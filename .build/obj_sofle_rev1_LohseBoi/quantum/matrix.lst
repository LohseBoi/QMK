   1               		.file	"matrix.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.setPinInputHigh_atomic,"ax",@progbits
  12               	setPinInputHigh_atomic:
  13               	.LVL0:
  14               	.LFB30:
  15               		.file 1 "quantum/matrix.c"
   1:quantum/matrix.c **** /*
   2:quantum/matrix.c **** Copyright 2012-2018 Jun Wako, Jack Humbert, Yiancar
   3:quantum/matrix.c **** 
   4:quantum/matrix.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/matrix.c **** it under the terms of the GNU General Public License as published by
   6:quantum/matrix.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/matrix.c **** (at your option) any later version.
   8:quantum/matrix.c **** 
   9:quantum/matrix.c **** This program is distributed in the hope that it will be useful,
  10:quantum/matrix.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/matrix.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/matrix.c **** GNU General Public License for more details.
  13:quantum/matrix.c **** 
  14:quantum/matrix.c **** You should have received a copy of the GNU General Public License
  15:quantum/matrix.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/matrix.c **** */
  17:quantum/matrix.c **** #include <stdint.h>
  18:quantum/matrix.c **** #include <stdbool.h>
  19:quantum/matrix.c **** #include <string.h>
  20:quantum/matrix.c **** #include "util.h"
  21:quantum/matrix.c **** #include "matrix.h"
  22:quantum/matrix.c **** #include "debounce.h"
  23:quantum/matrix.c **** #include "quantum.h"
  24:quantum/matrix.c **** #ifdef SPLIT_KEYBOARD
  25:quantum/matrix.c **** #    include "split_common/split_util.h"
  26:quantum/matrix.c **** #    include "split_common/transactions.h"
  27:quantum/matrix.c **** 
  28:quantum/matrix.c **** #    define ROWS_PER_HAND (MATRIX_ROWS / 2)
  29:quantum/matrix.c **** #else
  30:quantum/matrix.c **** #    define ROWS_PER_HAND (MATRIX_ROWS)
  31:quantum/matrix.c **** #endif
  32:quantum/matrix.c **** 
  33:quantum/matrix.c **** #ifdef DIRECT_PINS_RIGHT
  34:quantum/matrix.c **** #    define SPLIT_MUTABLE
  35:quantum/matrix.c **** #else
  36:quantum/matrix.c **** #    define SPLIT_MUTABLE const
  37:quantum/matrix.c **** #endif
  38:quantum/matrix.c **** #ifdef MATRIX_ROW_PINS_RIGHT
  39:quantum/matrix.c **** #    define SPLIT_MUTABLE_ROW
  40:quantum/matrix.c **** #else
  41:quantum/matrix.c **** #    define SPLIT_MUTABLE_ROW const
  42:quantum/matrix.c **** #endif
  43:quantum/matrix.c **** #ifdef MATRIX_COL_PINS_RIGHT
  44:quantum/matrix.c **** #    define SPLIT_MUTABLE_COL
  45:quantum/matrix.c **** #else
  46:quantum/matrix.c **** #    define SPLIT_MUTABLE_COL const
  47:quantum/matrix.c **** #endif
  48:quantum/matrix.c **** 
  49:quantum/matrix.c **** #ifdef DIRECT_PINS
  50:quantum/matrix.c **** static SPLIT_MUTABLE pin_t direct_pins[MATRIX_ROWS][MATRIX_COLS] = DIRECT_PINS;
  51:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL) || (DIODE_DIRECTION == COL2ROW)
  52:quantum/matrix.c **** #    ifdef MATRIX_ROW_PINS
  53:quantum/matrix.c **** static SPLIT_MUTABLE_ROW pin_t row_pins[MATRIX_ROWS] = MATRIX_ROW_PINS;
  54:quantum/matrix.c **** #    endif  // MATRIX_ROW_PINS
  55:quantum/matrix.c **** #    ifdef MATRIX_COL_PINS
  56:quantum/matrix.c **** static SPLIT_MUTABLE_COL pin_t col_pins[MATRIX_COLS] = MATRIX_COL_PINS;
  57:quantum/matrix.c **** #    endif  // MATRIX_COL_PINS
  58:quantum/matrix.c **** #endif
  59:quantum/matrix.c **** 
  60:quantum/matrix.c **** /* matrix state(1:on, 0:off) */
  61:quantum/matrix.c **** extern matrix_row_t raw_matrix[MATRIX_ROWS];  // raw values
  62:quantum/matrix.c **** extern matrix_row_t matrix[MATRIX_ROWS];      // debounced values
  63:quantum/matrix.c **** 
  64:quantum/matrix.c **** #ifdef SPLIT_KEYBOARD
  65:quantum/matrix.c **** // row offsets for each hand
  66:quantum/matrix.c **** uint8_t thisHand, thatHand;
  67:quantum/matrix.c **** #endif
  68:quantum/matrix.c **** 
  69:quantum/matrix.c **** // user-defined overridable functions
  70:quantum/matrix.c **** __attribute__((weak)) void matrix_init_pins(void);
  71:quantum/matrix.c **** __attribute__((weak)) void matrix_read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_r
  72:quantum/matrix.c **** __attribute__((weak)) void matrix_read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_c
  73:quantum/matrix.c **** #ifdef SPLIT_KEYBOARD
  74:quantum/matrix.c **** __attribute__((weak)) void matrix_slave_scan_kb(void) { matrix_slave_scan_user(); }
  75:quantum/matrix.c **** __attribute__((weak)) void matrix_slave_scan_user(void) {}
  76:quantum/matrix.c **** #endif
  77:quantum/matrix.c **** 
  78:quantum/matrix.c **** static inline void setPinOutput_writeLow(pin_t pin) {
  79:quantum/matrix.c ****     ATOMIC_BLOCK_FORCEON {
  80:quantum/matrix.c ****         setPinOutput(pin);
  81:quantum/matrix.c ****         writePinLow(pin);
  82:quantum/matrix.c ****     }
  83:quantum/matrix.c **** }
  84:quantum/matrix.c **** 
  85:quantum/matrix.c **** static inline void setPinInputHigh_atomic(pin_t pin) {
  16               		.loc 1 85 54 view -0
  17               		.cfi_startproc
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  86:quantum/matrix.c ****     ATOMIC_BLOCK_FORCEON { setPinInputHigh(pin); }
  22               		.loc 1 86 5 view .LVU1
  23               	.LBB13:
  24               		.loc 1 86 5 view .LVU2
  25               	.LBB14:
  26               	.LBI14:
  27               		.file 2 "/usr/avr/include/util/atomic.h"
   1:/usr/avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/avr/include/util/atomic.h **** 
   4:/usr/avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/avr/include/util/atomic.h **** 
   7:/usr/avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/avr/include/util/atomic.h **** 
  10:/usr/avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/avr/include/util/atomic.h ****      distribution.
  14:/usr/avr/include/util/atomic.h **** 
  15:/usr/avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/avr/include/util/atomic.h **** 
  19:/usr/avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/avr/include/util/atomic.h **** */
  31:/usr/avr/include/util/atomic.h **** 
  32:/usr/avr/include/util/atomic.h **** /* $Id: atomic.h 2158 2010-06-10 15:48:28Z joerg_wunsch $ */
  33:/usr/avr/include/util/atomic.h **** 
  34:/usr/avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/avr/include/util/atomic.h **** 
  37:/usr/avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/avr/include/util/atomic.h **** 
  40:/usr/avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/avr/include/util/atomic.h **** {
  44:/usr/avr/include/util/atomic.h ****     sei();
  45:/usr/avr/include/util/atomic.h ****     return 1;
  46:/usr/avr/include/util/atomic.h **** }
  47:/usr/avr/include/util/atomic.h **** 
  48:/usr/avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  28               		.loc 2 48 27 view .LVU3
  29               	.LBB15:
  49:/usr/avr/include/util/atomic.h **** {
  50:/usr/avr/include/util/atomic.h ****     cli();
  30               		.loc 2 50 5 view .LVU4
  31               	/* #APP */
  32               	 ;  50 "/usr/avr/include/util/atomic.h" 1
  33 0000 F894      		cli
  34               	 ;  0 "" 2
  51:/usr/avr/include/util/atomic.h ****     return 1;
  35               		.loc 2 51 5 view .LVU5
  36               	.LVL1:
  37               		.loc 2 51 5 is_stmt 0 view .LVU6
  38               	/* #NOAPP */
  39               	.LBE15:
  40               	.LBE14:
  41               		.loc 1 86 28 is_stmt 1 view .LVU7
  42 0002 E82F      		mov r30,r24
  43 0004 E295      		swap r30
  44 0006 EF70      		andi r30,lo8(15)
  45 0008 F0E0      		ldi r31,0
  46 000a 31A1      		ldd r19,Z+33
  47 000c 282F      		mov r18,r24
  48 000e 2F70      		andi r18,lo8(15)
  49 0010 81E0      		ldi r24,lo8(1)
  50 0012 90E0      		ldi r25,0
  51               	.LVL2:
  52               		.loc 1 86 28 is_stmt 0 view .LVU8
  53 0014 00C0      		rjmp 2f
  54               		1:
  55 0016 880F      		lsl r24
  56               		2:
  57 0018 2A95      		dec r18
  58 001a 02F4      		brpl 1b
  59 001c 982F      		mov r25,r24
  60 001e 9095      		com r25
  61 0020 9323      		and r25,r19
  62 0022 91A3      		std Z+33,r25
  63 0024 92A1      		ldd r25,Z+34
  64 0026 892B      		or r24,r25
  65 0028 82A3      		std Z+34,r24
  66               	.LVL3:
  67               	.LBB16:
  68               	.LBI16:
  52:/usr/avr/include/util/atomic.h **** }
  53:/usr/avr/include/util/atomic.h **** 
  54:/usr/avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  69               		.loc 2 54 24 is_stmt 1 view .LVU9
  70               	.LBB17:
  55:/usr/avr/include/util/atomic.h **** {
  56:/usr/avr/include/util/atomic.h ****     sei();
  71               		.loc 2 56 5 view .LVU10
  72               	/* #APP */
  73               	 ;  56 "/usr/avr/include/util/atomic.h" 1
  74 002a 7894      		sei
  75               	 ;  0 "" 2
  57:/usr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  76               		.loc 2 57 5 view .LVU11
  58:/usr/avr/include/util/atomic.h ****     (void)__s;
  77               		.loc 2 58 5 view .LVU12
  78               	.LVL4:
  79               	/* #NOAPP */
  80               	/* epilogue start */
  81               		.loc 2 58 5 is_stmt 0 view .LVU13
  82               	.LBE17:
  83               	.LBE16:
  84               	.LBE13:
  87:quantum/matrix.c **** }
  85               		.loc 1 87 1 view .LVU14
  86 002c 0895      		ret
  87               		.cfi_endproc
  88               	.LFE30:
  90               		.section	.text.matrix_slave_scan_user,"ax",@progbits
  91               		.weak	matrix_slave_scan_user
  93               	matrix_slave_scan_user:
  94               	.LFB28:
  75:quantum/matrix.c **** #endif
  95               		.loc 1 75 57 is_stmt 1 view -0
  96               		.cfi_startproc
  97               	/* prologue: function */
  98               	/* frame size = 0 */
  99               	/* stack size = 0 */
 100               	.L__stack_usage = 0
  75:quantum/matrix.c **** #endif
 101               		.loc 1 75 58 view .LVU16
 102               	/* epilogue start */
  75:quantum/matrix.c **** #endif
 103               		.loc 1 75 1 is_stmt 0 view .LVU17
 104 0000 0895      		ret
 105               		.cfi_endproc
 106               	.LFE28:
 108               		.section	.text.matrix_slave_scan_kb,"ax",@progbits
 109               		.weak	matrix_slave_scan_kb
 111               	matrix_slave_scan_kb:
 112               	.LFB27:
  74:quantum/matrix.c **** __attribute__((weak)) void matrix_slave_scan_user(void) {}
 113               		.loc 1 74 55 is_stmt 1 view -0
 114               		.cfi_startproc
 115               	/* prologue: function */
 116               	/* frame size = 0 */
 117               	/* stack size = 0 */
 118               	.L__stack_usage = 0
  74:quantum/matrix.c **** __attribute__((weak)) void matrix_slave_scan_user(void) {}
 119               		.loc 1 74 57 view .LVU19
 120 0000 0C94 0000 		jmp matrix_slave_scan_user
 121               	.LVL5:
 122               		.cfi_endproc
 123               	.LFE27:
 125               		.section	.text.matrix_init_pins,"ax",@progbits
 126               		.weak	matrix_init_pins
 128               	matrix_init_pins:
 129               	.LFB35:
  88:quantum/matrix.c **** 
  89:quantum/matrix.c **** static inline uint8_t readMatrixPin(pin_t pin) {
  90:quantum/matrix.c ****     if (pin != NO_PIN) {
  91:quantum/matrix.c ****         return readPin(pin);
  92:quantum/matrix.c ****     } else {
  93:quantum/matrix.c ****         return 1;
  94:quantum/matrix.c ****     }
  95:quantum/matrix.c **** }
  96:quantum/matrix.c **** 
  97:quantum/matrix.c **** // matrix code
  98:quantum/matrix.c **** 
  99:quantum/matrix.c **** #ifdef DIRECT_PINS
 100:quantum/matrix.c **** 
 101:quantum/matrix.c **** __attribute__((weak)) void matrix_init_pins(void) {
 102:quantum/matrix.c ****     for (int row = 0; row < MATRIX_ROWS; row++) {
 103:quantum/matrix.c ****         for (int col = 0; col < MATRIX_COLS; col++) {
 104:quantum/matrix.c ****             pin_t pin = direct_pins[row][col];
 105:quantum/matrix.c ****             if (pin != NO_PIN) {
 106:quantum/matrix.c ****                 setPinInputHigh(pin);
 107:quantum/matrix.c ****             }
 108:quantum/matrix.c ****         }
 109:quantum/matrix.c ****     }
 110:quantum/matrix.c **** }
 111:quantum/matrix.c **** 
 112:quantum/matrix.c **** __attribute__((weak)) void matrix_read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_r
 113:quantum/matrix.c ****     // Start with a clear matrix row
 114:quantum/matrix.c ****     matrix_row_t current_row_value = 0;
 115:quantum/matrix.c **** 
 116:quantum/matrix.c ****     for (uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 117:quantum/matrix.c ****         pin_t pin = direct_pins[current_row][col_index];
 118:quantum/matrix.c ****         if (pin != NO_PIN) {
 119:quantum/matrix.c ****             current_row_value |= readPin(pin) ? 0 : (MATRIX_ROW_SHIFTER << col_index);
 120:quantum/matrix.c ****         }
 121:quantum/matrix.c ****     }
 122:quantum/matrix.c **** 
 123:quantum/matrix.c ****     // Update the matrix
 124:quantum/matrix.c ****     current_matrix[current_row] = current_row_value;
 125:quantum/matrix.c **** }
 126:quantum/matrix.c **** 
 127:quantum/matrix.c **** #elif defined(DIODE_DIRECTION)
 128:quantum/matrix.c **** #    if defined(MATRIX_ROW_PINS) && defined(MATRIX_COL_PINS)
 129:quantum/matrix.c **** #        if (DIODE_DIRECTION == COL2ROW)
 130:quantum/matrix.c **** 
 131:quantum/matrix.c **** static bool select_row(uint8_t row) {
 132:quantum/matrix.c ****     pin_t pin = row_pins[row];
 133:quantum/matrix.c ****     if (pin != NO_PIN) {
 134:quantum/matrix.c ****         setPinOutput_writeLow(pin);
 135:quantum/matrix.c ****         return true;
 136:quantum/matrix.c ****     }
 137:quantum/matrix.c ****     return false;
 138:quantum/matrix.c **** }
 139:quantum/matrix.c **** 
 140:quantum/matrix.c **** static void unselect_row(uint8_t row) {
 141:quantum/matrix.c ****     pin_t pin = row_pins[row];
 142:quantum/matrix.c ****     if (pin != NO_PIN) {
 143:quantum/matrix.c ****         setPinInputHigh_atomic(pin);
 144:quantum/matrix.c ****     }
 145:quantum/matrix.c **** }
 146:quantum/matrix.c **** 
 147:quantum/matrix.c **** static void unselect_rows(void) {
 148:quantum/matrix.c ****     for (uint8_t x = 0; x < ROWS_PER_HAND; x++) {
 149:quantum/matrix.c ****         unselect_row(x);
 150:quantum/matrix.c ****     }
 151:quantum/matrix.c **** }
 152:quantum/matrix.c **** 
 153:quantum/matrix.c **** __attribute__((weak)) void matrix_init_pins(void) {
 130               		.loc 1 153 51 view -0
 131               		.cfi_startproc
 132 0000 0F93      		push r16
 133               	.LCFI0:
 134               		.cfi_def_cfa_offset 3
 135               		.cfi_offset 16, -2
 136 0002 1F93      		push r17
 137               	.LCFI1:
 138               		.cfi_def_cfa_offset 4
 139               		.cfi_offset 17, -3
 140 0004 CF93      		push r28
 141               	.LCFI2:
 142               		.cfi_def_cfa_offset 5
 143               		.cfi_offset 28, -4
 144 0006 DF93      		push r29
 145               	.LCFI3:
 146               		.cfi_def_cfa_offset 6
 147               		.cfi_offset 29, -5
 148               	/* prologue: function */
 149               	/* frame size = 0 */
 150               	/* stack size = 4 */
 151               	.L__stack_usage = 4
 154:quantum/matrix.c ****     unselect_rows();
 152               		.loc 1 154 5 view .LVU21
 153               	.LBB24:
 154               	.LBI24:
 147:quantum/matrix.c ****     for (uint8_t x = 0; x < ROWS_PER_HAND; x++) {
 155               		.loc 1 147 13 view .LVU22
 156               	.LBE24:
 148:quantum/matrix.c ****         unselect_row(x);
 157               		.loc 1 148 5 view .LVU23
 158               	.LBB28:
 159               	.LBB25:
 148:quantum/matrix.c ****         unselect_row(x);
 160               		.loc 1 148 10 view .LVU24
 161               	.LVL6:
 148:quantum/matrix.c ****         unselect_row(x);
 162               		.loc 1 148 10 is_stmt 0 view .LVU25
 163 0008 C0E0      		ldi r28,lo8(row_pins)
 164 000a D0E0      		ldi r29,hi8(row_pins)
 165               	.LVL7:
 166               	.L6:
 149:quantum/matrix.c ****     }
 167               		.loc 1 149 9 is_stmt 1 view .LVU26
 168               	.LBB26:
 169               	.LBI26:
 140:quantum/matrix.c ****     pin_t pin = row_pins[row];
 170               		.loc 1 140 13 view .LVU27
 171               	.LBB27:
 141:quantum/matrix.c ****     if (pin != NO_PIN) {
 172               		.loc 1 141 5 view .LVU28
 141:quantum/matrix.c ****     if (pin != NO_PIN) {
 173               		.loc 1 141 11 is_stmt 0 view .LVU29
 174 000c 8991      		ld r24,Y+
 175               	.LVL8:
 142:quantum/matrix.c ****         setPinInputHigh_atomic(pin);
 176               		.loc 1 142 5 is_stmt 1 view .LVU30
 142:quantum/matrix.c ****         setPinInputHigh_atomic(pin);
 177               		.loc 1 142 8 is_stmt 0 view .LVU31
 178 000e 8F3F      		cpi r24,lo8(-1)
 179 0010 01F0      		breq .L5
 143:quantum/matrix.c ****     }
 180               		.loc 1 143 9 is_stmt 1 view .LVU32
 181 0012 0E94 0000 		call setPinInputHigh_atomic
 182               	.LVL9:
 183               	.L5:
 143:quantum/matrix.c ****     }
 184               		.loc 1 143 9 is_stmt 0 view .LVU33
 185               	.LBE27:
 186               	.LBE26:
 148:quantum/matrix.c ****         unselect_row(x);
 187               		.loc 1 148 5 view .LVU34
 188 0016 80E0      		ldi r24,hi8(row_pins+5)
 189 0018 C030      		cpi r28,lo8(row_pins+5)
 190 001a D807      		cpc r29,r24
 191 001c 01F4      		brne .L6
 192 001e C0E0      		ldi r28,lo8(col_pins)
 193 0020 D0E0      		ldi r29,hi8(col_pins)
 194               	.LVL10:
 148:quantum/matrix.c ****         unselect_row(x);
 195               		.loc 1 148 5 view .LVU35
 196 0022 00E0      		ldi r16,lo8(col_pins+6)
 197 0024 10E0      		ldi r17,hi8(col_pins+6)
 198               	.L8:
 199               	.LVL11:
 148:quantum/matrix.c ****         unselect_row(x);
 200               		.loc 1 148 5 view .LVU36
 201               	.LBE25:
 202               	.LBE28:
 203               	.LBB29:
 155:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 156:quantum/matrix.c ****         if (col_pins[x] != NO_PIN) {
 204               		.loc 1 156 9 is_stmt 1 view .LVU37
 205               		.loc 1 156 21 is_stmt 0 view .LVU38
 206 0026 8991      		ld r24,Y+
 207               	.LVL12:
 208               		.loc 1 156 12 view .LVU39
 209 0028 8F3F      		cpi r24,lo8(-1)
 210 002a 01F0      		breq .L7
 157:quantum/matrix.c ****             setPinInputHigh_atomic(col_pins[x]);
 211               		.loc 1 157 13 is_stmt 1 view .LVU40
 212 002c 0E94 0000 		call setPinInputHigh_atomic
 213               	.LVL13:
 214               	.L7:
 155:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 215               		.loc 1 155 5 is_stmt 0 discriminator 2 view .LVU41
 216 0030 0C17      		cp r16,r28
 217 0032 1D07      		cpc r17,r29
 218 0034 01F4      		brne .L8
 219               	/* epilogue start */
 220               	.LBE29:
 158:quantum/matrix.c ****         }
 159:quantum/matrix.c ****     }
 160:quantum/matrix.c **** }
 221               		.loc 1 160 1 view .LVU42
 222 0036 DF91      		pop r29
 223 0038 CF91      		pop r28
 224               	.LVL14:
 225               		.loc 1 160 1 view .LVU43
 226 003a 1F91      		pop r17
 227 003c 0F91      		pop r16
 228 003e 0895      		ret
 229               		.cfi_endproc
 230               	.LFE35:
 232               		.section	.text.matrix_read_cols_on_row,"ax",@progbits
 233               		.weak	matrix_read_cols_on_row
 235               	matrix_read_cols_on_row:
 236               	.LVL15:
 237               	.LFB36:
 161:quantum/matrix.c **** 
 162:quantum/matrix.c **** __attribute__((weak)) void matrix_read_cols_on_row(matrix_row_t current_matrix[], uint8_t current_r
 238               		.loc 1 162 104 is_stmt 1 view -0
 239               		.cfi_startproc
 240               		.loc 1 162 104 is_stmt 0 view .LVU45
 241 0000 CF92      		push r12
 242               	.LCFI4:
 243               		.cfi_def_cfa_offset 3
 244               		.cfi_offset 12, -2
 245 0002 DF92      		push r13
 246               	.LCFI5:
 247               		.cfi_def_cfa_offset 4
 248               		.cfi_offset 13, -3
 249 0004 EF92      		push r14
 250               	.LCFI6:
 251               		.cfi_def_cfa_offset 5
 252               		.cfi_offset 14, -4
 253 0006 FF92      		push r15
 254               	.LCFI7:
 255               		.cfi_def_cfa_offset 6
 256               		.cfi_offset 15, -5
 257 0008 0F93      		push r16
 258               	.LCFI8:
 259               		.cfi_def_cfa_offset 7
 260               		.cfi_offset 16, -6
 261 000a 1F93      		push r17
 262               	.LCFI9:
 263               		.cfi_def_cfa_offset 8
 264               		.cfi_offset 17, -7
 265 000c CF93      		push r28
 266               	.LCFI10:
 267               		.cfi_def_cfa_offset 9
 268               		.cfi_offset 28, -8
 269 000e DF93      		push r29
 270               	.LCFI11:
 271               		.cfi_def_cfa_offset 10
 272               		.cfi_offset 29, -9
 273               	/* prologue: function */
 274               	/* frame size = 0 */
 275               	/* stack size = 8 */
 276               	.L__stack_usage = 8
 277 0010 EC01      		movw r28,r24
 278 0012 D62E      		mov r13,r22
 163:quantum/matrix.c ****     // Start with a clear matrix row
 164:quantum/matrix.c ****     matrix_row_t current_row_value = 0;
 279               		.loc 1 164 5 is_stmt 1 view .LVU46
 280               	.LVL16:
 165:quantum/matrix.c **** 
 166:quantum/matrix.c ****     if (!select_row(current_row)) {  // Select row
 281               		.loc 1 166 5 view .LVU47
 282               	.LBB45:
 283               	.LBI45:
 131:quantum/matrix.c ****     pin_t pin = row_pins[row];
 284               		.loc 1 131 13 view .LVU48
 285               	.LBB46:
 132:quantum/matrix.c ****     if (pin != NO_PIN) {
 286               		.loc 1 132 5 view .LVU49
 132:quantum/matrix.c ****     if (pin != NO_PIN) {
 287               		.loc 1 132 25 is_stmt 0 view .LVU50
 288 0014 062F      		mov r16,r22
 289 0016 10E0      		ldi r17,0
 132:quantum/matrix.c ****     if (pin != NO_PIN) {
 290               		.loc 1 132 11 view .LVU51
 291 0018 C801      		movw r24,r16
 292               	.LVL17:
 132:quantum/matrix.c ****     if (pin != NO_PIN) {
 293               		.loc 1 132 11 view .LVU52
 294 001a 8050      		subi r24,lo8(-(row_pins))
 295 001c 9040      		sbci r25,hi8(-(row_pins))
 296 001e 7C01      		movw r14,r24
 297 0020 FC01      		movw r30,r24
 298 0022 8081      		ld r24,Z
 299               	.LVL18:
 133:quantum/matrix.c ****         setPinOutput_writeLow(pin);
 300               		.loc 1 133 5 is_stmt 1 view .LVU53
 133:quantum/matrix.c ****         setPinOutput_writeLow(pin);
 301               		.loc 1 133 8 is_stmt 0 view .LVU54
 302 0024 8F3F      		cpi r24,lo8(-1)
 303 0026 01F4      		brne .+2
 304 0028 00C0      		rjmp .L17
 134:quantum/matrix.c ****         return true;
 305               		.loc 1 134 9 is_stmt 1 view .LVU55
 306               	.LVL19:
 307               	.LBB47:
 308               	.LBI47:
  78:quantum/matrix.c ****     ATOMIC_BLOCK_FORCEON {
 309               		.loc 1 78 20 view .LVU56
 310               	.LBE47:
 311               	.LBE46:
 312               	.LBE45:
  79:quantum/matrix.c ****         setPinOutput(pin);
 313               		.loc 1 79 5 view .LVU57
 314               	.LBB55:
 315               	.LBB54:
 316               	.LBB53:
 317               	.LBB48:
  79:quantum/matrix.c ****         setPinOutput(pin);
 318               		.loc 1 79 5 view .LVU58
 319               	.LBB49:
 320               	.LBI49:
  48:/usr/avr/include/util/atomic.h **** {
 321               		.loc 2 48 27 view .LVU59
 322               	.LBB50:
  50:/usr/avr/include/util/atomic.h ****     return 1;
 323               		.loc 2 50 5 view .LVU60
 324               	/* #APP */
 325               	 ;  50 "/usr/avr/include/util/atomic.h" 1
 326 002a F894      		cli
 327               	 ;  0 "" 2
  51:/usr/avr/include/util/atomic.h **** }
 328               		.loc 2 51 5 view .LVU61
 329               	.LVL20:
  51:/usr/avr/include/util/atomic.h **** }
 330               		.loc 2 51 5 is_stmt 0 view .LVU62
 331               	/* #NOAPP */
 332               	.LBE50:
 333               	.LBE49:
  80:quantum/matrix.c ****         writePinLow(pin);
 334               		.loc 1 80 9 is_stmt 1 view .LVU63
 335 002c E82F      		mov r30,r24
 336 002e E295      		swap r30
 337 0030 EF70      		andi r30,lo8(15)
 338 0032 F0E0      		ldi r31,0
 339 0034 91A1      		ldd r25,Z+33
 340 0036 8F70      		andi r24,lo8(15)
 341               	.LVL21:
  80:quantum/matrix.c ****         writePinLow(pin);
 342               		.loc 1 80 9 is_stmt 0 view .LVU64
 343 0038 21E0      		ldi r18,lo8(1)
 344 003a 30E0      		ldi r19,0
 345 003c 00C0      		rjmp 2f
 346               		1:
 347 003e 220F      		lsl r18
 348               		2:
 349 0040 8A95      		dec r24
 350 0042 02F4      		brpl 1b
 351 0044 892F      		mov r24,r25
 352 0046 822B      		or r24,r18
 353 0048 81A3      		std Z+33,r24
  81:quantum/matrix.c ****     }
 354               		.loc 1 81 9 is_stmt 1 view .LVU65
 355 004a 82A1      		ldd r24,Z+34
 356 004c 2095      		com r18
 357 004e 2823      		and r18,r24
 358 0050 22A3      		std Z+34,r18
 359               	.LVL22:
 360               	.LBB51:
 361               	.LBI51:
  54:/usr/avr/include/util/atomic.h **** {
 362               		.loc 2 54 24 view .LVU66
 363               	.LBB52:
  56:/usr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 364               		.loc 2 56 5 view .LVU67
 365               	/* #APP */
 366               	 ;  56 "/usr/avr/include/util/atomic.h" 1
 367 0052 7894      		sei
 368               	 ;  0 "" 2
  57:/usr/avr/include/util/atomic.h ****     (void)__s;
 369               		.loc 2 57 5 view .LVU68
 370               		.loc 2 58 5 view .LVU69
 371               	.LVL23:
 372               		.loc 2 58 5 is_stmt 0 view .LVU70
 373               	/* #NOAPP */
 374               	.LBE52:
 375               	.LBE51:
 376               	.LBE48:
 377               	.LBE53:
 378               	.LBE54:
 379               	.LBE55:
 167:quantum/matrix.c ****         return;                      // skip NO_PIN row
 168:quantum/matrix.c ****     }
 169:quantum/matrix.c ****     matrix_output_select_delay();
 380               		.loc 1 169 5 is_stmt 1 view .LVU71
 381 0054 0E94 0000 		call matrix_output_select_delay
 382               	.LVL24:
 170:quantum/matrix.c **** 
 171:quantum/matrix.c ****     // For each col...
 172:quantum/matrix.c ****     for (uint8_t col_index = 0; col_index < MATRIX_COLS; col_index++) {
 383               		.loc 1 172 5 view .LVU72
 384               	.LBB56:
 385               		.loc 1 172 10 view .LVU73
 386               		.loc 1 172 10 is_stmt 0 view .LVU74
 387 0058 E0E0      		ldi r30,lo8(col_pins)
 388 005a F0E0      		ldi r31,hi8(col_pins)
 389               	.LBE56:
 169:quantum/matrix.c **** 
 390               		.loc 1 169 5 view .LVU75
 391 005c 30E0      		ldi r19,0
 392 005e 20E0      		ldi r18,0
 164:quantum/matrix.c **** 
 393               		.loc 1 164 18 view .LVU76
 394 0060 C12C      		mov r12,__zero_reg__
 395               	.LBB63:
 396               	.LBB57:
 173:quantum/matrix.c ****         uint8_t pin_state = readMatrixPin(col_pins[col_index]);
 174:quantum/matrix.c **** 
 175:quantum/matrix.c ****         // Populate the matrix row with the state of the col pin
 176:quantum/matrix.c ****         current_row_value |= pin_state ? 0 : (MATRIX_ROW_SHIFTER << col_index);
 397               		.loc 1 176 66 view .LVU77
 398 0062 51E0      		ldi r21,lo8(1)
 399               	.LVL25:
 400               	.L20:
 173:quantum/matrix.c ****         uint8_t pin_state = readMatrixPin(col_pins[col_index]);
 401               		.loc 1 173 9 is_stmt 1 view .LVU78
 173:quantum/matrix.c ****         uint8_t pin_state = readMatrixPin(col_pins[col_index]);
 402               		.loc 1 173 29 is_stmt 0 view .LVU79
 403 0064 4191      		ld r20,Z+
 404               	.LVL26:
 405               	.LBB58:
 406               	.LBI58:
  89:quantum/matrix.c ****     if (pin != NO_PIN) {
 407               		.loc 1 89 23 is_stmt 1 view .LVU80
 408               	.LBB59:
  90:quantum/matrix.c ****         return readPin(pin);
 409               		.loc 1 90 5 view .LVU81
  90:quantum/matrix.c ****         return readPin(pin);
 410               		.loc 1 90 8 is_stmt 0 view .LVU82
 411 0066 4F3F      		cpi r20,lo8(-1)
 412 0068 01F0      		breq .L24
  91:quantum/matrix.c ****     } else {
 413               		.loc 1 91 9 is_stmt 1 view .LVU83
  91:quantum/matrix.c ****     } else {
 414               		.loc 1 91 16 is_stmt 0 view .LVU84
 415 006a A42F      		mov r26,r20
 416 006c A295      		swap r26
 417 006e AF70      		andi r26,lo8(15)
 418 0070 B0E0      		ldi r27,0
 419 0072 9096      		adiw r26,32
 420 0074 8C91      		ld r24,X
 421               	.LVL27:
  91:quantum/matrix.c ****     } else {
 422               		.loc 1 91 16 view .LVU85
 423               	.LBE59:
 424               	.LBE58:
 425               		.loc 1 176 9 is_stmt 1 view .LVU86
 426               	.LBB61:
 427               	.LBB60:
  91:quantum/matrix.c ****     } else {
 428               		.loc 1 91 16 is_stmt 0 view .LVU87
 429 0076 90E0      		ldi r25,0
 430 0078 4F70      		andi r20,lo8(15)
 431               	.LVL28:
  91:quantum/matrix.c ****     } else {
 432               		.loc 1 91 16 view .LVU88
 433 007a 00C0      		rjmp 2f
 434               		1:
 435 007c 9595      		asr r25
 436 007e 8795      		ror r24
 437               		2:
 438 0080 4A95      		dec r20
 439 0082 02F4      		brpl 1b
 440               	.LVL29:
  91:quantum/matrix.c ****     } else {
 441               		.loc 1 91 16 view .LVU89
 442               	.LBE60:
 443               	.LBE61:
 444               		.loc 1 176 27 view .LVU90
 445 0084 80FD      		sbrc r24,0
 446 0086 00C0      		rjmp .L24
 447               		.loc 1 176 27 discriminator 1 view .LVU91
 448 0088 852F      		mov r24,r21
 449 008a 022E      		mov r0,r18
 450 008c 00C0      		rjmp 2f
 451               		1:
 452 008e 880F      		lsl r24
 453               		2:
 454 0090 0A94      		dec r0
 455 0092 02F4      		brpl 1b
 456               	.L19:
 457               		.loc 1 176 27 discriminator 4 view .LVU92
 458 0094 C82A      		or r12,r24
 459               	.LVL30:
 460               		.loc 1 176 27 discriminator 4 view .LVU93
 461 0096 2F5F      		subi r18,-1
 462 0098 3F4F      		sbci r19,-1
 463               	.LVL31:
 464               		.loc 1 176 27 discriminator 4 view .LVU94
 465               	.LBE57:
 172:quantum/matrix.c ****         uint8_t pin_state = readMatrixPin(col_pins[col_index]);
 466               		.loc 1 172 5 discriminator 4 view .LVU95
 467 009a 2630      		cpi r18,6
 468 009c 3105      		cpc r19,__zero_reg__
 469 009e 01F4      		brne .L20
 470               	.LBE63:
 177:quantum/matrix.c ****     }
 178:quantum/matrix.c **** 
 179:quantum/matrix.c ****     // Unselect row
 180:quantum/matrix.c ****     unselect_row(current_row);
 471               		.loc 1 180 5 is_stmt 1 view .LVU96
 472               	.LVL32:
 473               	.LBB64:
 474               	.LBI64:
 140:quantum/matrix.c ****     pin_t pin = row_pins[row];
 475               		.loc 1 140 13 view .LVU97
 476               	.LBB65:
 141:quantum/matrix.c ****     if (pin != NO_PIN) {
 477               		.loc 1 141 5 view .LVU98
 141:quantum/matrix.c ****     if (pin != NO_PIN) {
 478               		.loc 1 141 11 is_stmt 0 view .LVU99
 479 00a0 F701      		movw r30,r14
 480 00a2 8081      		ld r24,Z
 481               	.LVL33:
 142:quantum/matrix.c ****         setPinInputHigh_atomic(pin);
 482               		.loc 1 142 5 is_stmt 1 view .LVU100
 142:quantum/matrix.c ****         setPinInputHigh_atomic(pin);
 483               		.loc 1 142 8 is_stmt 0 view .LVU101
 484 00a4 8F3F      		cpi r24,lo8(-1)
 485 00a6 01F0      		breq .L21
 143:quantum/matrix.c ****     }
 486               		.loc 1 143 9 is_stmt 1 view .LVU102
 487 00a8 0E94 0000 		call setPinInputHigh_atomic
 488               	.LVL34:
 489               	.L21:
 143:quantum/matrix.c ****     }
 490               		.loc 1 143 9 is_stmt 0 view .LVU103
 491               	.LBE65:
 492               	.LBE64:
 181:quantum/matrix.c ****     matrix_output_unselect_delay(current_row, current_row_value != 0);  // wait for all Col signals
 493               		.loc 1 181 5 is_stmt 1 view .LVU104
 494 00ac 61E0      		ldi r22,lo8(1)
 495 00ae C110      		cpse r12,__zero_reg__
 496 00b0 00C0      		rjmp .L22
 497 00b2 60E0      		ldi r22,0
 498               	.L22:
 499 00b4 8D2D      		mov r24,r13
 500 00b6 0E94 0000 		call matrix_output_unselect_delay
 501               	.LVL35:
 182:quantum/matrix.c **** 
 183:quantum/matrix.c ****     // Update the matrix
 184:quantum/matrix.c ****     current_matrix[current_row] = current_row_value;
 502               		.loc 1 184 5 view .LVU105
 503               		.loc 1 184 33 is_stmt 0 view .LVU106
 504 00ba C00F      		add r28,r16
 505 00bc D11F      		adc r29,r17
 506               	.LVL36:
 507               		.loc 1 184 33 view .LVU107
 508 00be C882      		st Y,r12
 509               	.LVL37:
 510               	.L17:
 511               	/* epilogue start */
 185:quantum/matrix.c **** }
 512               		.loc 1 185 1 view .LVU108
 513 00c0 DF91      		pop r29
 514 00c2 CF91      		pop r28
 515 00c4 1F91      		pop r17
 516 00c6 0F91      		pop r16
 517 00c8 FF90      		pop r15
 518 00ca EF90      		pop r14
 519 00cc DF90      		pop r13
 520               	.LVL38:
 521               		.loc 1 185 1 view .LVU109
 522 00ce CF90      		pop r12
 523 00d0 0895      		ret
 524               	.LVL39:
 525               	.L24:
 526               	.LBB66:
 527               	.LBB62:
 176:quantum/matrix.c ****     }
 528               		.loc 1 176 27 view .LVU110
 529 00d2 80E0      		ldi r24,0
 530 00d4 00C0      		rjmp .L19
 531               	.LBE62:
 532               	.LBE66:
 533               		.cfi_endproc
 534               	.LFE36:
 536               		.section	.text.matrix_init,"ax",@progbits
 537               	.global	matrix_init
 539               	matrix_init:
 540               	.LFB37:
 186:quantum/matrix.c **** 
 187:quantum/matrix.c **** #        elif (DIODE_DIRECTION == ROW2COL)
 188:quantum/matrix.c **** 
 189:quantum/matrix.c **** static bool select_col(uint8_t col) {
 190:quantum/matrix.c ****     pin_t pin = col_pins[col];
 191:quantum/matrix.c ****     if (pin != NO_PIN) {
 192:quantum/matrix.c ****         setPinOutput_writeLow(pin);
 193:quantum/matrix.c ****         return true;
 194:quantum/matrix.c ****     }
 195:quantum/matrix.c ****     return false;
 196:quantum/matrix.c **** }
 197:quantum/matrix.c **** 
 198:quantum/matrix.c **** static void unselect_col(uint8_t col) {
 199:quantum/matrix.c ****     pin_t pin = col_pins[col];
 200:quantum/matrix.c ****     if (pin != NO_PIN) {
 201:quantum/matrix.c ****         setPinInputHigh_atomic(pin);
 202:quantum/matrix.c ****     }
 203:quantum/matrix.c **** }
 204:quantum/matrix.c **** 
 205:quantum/matrix.c **** static void unselect_cols(void) {
 206:quantum/matrix.c ****     for (uint8_t x = 0; x < MATRIX_COLS; x++) {
 207:quantum/matrix.c ****         unselect_col(x);
 208:quantum/matrix.c ****     }
 209:quantum/matrix.c **** }
 210:quantum/matrix.c **** 
 211:quantum/matrix.c **** __attribute__((weak)) void matrix_init_pins(void) {
 212:quantum/matrix.c ****     unselect_cols();
 213:quantum/matrix.c ****     for (uint8_t x = 0; x < ROWS_PER_HAND; x++) {
 214:quantum/matrix.c ****         if (row_pins[x] != NO_PIN) {
 215:quantum/matrix.c ****             setPinInputHigh_atomic(row_pins[x]);
 216:quantum/matrix.c ****         }
 217:quantum/matrix.c ****     }
 218:quantum/matrix.c **** }
 219:quantum/matrix.c **** 
 220:quantum/matrix.c **** __attribute__((weak)) void matrix_read_rows_on_col(matrix_row_t current_matrix[], uint8_t current_c
 221:quantum/matrix.c ****     bool key_pressed = false;
 222:quantum/matrix.c **** 
 223:quantum/matrix.c ****     // Select col
 224:quantum/matrix.c ****     if (!select_col(current_col)) {  // select col
 225:quantum/matrix.c ****         return;                      // skip NO_PIN col
 226:quantum/matrix.c ****     }
 227:quantum/matrix.c ****     matrix_output_select_delay();
 228:quantum/matrix.c **** 
 229:quantum/matrix.c ****     // For each row...
 230:quantum/matrix.c ****     for (uint8_t row_index = 0; row_index < ROWS_PER_HAND; row_index++) {
 231:quantum/matrix.c ****         // Check row pin state
 232:quantum/matrix.c ****         if (readMatrixPin(row_pins[row_index]) == 0) {
 233:quantum/matrix.c ****             // Pin LO, set col bit
 234:quantum/matrix.c ****             current_matrix[row_index] |= (MATRIX_ROW_SHIFTER << current_col);
 235:quantum/matrix.c ****             key_pressed = true;
 236:quantum/matrix.c ****         } else {
 237:quantum/matrix.c ****             // Pin HI, clear col bit
 238:quantum/matrix.c ****             current_matrix[row_index] &= ~(MATRIX_ROW_SHIFTER << current_col);
 239:quantum/matrix.c ****         }
 240:quantum/matrix.c ****     }
 241:quantum/matrix.c **** 
 242:quantum/matrix.c ****     // Unselect col
 243:quantum/matrix.c ****     unselect_col(current_col);
 244:quantum/matrix.c ****     matrix_output_unselect_delay(current_col, key_pressed);  // wait for all Row signals to go HIGH
 245:quantum/matrix.c **** }
 246:quantum/matrix.c **** 
 247:quantum/matrix.c **** #        else
 248:quantum/matrix.c **** #            error DIODE_DIRECTION must be one of COL2ROW or ROW2COL!
 249:quantum/matrix.c **** #        endif
 250:quantum/matrix.c **** #    endif  // defined(MATRIX_ROW_PINS) && defined(MATRIX_COL_PINS)
 251:quantum/matrix.c **** #else
 252:quantum/matrix.c **** #    error DIODE_DIRECTION is not defined!
 253:quantum/matrix.c **** #endif
 254:quantum/matrix.c **** 
 255:quantum/matrix.c **** void matrix_init(void) {
 541               		.loc 1 255 24 is_stmt 1 view -0
 542               		.cfi_startproc
 543               	/* prologue: function */
 544               	/* frame size = 0 */
 545               	/* stack size = 0 */
 546               	.L__stack_usage = 0
 256:quantum/matrix.c **** #ifdef SPLIT_KEYBOARD
 257:quantum/matrix.c ****     split_pre_init();
 547               		.loc 1 257 5 view .LVU112
 548 0000 0E94 0000 		call split_pre_init
 549               	.LVL40:
 258:quantum/matrix.c **** 
 259:quantum/matrix.c ****     // Set pinout for right half if pinout for that half is defined
 260:quantum/matrix.c ****     if (!isLeftHand) {
 550               		.loc 1 260 5 view .LVU113
 551               		.loc 1 260 9 is_stmt 0 view .LVU114
 552 0004 8091 0000 		lds r24,isLeftHand
 261:quantum/matrix.c **** #    ifdef DIRECT_PINS_RIGHT
 262:quantum/matrix.c ****         const pin_t direct_pins_right[MATRIX_ROWS][MATRIX_COLS] = DIRECT_PINS_RIGHT;
 263:quantum/matrix.c ****         for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 264:quantum/matrix.c ****             for (uint8_t j = 0; j < MATRIX_COLS; j++) {
 265:quantum/matrix.c ****                 direct_pins[i][j] = direct_pins_right[i][j];
 266:quantum/matrix.c ****             }
 267:quantum/matrix.c ****         }
 268:quantum/matrix.c **** #    endif
 269:quantum/matrix.c **** #    ifdef MATRIX_ROW_PINS_RIGHT
 270:quantum/matrix.c ****         const pin_t row_pins_right[MATRIX_ROWS] = MATRIX_ROW_PINS_RIGHT;
 271:quantum/matrix.c ****         for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 272:quantum/matrix.c ****             row_pins[i] = row_pins_right[i];
 273:quantum/matrix.c ****         }
 274:quantum/matrix.c **** #    endif
 275:quantum/matrix.c **** #    ifdef MATRIX_COL_PINS_RIGHT
 276:quantum/matrix.c ****         const pin_t col_pins_right[MATRIX_COLS] = MATRIX_COL_PINS_RIGHT;
 277:quantum/matrix.c ****         for (uint8_t i = 0; i < MATRIX_COLS; i++) {
 278:quantum/matrix.c ****             col_pins[i] = col_pins_right[i];
 279:quantum/matrix.c ****         }
 280:quantum/matrix.c **** #    endif
 281:quantum/matrix.c ****     }
 553               		.loc 1 281 5 is_stmt 1 view .LVU115
 282:quantum/matrix.c **** 
 283:quantum/matrix.c ****     thisHand = isLeftHand ? 0 : (ROWS_PER_HAND);
 554               		.loc 1 283 5 view .LVU116
 555               		.loc 1 283 27 is_stmt 0 view .LVU117
 556 0008 8091 0000 		lds r24,isLeftHand
 557               		.loc 1 283 14 view .LVU118
 558 000c 95E0      		ldi r25,lo8(5)
 559 000e 8111      		cpse r24,__zero_reg__
 560 0010 90E0      		ldi r25,0
 561               	.L33:
 562               		.loc 1 283 14 discriminator 4 view .LVU119
 563 0012 9093 0000 		sts thisHand,r25
 284:quantum/matrix.c ****     thatHand = ROWS_PER_HAND - thisHand;
 564               		.loc 1 284 5 is_stmt 1 discriminator 4 view .LVU120
 565               		.loc 1 284 30 is_stmt 0 discriminator 4 view .LVU121
 566 0016 85E0      		ldi r24,lo8(5)
 567 0018 891B      		sub r24,r25
 568               		.loc 1 284 14 discriminator 4 view .LVU122
 569 001a 8093 0000 		sts thatHand,r24
 285:quantum/matrix.c **** #endif
 286:quantum/matrix.c **** 
 287:quantum/matrix.c ****     // initialize key pins
 288:quantum/matrix.c ****     matrix_init_pins();
 570               		.loc 1 288 5 is_stmt 1 discriminator 4 view .LVU123
 571 001e 0E94 0000 		call matrix_init_pins
 572               	.LVL41:
 289:quantum/matrix.c **** 
 290:quantum/matrix.c ****     // initialize matrix state: all keys off
 291:quantum/matrix.c ****     for (uint8_t i = 0; i < MATRIX_ROWS; i++) {
 573               		.loc 1 291 5 discriminator 4 view .LVU124
 574               	.LBB67:
 575               		.loc 1 291 10 discriminator 4 view .LVU125
 576               		.loc 1 291 10 is_stmt 0 discriminator 4 view .LVU126
 577 0022 E0E0      		ldi r30,lo8(raw_matrix)
 578 0024 F0E0      		ldi r31,hi8(raw_matrix)
 579 0026 A0E0      		ldi r26,lo8(matrix)
 580 0028 B0E0      		ldi r27,hi8(matrix)
 581               	.LVL42:
 582               	.L34:
 292:quantum/matrix.c ****         raw_matrix[i] = 0;
 583               		.loc 1 292 9 is_stmt 1 discriminator 3 view .LVU127
 584               		.loc 1 292 23 is_stmt 0 discriminator 3 view .LVU128
 585 002a 1192      		st Z+,__zero_reg__
 586               	.LVL43:
 293:quantum/matrix.c ****         matrix[i]     = 0;
 587               		.loc 1 293 9 is_stmt 1 discriminator 3 view .LVU129
 588               		.loc 1 293 23 is_stmt 0 discriminator 3 view .LVU130
 589 002c 1D92      		st X+,__zero_reg__
 590               	.LVL44:
 291:quantum/matrix.c ****         raw_matrix[i] = 0;
 591               		.loc 1 291 5 discriminator 3 view .LVU131
 592 002e 80E0      		ldi r24,hi8(raw_matrix+10)
 593 0030 E030      		cpi r30,lo8(raw_matrix+10)
 594 0032 F807      		cpc r31,r24
 595 0034 01F4      		brne .L34
 596               	.LBE67:
 294:quantum/matrix.c ****     }
 295:quantum/matrix.c **** 
 296:quantum/matrix.c ****     debounce_init(ROWS_PER_HAND);
 597               		.loc 1 296 5 is_stmt 1 view .LVU132
 598 0036 85E0      		ldi r24,lo8(5)
 599 0038 0E94 0000 		call debounce_init
 600               	.LVL45:
 297:quantum/matrix.c **** 
 298:quantum/matrix.c ****     matrix_init_quantum();
 601               		.loc 1 298 5 view .LVU133
 602 003c 0E94 0000 		call matrix_init_quantum
 603               	.LVL46:
 299:quantum/matrix.c **** 
 300:quantum/matrix.c **** #ifdef SPLIT_KEYBOARD
 301:quantum/matrix.c ****     split_post_init();
 604               		.loc 1 301 5 view .LVU134
 605 0040 0C94 0000 		jmp split_post_init
 606               	.LVL47:
 607               		.cfi_endproc
 608               	.LFE37:
 610               		.section	.text.transport_master_if_connected,"ax",@progbits
 611               		.weak	transport_master_if_connected
 613               	transport_master_if_connected:
 614               	.LVL48:
 615               	.LFB38:
 302:quantum/matrix.c **** #endif
 303:quantum/matrix.c **** }
 304:quantum/matrix.c **** 
 305:quantum/matrix.c **** #ifdef SPLIT_KEYBOARD
 306:quantum/matrix.c **** // Fallback implementation for keyboards not using the standard split_util.c
 307:quantum/matrix.c **** __attribute__((weak)) bool transport_master_if_connected(matrix_row_t master_matrix[], matrix_row_t
 616               		.loc 1 307 117 view -0
 617               		.cfi_startproc
 618               	/* prologue: function */
 619               	/* frame size = 0 */
 620               	/* stack size = 0 */
 621               	.L__stack_usage = 0
 308:quantum/matrix.c ****     transport_master(master_matrix, slave_matrix);
 622               		.loc 1 308 5 view .LVU136
 623 0000 0E94 0000 		call transport_master
 624               	.LVL49:
 309:quantum/matrix.c ****     return true;  // Treat the transport as always connected
 625               		.loc 1 309 5 view .LVU137
 310:quantum/matrix.c **** }
 626               		.loc 1 310 1 is_stmt 0 view .LVU138
 627 0004 81E0      		ldi r24,lo8(1)
 628               	/* epilogue start */
 629 0006 0895      		ret
 630               		.cfi_endproc
 631               	.LFE38:
 633               		.section	.text.matrix_post_scan,"ax",@progbits
 634               	.global	matrix_post_scan
 636               	matrix_post_scan:
 637               	.LFB39:
 311:quantum/matrix.c **** 
 312:quantum/matrix.c **** bool matrix_post_scan(void) {
 638               		.loc 1 312 29 is_stmt 1 view -0
 639               		.cfi_startproc
 640 0000 FF92      		push r15
 641               	.LCFI12:
 642               		.cfi_def_cfa_offset 3
 643               		.cfi_offset 15, -2
 644 0002 0F93      		push r16
 645               	.LCFI13:
 646               		.cfi_def_cfa_offset 4
 647               		.cfi_offset 16, -3
 648 0004 1F93      		push r17
 649               	.LCFI14:
 650               		.cfi_def_cfa_offset 5
 651               		.cfi_offset 17, -4
 652 0006 CF93      		push r28
 653               	.LCFI15:
 654               		.cfi_def_cfa_offset 6
 655               		.cfi_offset 28, -5
 656 0008 DF93      		push r29
 657               	.LCFI16:
 658               		.cfi_def_cfa_offset 7
 659               		.cfi_offset 29, -6
 660 000a 00D0      		rcall .
 661 000c 00D0      		rcall .
 662 000e 0F92      		push __tmp_reg__
 663               	.LCFI17:
 664               		.cfi_def_cfa_offset 12
 665 0010 CDB7      		in r28,__SP_L__
 666 0012 DEB7      		in r29,__SP_H__
 667               	.LCFI18:
 668               		.cfi_def_cfa_register 28
 669               	/* prologue: function */
 670               	/* frame size = 5 */
 671               	/* stack size = 10 */
 672               	.L__stack_usage = 10
 313:quantum/matrix.c ****     bool changed = false;
 673               		.loc 1 313 5 view .LVU140
 674               	.LVL50:
 314:quantum/matrix.c ****     if (is_keyboard_master()) {
 675               		.loc 1 314 5 view .LVU141
 676               		.loc 1 314 9 is_stmt 0 view .LVU142
 677 0014 0E94 0000 		call is_keyboard_master
 678               	.LVL51:
 679 0018 F82E      		mov r15,r24
 680 001a 6091 0000 		lds r22,thisHand
 681               		.loc 1 314 8 view .LVU143
 682 001e 8823      		tst r24
 683 0020 01F4      		brne .+2
 684 0022 00C0      		rjmp .L39
 685               	.LBB68:
 315:quantum/matrix.c ****         matrix_row_t slave_matrix[ROWS_PER_HAND] = {0};
 686               		.loc 1 315 9 is_stmt 1 view .LVU144
 687               		.loc 1 315 22 is_stmt 0 view .LVU145
 688 0024 8E01      		movw r16,r28
 689 0026 0F5F      		subi r16,-1
 690 0028 1F4F      		sbci r17,-1
 691 002a 85E0      		ldi r24,lo8(5)
 692 002c F801      		movw r30,r16
 693               		0:
 694 002e 1192      		st Z+,__zero_reg__
 695 0030 8A95      		dec r24
 696 0032 01F4      		brne 0b
 316:quantum/matrix.c ****         if (transport_master_if_connected(matrix + thisHand, slave_matrix)) {
 697               		.loc 1 316 9 is_stmt 1 view .LVU146
 698               		.loc 1 316 13 is_stmt 0 view .LVU147
 699 0034 862F      		mov r24,r22
 700 0036 90E0      		ldi r25,0
 701 0038 B801      		movw r22,r16
 702 003a 8050      		subi r24,lo8(-(matrix))
 703 003c 9040      		sbci r25,hi8(-(matrix))
 704 003e 0E94 0000 		call transport_master_if_connected
 705               	.LVL52:
 706 0042 E091 0000 		lds r30,thatHand
 707 0046 9E01      		movw r18,r28
 708 0048 2A5F      		subi r18,-6
 709 004a 3F4F      		sbci r19,-1
 710 004c F0E0      		ldi r31,0
 711               		.loc 1 316 12 view .LVU148
 712 004e 8823      		tst r24
 713 0050 01F0      		breq .L40
 714 0052 BF01      		movw r22,r30
 715 0054 6050      		subi r22,lo8(-(matrix))
 716 0056 7040      		sbci r23,hi8(-(matrix))
 717 0058 D801      		movw r26,r16
 718               	.LBE68:
 313:quantum/matrix.c ****     if (is_keyboard_master()) {
 719               		.loc 1 313 10 view .LVU149
 720 005a F12C      		mov r15,__zero_reg__
 721               	.LVL53:
 722               	.L42:
 723               	.LBB71:
 724               	.LBB69:
 317:quantum/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 318:quantum/matrix.c ****                 if (matrix[thatHand + i] != slave_matrix[i]) {
 725               		.loc 1 318 17 is_stmt 1 view .LVU150
 726               		.loc 1 318 27 is_stmt 0 view .LVU151
 727 005c FB01      		movw r30,r22
 728 005e 4191      		ld r20,Z+
 729 0060 BF01      		movw r22,r30
 730               	.LVL54:
 731               		.loc 1 318 57 view .LVU152
 732 0062 9D91      		ld r25,X+
 733               		.loc 1 318 20 view .LVU153
 734 0064 4917      		cp r20,r25
 735 0066 01F0      		breq .L41
 319:quantum/matrix.c ****                     matrix[thatHand + i] = slave_matrix[i];
 736               		.loc 1 319 21 is_stmt 1 view .LVU154
 737               		.loc 1 319 42 is_stmt 0 view .LVU155
 738 0068 AF01      		movw r20,r30
 739 006a 4150      		subi r20,1
 740 006c 5109      		sbc r21,__zero_reg__
 741 006e FA01      		movw r30,r20
 742 0070 9083      		st Z,r25
 320:quantum/matrix.c ****                     changed              = true;
 743               		.loc 1 320 21 is_stmt 1 view .LVU156
 744               	.LVL55:
 745               		.loc 1 320 42 is_stmt 0 view .LVU157
 746 0072 F82E      		mov r15,r24
 747               	.LVL56:
 748               	.L41:
 317:quantum/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 749               		.loc 1 317 13 discriminator 2 view .LVU158
 750 0074 A217      		cp r26,r18
 751 0076 B307      		cpc r27,r19
 752 0078 01F4      		brne .L42
 753               	.LVL57:
 754               	.L43:
 317:quantum/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 755               		.loc 1 317 13 discriminator 2 view .LVU159
 756               	.LBE69:
 321:quantum/matrix.c ****                 }
 322:quantum/matrix.c ****             }
 323:quantum/matrix.c ****         } else {
 324:quantum/matrix.c ****             // reset other half if disconnected
 325:quantum/matrix.c ****             for (int i = 0; i < ROWS_PER_HAND; ++i) {
 326:quantum/matrix.c ****                 matrix[thatHand + i] = 0;
 327:quantum/matrix.c ****                 slave_matrix[i]      = 0;
 328:quantum/matrix.c ****             }
 329:quantum/matrix.c **** 
 330:quantum/matrix.c ****             changed = true;
 331:quantum/matrix.c ****         }
 332:quantum/matrix.c **** 
 333:quantum/matrix.c ****         matrix_scan_quantum();
 757               		.loc 1 333 9 is_stmt 1 discriminator 1 view .LVU160
 758 007a 0E94 0000 		call matrix_scan_quantum
 759               	.LVL58:
 760               	.L38:
 761               		.loc 1 333 9 is_stmt 0 discriminator 1 view .LVU161
 762               	.LBE71:
 334:quantum/matrix.c ****     } else {
 335:quantum/matrix.c ****         transport_slave(matrix + thatHand, matrix + thisHand);
 336:quantum/matrix.c **** 
 337:quantum/matrix.c ****         matrix_slave_scan_kb();
 338:quantum/matrix.c ****     }
 339:quantum/matrix.c **** 
 340:quantum/matrix.c ****     return changed;
 341:quantum/matrix.c **** }
 763               		.loc 1 341 1 view .LVU162
 764 007e 8F2D      		mov r24,r15
 765               	/* epilogue start */
 766 0080 0F90      		pop __tmp_reg__
 767 0082 0F90      		pop __tmp_reg__
 768 0084 0F90      		pop __tmp_reg__
 769 0086 0F90      		pop __tmp_reg__
 770 0088 0F90      		pop __tmp_reg__
 771 008a DF91      		pop r29
 772 008c CF91      		pop r28
 773 008e 1F91      		pop r17
 774 0090 0F91      		pop r16
 775 0092 FF90      		pop r15
 776               	.LVL59:
 777               		.loc 1 341 1 view .LVU163
 778 0094 0895      		ret
 779               	.LVL60:
 780               	.L40:
 781               		.loc 1 341 1 view .LVU164
 782 0096 E050      		subi r30,lo8(-(matrix))
 783 0098 F040      		sbci r31,hi8(-(matrix))
 784 009a D801      		movw r26,r16
 785               	.L44:
 786               	.LVL61:
 787               	.LBB72:
 788               	.LBB70:
 326:quantum/matrix.c ****                 slave_matrix[i]      = 0;
 789               		.loc 1 326 17 is_stmt 1 discriminator 3 view .LVU165
 326:quantum/matrix.c ****                 slave_matrix[i]      = 0;
 790               		.loc 1 326 38 is_stmt 0 discriminator 3 view .LVU166
 791 009c 1192      		st Z+,__zero_reg__
 792               	.LVL62:
 327:quantum/matrix.c ****             }
 793               		.loc 1 327 17 is_stmt 1 discriminator 3 view .LVU167
 327:quantum/matrix.c ****             }
 794               		.loc 1 327 38 is_stmt 0 discriminator 3 view .LVU168
 795 009e 1D92      		st X+,__zero_reg__
 796               	.LVL63:
 325:quantum/matrix.c ****                 matrix[thatHand + i] = 0;
 797               		.loc 1 325 13 discriminator 3 view .LVU169
 798 00a0 A217      		cp r26,r18
 799 00a2 B307      		cpc r27,r19
 800 00a4 01F4      		brne .L44
 801 00a6 00C0      		rjmp .L43
 802               	.LVL64:
 803               	.L39:
 325:quantum/matrix.c ****                 matrix[thatHand + i] = 0;
 804               		.loc 1 325 13 discriminator 3 view .LVU170
 805               	.LBE70:
 806               	.LBE72:
 335:quantum/matrix.c **** 
 807               		.loc 1 335 9 is_stmt 1 view .LVU171
 808 00a8 70E0      		ldi r23,0
 809 00aa 6050      		subi r22,lo8(-(matrix))
 810 00ac 7040      		sbci r23,hi8(-(matrix))
 811 00ae 8091 0000 		lds r24,thatHand
 812 00b2 90E0      		ldi r25,0
 813 00b4 8050      		subi r24,lo8(-(matrix))
 814 00b6 9040      		sbci r25,hi8(-(matrix))
 815 00b8 0E94 0000 		call transport_slave
 816               	.LVL65:
 337:quantum/matrix.c ****     }
 817               		.loc 1 337 9 view .LVU172
 818 00bc 0E94 0000 		call matrix_slave_scan_kb
 819               	.LVL66:
 340:quantum/matrix.c **** }
 820               		.loc 1 340 5 view .LVU173
 340:quantum/matrix.c **** }
 821               		.loc 1 340 12 is_stmt 0 view .LVU174
 822 00c0 00C0      		rjmp .L38
 823               		.cfi_endproc
 824               	.LFE39:
 826               		.section	.text.matrix_scan,"ax",@progbits
 827               	.global	matrix_scan
 829               	matrix_scan:
 830               	.LFB40:
 342:quantum/matrix.c **** #endif
 343:quantum/matrix.c **** 
 344:quantum/matrix.c **** uint8_t matrix_scan(void) {
 831               		.loc 1 344 27 is_stmt 1 view -0
 832               		.cfi_startproc
 833 0000 EF92      		push r14
 834               	.LCFI19:
 835               		.cfi_def_cfa_offset 3
 836               		.cfi_offset 14, -2
 837 0002 FF92      		push r15
 838               	.LCFI20:
 839               		.cfi_def_cfa_offset 4
 840               		.cfi_offset 15, -3
 841 0004 0F93      		push r16
 842               	.LCFI21:
 843               		.cfi_def_cfa_offset 5
 844               		.cfi_offset 16, -4
 845 0006 1F93      		push r17
 846               	.LCFI22:
 847               		.cfi_def_cfa_offset 6
 848               		.cfi_offset 17, -5
 849 0008 CF93      		push r28
 850               	.LCFI23:
 851               		.cfi_def_cfa_offset 7
 852               		.cfi_offset 28, -6
 853 000a DF93      		push r29
 854               	.LCFI24:
 855               		.cfi_def_cfa_offset 8
 856               		.cfi_offset 29, -7
 857 000c CDB7      		in r28,__SP_L__
 858 000e DEB7      		in r29,__SP_H__
 859               	.LCFI25:
 860               		.cfi_def_cfa_register 28
 861 0010 2A97      		sbiw r28,10
 862               	.LCFI26:
 863               		.cfi_def_cfa_offset 18
 864 0012 0FB6      		in __tmp_reg__,__SREG__
 865 0014 F894      		cli
 866 0016 DEBF      		out __SP_H__,r29
 867 0018 0FBE      		out __SREG__,__tmp_reg__
 868 001a CDBF      		out __SP_L__,r28
 869               	/* prologue: function */
 870               	/* frame size = 10 */
 871               	/* stack size = 16 */
 872               	.L__stack_usage = 16
 345:quantum/matrix.c ****     matrix_row_t curr_matrix[MATRIX_ROWS] = {0};
 873               		.loc 1 345 5 view .LVU176
 874               		.loc 1 345 18 is_stmt 0 view .LVU177
 875 001c 8E01      		movw r16,r28
 876 001e 0F5F      		subi r16,-1
 877 0020 1F4F      		sbci r17,-1
 878 0022 8AE0      		ldi r24,lo8(10)
 879 0024 F801      		movw r30,r16
 880               		0:
 881 0026 1192      		st Z+,__zero_reg__
 882 0028 8A95      		dec r24
 883 002a 01F4      		brne 0b
 346:quantum/matrix.c **** 
 347:quantum/matrix.c **** #if defined(DIRECT_PINS) || (DIODE_DIRECTION == COL2ROW)
 348:quantum/matrix.c ****     // Set row, read cols
 349:quantum/matrix.c ****     for (uint8_t current_row = 0; current_row < ROWS_PER_HAND; current_row++) {
 884               		.loc 1 349 5 is_stmt 1 view .LVU178
 885               	.LBB73:
 886               		.loc 1 349 10 view .LVU179
 887               	.LVL67:
 888               		.loc 1 349 18 is_stmt 0 view .LVU180
 889 002c F12C      		mov r15,__zero_reg__
 890               	.LVL68:
 891               	.L49:
 350:quantum/matrix.c ****         matrix_read_cols_on_row(curr_matrix, current_row);
 892               		.loc 1 350 9 is_stmt 1 discriminator 3 view .LVU181
 893 002e 6F2D      		mov r22,r15
 894 0030 C801      		movw r24,r16
 895 0032 0E94 0000 		call matrix_read_cols_on_row
 896               	.LVL69:
 349:quantum/matrix.c ****         matrix_read_cols_on_row(curr_matrix, current_row);
 897               		.loc 1 349 75 is_stmt 0 discriminator 3 view .LVU182
 898 0036 F394      		inc r15
 899               	.LVL70:
 349:quantum/matrix.c ****         matrix_read_cols_on_row(curr_matrix, current_row);
 900               		.loc 1 349 5 discriminator 3 view .LVU183
 901 0038 F5E0      		ldi r31,lo8(5)
 902 003a FF12      		cpse r15,r31
 903 003c 00C0      		rjmp .L49
 904               	.LBE73:
 351:quantum/matrix.c ****     }
 352:quantum/matrix.c **** #elif (DIODE_DIRECTION == ROW2COL)
 353:quantum/matrix.c ****     // Set col, read rows
 354:quantum/matrix.c ****     for (uint8_t current_col = 0; current_col < MATRIX_COLS; current_col++) {
 355:quantum/matrix.c ****         matrix_read_rows_on_col(curr_matrix, current_col);
 356:quantum/matrix.c ****     }
 357:quantum/matrix.c **** #endif
 358:quantum/matrix.c **** 
 359:quantum/matrix.c ****     bool changed = memcmp(raw_matrix, curr_matrix, sizeof(curr_matrix)) != 0;
 905               		.loc 1 359 5 is_stmt 1 view .LVU184
 906               		.loc 1 359 20 is_stmt 0 view .LVU185
 907 003e 4AE0      		ldi r20,lo8(10)
 908 0040 50E0      		ldi r21,0
 909 0042 B801      		movw r22,r16
 910 0044 80E0      		ldi r24,lo8(raw_matrix)
 911 0046 90E0      		ldi r25,hi8(raw_matrix)
 912 0048 0E94 0000 		call memcmp
 913               	.LVL71:
 914 004c 7C01      		movw r14,r24
 915               		.loc 1 359 10 view .LVU186
 916 004e 21E0      		ldi r18,lo8(1)
 917 0050 892B      		or r24,r25
 918 0052 01F4      		brne .L50
 919 0054 20E0      		ldi r18,0
 920               	.L50:
 921               	.LVL72:
 360:quantum/matrix.c ****     if (changed) memcpy(raw_matrix, curr_matrix, sizeof(curr_matrix));
 922               		.loc 1 360 5 is_stmt 1 view .LVU187
 923               		.loc 1 360 8 is_stmt 0 view .LVU188
 924 0056 E114      		cp r14,__zero_reg__
 925 0058 F104      		cpc r15,__zero_reg__
 926 005a 01F0      		breq .L51
 927               		.loc 1 360 18 is_stmt 1 discriminator 1 view .LVU189
 928 005c 8AE0      		ldi r24,lo8(10)
 929 005e F801      		movw r30,r16
 930 0060 A0E0      		ldi r26,lo8(raw_matrix)
 931 0062 B0E0      		ldi r27,hi8(raw_matrix)
 932               		0:
 933 0064 0190      		ld r0,Z+
 934 0066 0D92      		st X+,r0
 935 0068 8A95      		dec r24
 936 006a 01F4      		brne 0b
 937               	.L51:
 361:quantum/matrix.c **** 
 362:quantum/matrix.c **** #ifdef SPLIT_KEYBOARD
 363:quantum/matrix.c ****     debounce(raw_matrix, matrix + thisHand, ROWS_PER_HAND, changed);
 938               		.loc 1 363 5 view .LVU190
 939 006c 6091 0000 		lds r22,thisHand
 940 0070 70E0      		ldi r23,0
 941 0072 6050      		subi r22,lo8(-(matrix))
 942 0074 7040      		sbci r23,hi8(-(matrix))
 943 0076 45E0      		ldi r20,lo8(5)
 944 0078 80E0      		ldi r24,lo8(raw_matrix)
 945 007a 90E0      		ldi r25,hi8(raw_matrix)
 946 007c 0E94 0000 		call debounce
 947               	.LVL73:
 364:quantum/matrix.c ****     changed = (changed || matrix_post_scan());
 948               		.loc 1 364 5 view .LVU191
 949               		.loc 1 364 24 is_stmt 0 view .LVU192
 950 0080 81E0      		ldi r24,lo8(1)
 951 0082 90E0      		ldi r25,0
 952 0084 EF28      		or r14,r15
 953 0086 01F4      		brne .L52
 954               		.loc 1 364 27 discriminator 2 view .LVU193
 955 0088 0E94 0000 		call matrix_post_scan
 956               	.LVL74:
 957               	.L52:
 365:quantum/matrix.c **** #else
 366:quantum/matrix.c ****     debounce(raw_matrix, matrix, ROWS_PER_HAND, changed);
 367:quantum/matrix.c ****     matrix_scan_quantum();
 368:quantum/matrix.c **** #endif
 369:quantum/matrix.c ****     return (uint8_t)changed;
 958               		.loc 1 369 5 is_stmt 1 discriminator 6 view .LVU194
 959               	/* epilogue start */
 370:quantum/matrix.c **** }
 960               		.loc 1 370 1 is_stmt 0 discriminator 6 view .LVU195
 961 008c 2A96      		adiw r28,10
 962 008e 0FB6      		in __tmp_reg__,__SREG__
 963 0090 F894      		cli
 964 0092 DEBF      		out __SP_H__,r29
 965 0094 0FBE      		out __SREG__,__tmp_reg__
 966 0096 CDBF      		out __SP_L__,r28
 967 0098 DF91      		pop r29
 968 009a CF91      		pop r28
 969 009c 1F91      		pop r17
 970 009e 0F91      		pop r16
 971 00a0 FF90      		pop r15
 972               	.LVL75:
 973               		.loc 1 370 1 discriminator 6 view .LVU196
 974 00a2 EF90      		pop r14
 975 00a4 0895      		ret
 976               		.cfi_endproc
 977               	.LFE40:
 979               		.comm	thatHand,1,1
 980               		.comm	thisHand,1,1
 981               		.section	.rodata.col_pins,"a"
 984               	col_pins:
 985 0000 F6        		.byte	-10
 986 0001 F7        		.byte	-9
 987 0002 31        		.byte	49
 988 0003 33        		.byte	51
 989 0004 32        		.byte	50
 990 0005 36        		.byte	54
 991               		.section	.rodata.row_pins,"a"
 994               	row_pins:
 995 0000 66        		.byte	102
 996 0001 97        		.byte	-105
 997 0002 C6        		.byte	-58
 998 0003 34        		.byte	52
 999 0004 35        		.byte	53
 1000 0005 0000 0000 		.zero	5
 1000      00
 1001               		.text
 1002               	.Letext0:
 1003               		.file 3 "/usr/avr/include/stdint.h"
 1004               		.file 4 "/usr/lib/gcc/avr/8.3.0/include/stddef.h"
 1005               		.file 5 "quantum/matrix.h"
 1006               		.file 6 "quantum/keyboard.h"
 1007               		.file 7 "quantum/action.h"
 1008               		.file 8 "tmk_core/common/report.h"
 1009               		.file 9 "tmk_core/common/host.h"
 1010               		.file 10 "quantum/logging/debug.h"
 1011               		.file 11 "quantum/keycode_config.h"
 1012               		.file 12 "tmk_core/common/timer.h"
 1013               		.file 13 "quantum/sequencer/sequencer.h"
 1014               		.file 14 "quantum/keymap.h"
 1015               		.file 15 "quantum/action_layer.h"
 1016               		.file 16 "tmk_core/common/avr/gpio.h"
 1017               		.file 17 "quantum/action_util.h"
 1018               		.file 18 "quantum/send_string.h"
 1019               		.file 19 "/usr/avr/include/stdlib.h"
 1020               		.file 20 "/usr/avr/include/stdio.h"
 1021               		.file 21 "quantum/split_common/split_util.h"
 1022               		.file 22 "quantum/split_common/transaction_id_define.h"
 1023               		.file 23 "quantum/split_common/transport.h"
 1024               		.file 24 "quantum/split_common/transactions.h"
 1025               		.file 25 "/usr/avr/include/string.h"
 1026               		.file 26 "quantum/debounce.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 matrix.c
     /tmp/ccACjx5j.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccACjx5j.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccACjx5j.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccACjx5j.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccACjx5j.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccACjx5j.s:12     .text.setPinInputHigh_atomic:0000000000000000 setPinInputHigh_atomic
     /tmp/ccACjx5j.s:93     .text.matrix_slave_scan_user:0000000000000000 matrix_slave_scan_user
     /tmp/ccACjx5j.s:111    .text.matrix_slave_scan_kb:0000000000000000 matrix_slave_scan_kb
     /tmp/ccACjx5j.s:128    .text.matrix_init_pins:0000000000000000 matrix_init_pins
     /tmp/ccACjx5j.s:994    .rodata.row_pins:0000000000000000 row_pins
     /tmp/ccACjx5j.s:984    .rodata.col_pins:0000000000000000 col_pins
     /tmp/ccACjx5j.s:235    .text.matrix_read_cols_on_row:0000000000000000 matrix_read_cols_on_row
     /tmp/ccACjx5j.s:539    .text.matrix_init:0000000000000000 matrix_init
                            *COM*:0000000000000001 thisHand
                            *COM*:0000000000000001 thatHand
     /tmp/ccACjx5j.s:613    .text.transport_master_if_connected:0000000000000000 transport_master_if_connected
     /tmp/ccACjx5j.s:636    .text.matrix_post_scan:0000000000000000 matrix_post_scan
     /tmp/ccACjx5j.s:829    .text.matrix_scan:0000000000000000 matrix_scan

UNDEFINED SYMBOLS
matrix_output_select_delay
matrix_output_unselect_delay
split_pre_init
isLeftHand
raw_matrix
matrix
debounce_init
matrix_init_quantum
split_post_init
transport_master
is_keyboard_master
matrix_scan_quantum
transport_slave
memcmp
debounce
__do_copy_data
__do_clear_bss
