   1               		.file	"transactions.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.sync_timer_handlers_master,"ax",@progbits
  12               	sync_timer_handlers_master:
  13               	.LVL0:
  14               	.LFB35:
  15               		.file 1 "quantum/split_common/transactions.c"
   1:quantum/split_common/transactions.c **** /* Copyright 2021 QMK
   2:quantum/split_common/transactions.c ****  *
   3:quantum/split_common/transactions.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/split_common/transactions.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/split_common/transactions.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/split_common/transactions.c ****  * (at your option) any later version.
   7:quantum/split_common/transactions.c ****  *
   8:quantum/split_common/transactions.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/split_common/transactions.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/split_common/transactions.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/split_common/transactions.c ****  * GNU General Public License for more details.
  12:quantum/split_common/transactions.c ****  *
  13:quantum/split_common/transactions.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/split_common/transactions.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/split_common/transactions.c ****  */
  16:quantum/split_common/transactions.c **** 
  17:quantum/split_common/transactions.c **** #include <string.h>
  18:quantum/split_common/transactions.c **** #include <stddef.h>
  19:quantum/split_common/transactions.c **** 
  20:quantum/split_common/transactions.c **** #include "crc.h"
  21:quantum/split_common/transactions.c **** #include "debug.h"
  22:quantum/split_common/transactions.c **** #include "matrix.h"
  23:quantum/split_common/transactions.c **** #include "quantum.h"
  24:quantum/split_common/transactions.c **** #include "transactions.h"
  25:quantum/split_common/transactions.c **** #include "transport.h"
  26:quantum/split_common/transactions.c **** #include "split_util.h"
  27:quantum/split_common/transactions.c **** #include "transaction_id_define.h"
  28:quantum/split_common/transactions.c **** 
  29:quantum/split_common/transactions.c **** #define SYNC_TIMER_OFFSET 2
  30:quantum/split_common/transactions.c **** 
  31:quantum/split_common/transactions.c **** #ifndef FORCED_SYNC_THROTTLE_MS
  32:quantum/split_common/transactions.c **** #    define FORCED_SYNC_THROTTLE_MS 100
  33:quantum/split_common/transactions.c **** #endif  // FORCED_SYNC_THROTTLE_MS
  34:quantum/split_common/transactions.c **** 
  35:quantum/split_common/transactions.c **** #define sizeof_member(type, member) sizeof(((type *)NULL)->member)
  36:quantum/split_common/transactions.c **** 
  37:quantum/split_common/transactions.c **** #define trans_initiator2target_initializer_cb(member, cb) \
  38:quantum/split_common/transactions.c ****     { &dummy, sizeof_member(split_shared_memory_t, member), offsetof(split_shared_memory_t, member)
  39:quantum/split_common/transactions.c **** #define trans_initiator2target_initializer(member) trans_initiator2target_initializer_cb(member, NU
  40:quantum/split_common/transactions.c **** 
  41:quantum/split_common/transactions.c **** #define trans_target2initiator_initializer_cb(member, cb) \
  42:quantum/split_common/transactions.c ****     { &dummy, 0, 0, sizeof_member(split_shared_memory_t, member), offsetof(split_shared_memory_t, m
  43:quantum/split_common/transactions.c **** #define trans_target2initiator_initializer(member) trans_target2initiator_initializer_cb(member, NU
  44:quantum/split_common/transactions.c **** 
  45:quantum/split_common/transactions.c **** #define transport_write(id, data, length)          transport_execute_transaction(id, data, length, 
  46:quantum/split_common/transactions.c **** #define transport_read(id, data, length)           transport_execute_transaction(id, NULL, 0, data,
  47:quantum/split_common/transactions.c **** 
  48:quantum/split_common/transactions.c **** #if defined(SPLIT_TRANSACTION_IDS_KB) || defined(SPLIT_TRANSACTION_IDS_USER)
  49:quantum/split_common/transactions.c **** // Forward-declare the RPC callback handlers
  50:quantum/split_common/transactions.c **** void slave_rpc_info_callback(uint8_t initiator2target_buffer_size, const void *initiator2target_buf
  51:quantum/split_common/transactions.c **** void slave_rpc_exec_callback(uint8_t initiator2target_buffer_size, const void *initiator2target_buf
  52:quantum/split_common/transactions.c **** #endif  // defined(SPLIT_TRANSACTION_IDS_KB) || defined(SPLIT_TRANSACTION_IDS_USER)
  53:quantum/split_common/transactions.c **** 
  54:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
  55:quantum/split_common/transactions.c **** // Helpers
  56:quantum/split_common/transactions.c **** 
  57:quantum/split_common/transactions.c **** static bool transaction_handler_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[], c
  58:quantum/split_common/transactions.c ****     int num_retries = is_transport_connected() ? 10 : 1;
  59:quantum/split_common/transactions.c ****     for (int iter = 1; iter <= num_retries; ++iter) {
  60:quantum/split_common/transactions.c ****         if (iter > 1) {
  61:quantum/split_common/transactions.c ****             for (int i = 0; i < iter * iter; ++i) {
  62:quantum/split_common/transactions.c ****                 wait_us(10);
  63:quantum/split_common/transactions.c ****             }
  64:quantum/split_common/transactions.c ****         }
  65:quantum/split_common/transactions.c ****         bool this_okay = true;
  66:quantum/split_common/transactions.c ****         ATOMIC_BLOCK_FORCEON { this_okay = handler(master_matrix, slave_matrix); };
  67:quantum/split_common/transactions.c ****         if (this_okay) return true;
  68:quantum/split_common/transactions.c ****     }
  69:quantum/split_common/transactions.c ****     dprintf("Failed to execute %s\n", prefix);
  70:quantum/split_common/transactions.c ****     return false;
  71:quantum/split_common/transactions.c **** }
  72:quantum/split_common/transactions.c **** 
  73:quantum/split_common/transactions.c **** #define TRANSACTION_HANDLER_MASTER(prefix)                                                         
  74:quantum/split_common/transactions.c ****     do {                                                                                           
  75:quantum/split_common/transactions.c ****         if (!transaction_handler_master(master_matrix, slave_matrix, #prefix, &prefix##_handlers_ma
  76:quantum/split_common/transactions.c ****     } while (0)
  77:quantum/split_common/transactions.c **** 
  78:quantum/split_common/transactions.c **** #define TRANSACTION_HANDLER_SLAVE(prefix)                                               \
  79:quantum/split_common/transactions.c ****     do {                                                                                \
  80:quantum/split_common/transactions.c ****         ATOMIC_BLOCK_FORCEON { prefix##_handlers_slave(master_matrix, slave_matrix); }; \
  81:quantum/split_common/transactions.c ****     } while (0)
  82:quantum/split_common/transactions.c **** 
  83:quantum/split_common/transactions.c **** inline static bool read_if_checksum_mismatch(int8_t trans_id_checksum, int8_t trans_id_retrieve, ui
  84:quantum/split_common/transactions.c ****     uint8_t curr_checksum;
  85:quantum/split_common/transactions.c ****     bool    okay = transport_read(trans_id_checksum, &curr_checksum, sizeof(curr_checksum));
  86:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
  87:quantum/split_common/transactions.c ****         okay &= transport_read(trans_id_retrieve, destination, length);
  88:quantum/split_common/transactions.c ****         okay &= curr_checksum == crc8(equiv_shmem, length);
  89:quantum/split_common/transactions.c ****         if (okay) {
  90:quantum/split_common/transactions.c ****             *last_update = timer_read32();
  91:quantum/split_common/transactions.c ****         }
  92:quantum/split_common/transactions.c ****     } else {
  93:quantum/split_common/transactions.c ****         memcpy(destination, equiv_shmem, length);
  94:quantum/split_common/transactions.c ****     }
  95:quantum/split_common/transactions.c ****     return okay;
  96:quantum/split_common/transactions.c **** }
  97:quantum/split_common/transactions.c **** 
  98:quantum/split_common/transactions.c **** inline static bool send_if_condition(int8_t trans_id, uint32_t *last_update, bool condition, void *
  99:quantum/split_common/transactions.c ****     bool okay = true;
 100:quantum/split_common/transactions.c ****     if (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || condition) {
 101:quantum/split_common/transactions.c ****         okay &= transport_write(trans_id, source, length);
 102:quantum/split_common/transactions.c ****         if (okay) {
 103:quantum/split_common/transactions.c ****             *last_update = timer_read32();
 104:quantum/split_common/transactions.c ****         }
 105:quantum/split_common/transactions.c ****     }
 106:quantum/split_common/transactions.c ****     return okay;
 107:quantum/split_common/transactions.c **** }
 108:quantum/split_common/transactions.c **** 
 109:quantum/split_common/transactions.c **** inline static bool send_if_data_mismatch(int8_t trans_id, uint32_t *last_update, void *source, cons
 110:quantum/split_common/transactions.c ****     // Just run a memcmp to compare the source and equivalent shmem location
 111:quantum/split_common/transactions.c ****     return send_if_condition(trans_id, last_update, (memcmp(source, equiv_shmem, length) != 0), sou
 112:quantum/split_common/transactions.c **** }
 113:quantum/split_common/transactions.c **** 
 114:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 115:quantum/split_common/transactions.c **** // Slave matrix
 116:quantum/split_common/transactions.c **** 
 117:quantum/split_common/transactions.c **** static bool slave_matrix_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[])
 118:quantum/split_common/transactions.c ****     static uint32_t     last_update                    = 0;
 119:quantum/split_common/transactions.c ****     static matrix_row_t last_matrix[(MATRIX_ROWS) / 2] = {0};  // last successfully-read matrix, so
 120:quantum/split_common/transactions.c ****     matrix_row_t        temp_matrix[(MATRIX_ROWS) / 2];        // holding area while we test whethe
 121:quantum/split_common/transactions.c **** 
 122:quantum/split_common/transactions.c ****     bool okay = read_if_checksum_mismatch(GET_SLAVE_MATRIX_CHECKSUM, GET_SLAVE_MATRIX_DATA, &last_u
 123:quantum/split_common/transactions.c ****     if (okay) {
 124:quantum/split_common/transactions.c ****         // Checksum matches the received data, save as the last matrix state
 125:quantum/split_common/transactions.c ****         memcpy(last_matrix, temp_matrix, sizeof(temp_matrix));
 126:quantum/split_common/transactions.c ****     }
 127:quantum/split_common/transactions.c ****     // Copy out the last-known-good matrix state to the slave matrix
 128:quantum/split_common/transactions.c ****     memcpy(slave_matrix, last_matrix, sizeof(last_matrix));
 129:quantum/split_common/transactions.c ****     return okay;
 130:quantum/split_common/transactions.c **** }
 131:quantum/split_common/transactions.c **** 
 132:quantum/split_common/transactions.c **** static void slave_matrix_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) 
 133:quantum/split_common/transactions.c ****     memcpy(split_shmem->smatrix.matrix, slave_matrix, sizeof(split_shmem->smatrix.matrix));
 134:quantum/split_common/transactions.c ****     split_shmem->smatrix.checksum = crc8(split_shmem->smatrix.matrix, sizeof(split_shmem->smatrix.m
 135:quantum/split_common/transactions.c **** }
 136:quantum/split_common/transactions.c **** 
 137:quantum/split_common/transactions.c **** // clang-format off
 138:quantum/split_common/transactions.c **** #define TRANSACTIONS_SLAVE_MATRIX_MASTER() TRANSACTION_HANDLER_MASTER(slave_matrix)
 139:quantum/split_common/transactions.c **** #define TRANSACTIONS_SLAVE_MATRIX_SLAVE() TRANSACTION_HANDLER_SLAVE(slave_matrix)
 140:quantum/split_common/transactions.c **** #define TRANSACTIONS_SLAVE_MATRIX_REGISTRATIONS \
 141:quantum/split_common/transactions.c ****     [GET_SLAVE_MATRIX_CHECKSUM] = trans_target2initiator_initializer(smatrix.checksum), \
 142:quantum/split_common/transactions.c ****     [GET_SLAVE_MATRIX_DATA]     = trans_target2initiator_initializer(smatrix.matrix),
 143:quantum/split_common/transactions.c **** // clang-format on
 144:quantum/split_common/transactions.c **** 
 145:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 146:quantum/split_common/transactions.c **** // Master matrix
 147:quantum/split_common/transactions.c **** 
 148:quantum/split_common/transactions.c **** #ifdef SPLIT_TRANSPORT_MIRROR
 149:quantum/split_common/transactions.c **** 
 150:quantum/split_common/transactions.c **** static bool master_matrix_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]
 151:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
 152:quantum/split_common/transactions.c ****     return send_if_data_mismatch(PUT_MASTER_MATRIX, &last_update, master_matrix, split_shmem->mmatr
 153:quantum/split_common/transactions.c **** }
 154:quantum/split_common/transactions.c **** 
 155:quantum/split_common/transactions.c **** static void master_matrix_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[])
 156:quantum/split_common/transactions.c ****     // Always copy to the master matrix
 157:quantum/split_common/transactions.c ****     memcpy(master_matrix, split_shmem->mmatrix.matrix, sizeof(split_shmem->mmatrix.matrix));
 158:quantum/split_common/transactions.c **** }
 159:quantum/split_common/transactions.c **** 
 160:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MASTER_MATRIX_MASTER()      TRANSACTION_HANDLER_MASTER(master_matrix)
 161:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MASTER_MATRIX_SLAVE()       TRANSACTION_HANDLER_SLAVE(master_matrix)
 162:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MASTER_MATRIX_REGISTRATIONS [PUT_MASTER_MATRIX] = trans_initiator2target_i
 163:quantum/split_common/transactions.c **** 
 164:quantum/split_common/transactions.c **** #else  // SPLIT_TRANSPORT_MIRROR
 165:quantum/split_common/transactions.c **** 
 166:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MASTER_MATRIX_MASTER()
 167:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MASTER_MATRIX_SLAVE()
 168:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MASTER_MATRIX_REGISTRATIONS
 169:quantum/split_common/transactions.c **** 
 170:quantum/split_common/transactions.c **** #endif  // SPLIT_TRANSPORT_MIRROR
 171:quantum/split_common/transactions.c **** 
 172:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 173:quantum/split_common/transactions.c **** // Encoders
 174:quantum/split_common/transactions.c **** 
 175:quantum/split_common/transactions.c **** #ifdef ENCODER_ENABLE
 176:quantum/split_common/transactions.c **** 
 177:quantum/split_common/transactions.c **** static bool encoder_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 178:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
 179:quantum/split_common/transactions.c ****     uint8_t         temp_state[NUMBER_OF_ENCODERS];
 180:quantum/split_common/transactions.c **** 
 181:quantum/split_common/transactions.c ****     bool okay = read_if_checksum_mismatch(GET_ENCODERS_CHECKSUM, GET_ENCODERS_DATA, &last_update, t
 182:quantum/split_common/transactions.c ****     if (okay) encoder_update_raw(temp_state);
 183:quantum/split_common/transactions.c ****     return okay;
 184:quantum/split_common/transactions.c **** }
 185:quantum/split_common/transactions.c **** 
 186:quantum/split_common/transactions.c **** static void encoder_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 187:quantum/split_common/transactions.c ****     uint8_t encoder_state[NUMBER_OF_ENCODERS];
 188:quantum/split_common/transactions.c ****     encoder_state_raw(encoder_state);
 189:quantum/split_common/transactions.c ****     // Always prepare the encoder state for read.
 190:quantum/split_common/transactions.c ****     memcpy(split_shmem->encoders.state, encoder_state, sizeof(encoder_state));
 191:quantum/split_common/transactions.c ****     // Now update the checksum given that the encoders has been written to
 192:quantum/split_common/transactions.c ****     split_shmem->encoders.checksum = crc8(encoder_state, sizeof(encoder_state));
 193:quantum/split_common/transactions.c **** }
 194:quantum/split_common/transactions.c **** 
 195:quantum/split_common/transactions.c **** // clang-format off
 196:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ENCODERS_MASTER() TRANSACTION_HANDLER_MASTER(encoder)
 197:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ENCODERS_SLAVE() TRANSACTION_HANDLER_SLAVE(encoder)
 198:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ENCODERS_REGISTRATIONS \
 199:quantum/split_common/transactions.c ****     [GET_ENCODERS_CHECKSUM] = trans_target2initiator_initializer(encoders.checksum), \
 200:quantum/split_common/transactions.c ****     [GET_ENCODERS_DATA]     = trans_target2initiator_initializer(encoders.state),
 201:quantum/split_common/transactions.c **** // clang-format on
 202:quantum/split_common/transactions.c **** 
 203:quantum/split_common/transactions.c **** #else  // ENCODER_ENABLE
 204:quantum/split_common/transactions.c **** 
 205:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ENCODERS_MASTER()
 206:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ENCODERS_SLAVE()
 207:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ENCODERS_REGISTRATIONS
 208:quantum/split_common/transactions.c **** 
 209:quantum/split_common/transactions.c **** #endif  // ENCODER_ENABLE
 210:quantum/split_common/transactions.c **** 
 211:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 212:quantum/split_common/transactions.c **** // Sync timer
 213:quantum/split_common/transactions.c **** 
 214:quantum/split_common/transactions.c **** #ifndef DISABLE_SYNC_TIMER
 215:quantum/split_common/transactions.c **** 
 216:quantum/split_common/transactions.c **** static bool sync_timer_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
  16               		.loc 1 216 99 view -0
  17               		.cfi_startproc
  18               		.loc 1 216 99 is_stmt 0 view .LVU1
  19 0000 0F93      		push r16
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 16, -2
  23 0002 1F93      		push r17
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 4
  26               		.cfi_offset 17, -3
  27 0004 CF93      		push r28
  28               	.LCFI2:
  29               		.cfi_def_cfa_offset 5
  30               		.cfi_offset 28, -4
  31 0006 DF93      		push r29
  32               	.LCFI3:
  33               		.cfi_def_cfa_offset 6
  34               		.cfi_offset 29, -5
  35 0008 00D0      		rcall .
  36 000a 00D0      		rcall .
  37               	.LCFI4:
  38               		.cfi_def_cfa_offset 10
  39 000c CDB7      		in r28,__SP_L__
  40 000e DEB7      		in r29,__SP_H__
  41               	.LCFI5:
  42               		.cfi_def_cfa_register 28
  43               	/* prologue: function */
  44               	/* frame size = 4 */
  45               	/* stack size = 8 */
  46               	.L__stack_usage = 8
 217:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
  47               		.loc 1 217 5 is_stmt 1 view .LVU2
 218:quantum/split_common/transactions.c **** 
 219:quantum/split_common/transactions.c ****     bool okay = true;
  48               		.loc 1 219 5 view .LVU3
  49               	.LVL1:
 220:quantum/split_common/transactions.c ****     if (timer_elapsed32(last_update) >= FORCED_SYNC_THROTTLE_MS) {
  50               		.loc 1 220 5 view .LVU4
  51               		.loc 1 220 9 is_stmt 0 view .LVU5
  52 0010 6091 0000 		lds r22,last_update.4344
  53 0014 7091 0000 		lds r23,last_update.4344+1
  54 0018 8091 0000 		lds r24,last_update.4344+2
  55 001c 9091 0000 		lds r25,last_update.4344+3
  56               	.LVL2:
  57               		.loc 1 220 9 view .LVU6
  58 0020 0E94 0000 		call timer_elapsed32
  59               	.LVL3:
 219:quantum/split_common/transactions.c ****     if (timer_elapsed32(last_update) >= FORCED_SYNC_THROTTLE_MS) {
  60               		.loc 1 219 10 view .LVU7
  61 0024 11E0      		ldi r17,lo8(1)
  62               		.loc 1 220 8 view .LVU8
  63 0026 6436      		cpi r22,100
  64 0028 7105      		cpc r23,__zero_reg__
  65 002a 8105      		cpc r24,__zero_reg__
  66 002c 9105      		cpc r25,__zero_reg__
  67 002e 00F0      		brlo .L1
  68               	.LBB33:
 221:quantum/split_common/transactions.c ****         uint32_t sync_timer = sync_timer_read32() + SYNC_TIMER_OFFSET;
  69               		.loc 1 221 9 is_stmt 1 view .LVU9
  70               		.loc 1 221 31 is_stmt 0 view .LVU10
  71 0030 0E94 0000 		call sync_timer_read32
  72               	.LVL4:
  73               		.loc 1 221 51 view .LVU11
  74 0034 6E5F      		subi r22,-2
  75 0036 7F4F      		sbci r23,-1
  76 0038 8F4F      		sbci r24,-1
  77 003a 9F4F      		sbci r25,-1
  78               		.loc 1 221 18 view .LVU12
  79 003c 6983      		std Y+1,r22
  80 003e 7A83      		std Y+2,r23
  81 0040 8B83      		std Y+3,r24
  82 0042 9C83      		std Y+4,r25
 222:quantum/split_common/transactions.c ****         okay &= transport_write(PUT_SYNC_TIMER, &sync_timer, sizeof(sync_timer));
  83               		.loc 1 222 9 is_stmt 1 view .LVU13
  84               		.loc 1 222 17 is_stmt 0 view .LVU14
  85 0044 10E0      		ldi r17,0
  86 0046 00E0      		ldi r16,0
  87 0048 30E0      		ldi r19,0
  88 004a 20E0      		ldi r18,0
  89 004c 44E0      		ldi r20,lo8(4)
  90 004e 50E0      		ldi r21,0
  91 0050 BE01      		movw r22,r28
  92 0052 6F5F      		subi r22,-1
  93 0054 7F4F      		sbci r23,-1
  94 0056 84E0      		ldi r24,lo8(4)
  95 0058 0E94 0000 		call transport_execute_transaction
  96               	.LVL5:
  97 005c 182F      		mov r17,r24
  98               	.LVL6:
 223:quantum/split_common/transactions.c ****         if (okay) {
  99               		.loc 1 223 9 is_stmt 1 view .LVU15
 100               		.loc 1 223 12 is_stmt 0 view .LVU16
 101 005e 8823      		tst r24
 102 0060 01F0      		breq .L1
 224:quantum/split_common/transactions.c ****             last_update = timer_read32();
 103               		.loc 1 224 13 is_stmt 1 view .LVU17
 104               		.loc 1 224 27 is_stmt 0 view .LVU18
 105 0062 0E94 0000 		call timer_read32
 106               	.LVL7:
 107               		.loc 1 224 25 view .LVU19
 108 0066 6093 0000 		sts last_update.4344,r22
 109 006a 7093 0000 		sts last_update.4344+1,r23
 110 006e 8093 0000 		sts last_update.4344+2,r24
 111 0072 9093 0000 		sts last_update.4344+3,r25
 112               	.LVL8:
 113               	.L1:
 114               		.loc 1 224 25 view .LVU20
 115               	.LBE33:
 225:quantum/split_common/transactions.c ****         }
 226:quantum/split_common/transactions.c ****     }
 227:quantum/split_common/transactions.c ****     return okay;
 228:quantum/split_common/transactions.c **** }
 116               		.loc 1 228 1 view .LVU21
 117 0076 812F      		mov r24,r17
 118               	/* epilogue start */
 119 0078 0F90      		pop __tmp_reg__
 120 007a 0F90      		pop __tmp_reg__
 121 007c 0F90      		pop __tmp_reg__
 122 007e 0F90      		pop __tmp_reg__
 123 0080 DF91      		pop r29
 124 0082 CF91      		pop r28
 125 0084 1F91      		pop r17
 126 0086 0F91      		pop r16
 127 0088 0895      		ret
 128               		.cfi_endproc
 129               	.LFE35:
 131               		.section	.text.read_if_checksum_mismatch,"ax",@progbits
 133               	read_if_checksum_mismatch:
 134               	.LVL9:
 135               	.LFB28:
  83:quantum/split_common/transactions.c ****     uint8_t curr_checksum;
 136               		.loc 1 83 180 is_stmt 1 view -0
 137               		.cfi_startproc
  83:quantum/split_common/transactions.c ****     uint8_t curr_checksum;
 138               		.loc 1 83 180 is_stmt 0 view .LVU23
 139 0000 7F92      		push r7
 140               	.LCFI6:
 141               		.cfi_def_cfa_offset 3
 142               		.cfi_offset 7, -2
 143 0002 8F92      		push r8
 144               	.LCFI7:
 145               		.cfi_def_cfa_offset 4
 146               		.cfi_offset 8, -3
 147 0004 9F92      		push r9
 148               	.LCFI8:
 149               		.cfi_def_cfa_offset 5
 150               		.cfi_offset 9, -4
 151 0006 AF92      		push r10
 152               	.LCFI9:
 153               		.cfi_def_cfa_offset 6
 154               		.cfi_offset 10, -5
 155 0008 BF92      		push r11
 156               	.LCFI10:
 157               		.cfi_def_cfa_offset 7
 158               		.cfi_offset 11, -6
 159 000a CF92      		push r12
 160               	.LCFI11:
 161               		.cfi_def_cfa_offset 8
 162               		.cfi_offset 12, -7
 163 000c DF92      		push r13
 164               	.LCFI12:
 165               		.cfi_def_cfa_offset 9
 166               		.cfi_offset 13, -8
 167 000e EF92      		push r14
 168               	.LCFI13:
 169               		.cfi_def_cfa_offset 10
 170               		.cfi_offset 14, -9
 171 0010 FF92      		push r15
 172               	.LCFI14:
 173               		.cfi_def_cfa_offset 11
 174               		.cfi_offset 15, -10
 175 0012 0F93      		push r16
 176               	.LCFI15:
 177               		.cfi_def_cfa_offset 12
 178               		.cfi_offset 16, -11
 179 0014 1F93      		push r17
 180               	.LCFI16:
 181               		.cfi_def_cfa_offset 13
 182               		.cfi_offset 17, -12
 183 0016 CF93      		push r28
 184               	.LCFI17:
 185               		.cfi_def_cfa_offset 14
 186               		.cfi_offset 28, -13
 187 0018 DF93      		push r29
 188               	.LCFI18:
 189               		.cfi_def_cfa_offset 15
 190               		.cfi_offset 29, -14
 191 001a 0F92      		push __tmp_reg__
 192               	.LCFI19:
 193               		.cfi_def_cfa_offset 16
 194 001c CDB7      		in r28,__SP_L__
 195 001e DEB7      		in r29,__SP_H__
 196               	.LCFI20:
 197               		.cfi_def_cfa_register 28
 198               	/* prologue: function */
 199               	/* frame size = 1 */
 200               	/* stack size = 14 */
 201               	.L__stack_usage = 14
 202 0020 762E      		mov r7,r22
 203 0022 4A01      		movw r8,r20
 204 0024 5901      		movw r10,r18
 205 0026 6801      		movw r12,r16
  84:quantum/split_common/transactions.c ****     bool    okay = transport_read(trans_id_checksum, &curr_checksum, sizeof(curr_checksum));
 206               		.loc 1 84 5 is_stmt 1 view .LVU24
  85:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
 207               		.loc 1 85 5 view .LVU25
  85:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
 208               		.loc 1 85 20 is_stmt 0 view .LVU26
 209 0028 01E0      		ldi r16,lo8(1)
 210 002a 10E0      		ldi r17,0
 211               	.LVL10:
  85:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
 212               		.loc 1 85 20 view .LVU27
 213 002c 9E01      		movw r18,r28
 214               	.LVL11:
  85:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
 215               		.loc 1 85 20 view .LVU28
 216 002e 2F5F      		subi r18,-1
 217 0030 3F4F      		sbci r19,-1
 218 0032 50E0      		ldi r21,0
 219 0034 40E0      		ldi r20,0
 220               	.LVL12:
  85:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
 221               		.loc 1 85 20 view .LVU29
 222 0036 70E0      		ldi r23,0
 223 0038 60E0      		ldi r22,0
 224               	.LVL13:
  85:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
 225               		.loc 1 85 20 view .LVU30
 226 003a 0E94 0000 		call transport_execute_transaction
 227               	.LVL14:
  85:quantum/split_common/transactions.c ****     if (okay && (timer_elapsed32(*last_update) >= FORCED_SYNC_THROTTLE_MS || curr_checksum != crc8(
 228               		.loc 1 85 20 view .LVU31
 229 003e 182F      		mov r17,r24
 230               	.LVL15:
  86:quantum/split_common/transactions.c ****         okay &= transport_read(trans_id_retrieve, destination, length);
 231               		.loc 1 86 5 is_stmt 1 view .LVU32
  86:quantum/split_common/transactions.c ****         okay &= transport_read(trans_id_retrieve, destination, length);
 232               		.loc 1 86 8 is_stmt 0 view .LVU33
 233 0040 8823      		tst r24
 234 0042 01F4      		brne .+2
 235 0044 00C0      		rjmp .L9
  86:quantum/split_common/transactions.c ****         okay &= transport_read(trans_id_retrieve, destination, length);
 236               		.loc 1 86 18 discriminator 1 view .LVU34
 237 0046 F401      		movw r30,r8
 238 0048 6081      		ld r22,Z
 239 004a 7181      		ldd r23,Z+1
 240 004c 8281      		ldd r24,Z+2
 241 004e 9381      		ldd r25,Z+3
 242 0050 0E94 0000 		call timer_elapsed32
 243               	.LVL16:
  86:quantum/split_common/transactions.c ****         okay &= transport_read(trans_id_retrieve, destination, length);
 244               		.loc 1 86 14 discriminator 1 view .LVU35
 245 0054 6436      		cpi r22,100
 246 0056 7105      		cpc r23,__zero_reg__
 247 0058 8105      		cpc r24,__zero_reg__
 248 005a 9105      		cpc r25,__zero_reg__
 249 005c 00F0      		brlo .L10
 250               	.L14:
  87:quantum/split_common/transactions.c ****         okay &= curr_checksum == crc8(equiv_shmem, length);
 251               		.loc 1 87 9 is_stmt 1 view .LVU36
  87:quantum/split_common/transactions.c ****         okay &= curr_checksum == crc8(equiv_shmem, length);
 252               		.loc 1 87 17 is_stmt 0 view .LVU37
 253 005e 8701      		movw r16,r14
 254 0060 9501      		movw r18,r10
 255 0062 50E0      		ldi r21,0
 256 0064 40E0      		ldi r20,0
 257 0066 70E0      		ldi r23,0
 258 0068 60E0      		ldi r22,0
 259 006a 872D      		mov r24,r7
 260 006c 0E94 0000 		call transport_execute_transaction
 261               	.LVL17:
 262 0070 B82E      		mov r11,r24
 263               	.LVL18:
  88:quantum/split_common/transactions.c ****         if (okay) {
 264               		.loc 1 88 9 is_stmt 1 view .LVU38
  88:quantum/split_common/transactions.c ****         if (okay) {
 265               		.loc 1 88 34 is_stmt 0 view .LVU39
 266 0072 B701      		movw r22,r14
 267 0074 C601      		movw r24,r12
 268 0076 0E94 0000 		call crc8
 269               	.LVL19:
  88:quantum/split_common/transactions.c ****         if (okay) {
 270               		.loc 1 88 31 view .LVU40
 271 007a 11E0      		ldi r17,lo8(1)
 272 007c 9981      		ldd r25,Y+1
 273 007e 9813      		cpse r25,r24
  88:quantum/split_common/transactions.c ****         if (okay) {
 274               		.loc 1 88 31 view .LVU41
 275 0080 10E0      		ldi r17,0
 276               	.L11:
 277 0082 1B21      		and r17,r11
 278               	.LVL20:
  89:quantum/split_common/transactions.c ****             *last_update = timer_read32();
 279               		.loc 1 89 9 is_stmt 1 view .LVU42
  89:quantum/split_common/transactions.c ****             *last_update = timer_read32();
 280               		.loc 1 89 12 is_stmt 0 view .LVU43
 281 0084 01F0      		breq .L8
 282               	.LVL21:
 283               	.LBB36:
 284               	.LBI36:
  83:quantum/split_common/transactions.c ****     uint8_t curr_checksum;
 285               		.loc 1 83 20 is_stmt 1 view .LVU44
 286               	.LBB37:
  90:quantum/split_common/transactions.c ****         }
 287               		.loc 1 90 13 view .LVU45
  90:quantum/split_common/transactions.c ****         }
 288               		.loc 1 90 28 is_stmt 0 view .LVU46
 289 0086 0E94 0000 		call timer_read32
 290               	.LVL22:
  90:quantum/split_common/transactions.c ****         }
 291               		.loc 1 90 26 view .LVU47
 292 008a F401      		movw r30,r8
 293 008c 6083      		st Z,r22
 294 008e 7183      		std Z+1,r23
 295 0090 8283      		std Z+2,r24
 296 0092 9383      		std Z+3,r25
 297               	.LVL23:
  95:quantum/split_common/transactions.c **** }
 298               		.loc 1 95 5 is_stmt 1 view .LVU48
 299               	.L8:
  95:quantum/split_common/transactions.c **** }
 300               		.loc 1 95 5 is_stmt 0 view .LVU49
 301               	.LBE37:
 302               	.LBE36:
  96:quantum/split_common/transactions.c **** 
 303               		.loc 1 96 1 view .LVU50
 304 0094 812F      		mov r24,r17
 305               	/* epilogue start */
 306 0096 0F90      		pop __tmp_reg__
 307 0098 DF91      		pop r29
 308 009a CF91      		pop r28
 309 009c 1F91      		pop r17
 310               	.LVL24:
  96:quantum/split_common/transactions.c **** 
 311               		.loc 1 96 1 view .LVU51
 312 009e 0F91      		pop r16
 313 00a0 FF90      		pop r15
 314 00a2 EF90      		pop r14
 315               	.LVL25:
  96:quantum/split_common/transactions.c **** 
 316               		.loc 1 96 1 view .LVU52
 317 00a4 DF90      		pop r13
 318 00a6 CF90      		pop r12
 319               	.LVL26:
  96:quantum/split_common/transactions.c **** 
 320               		.loc 1 96 1 view .LVU53
 321 00a8 BF90      		pop r11
 322 00aa AF90      		pop r10
 323               	.LVL27:
  96:quantum/split_common/transactions.c **** 
 324               		.loc 1 96 1 view .LVU54
 325 00ac 9F90      		pop r9
 326 00ae 8F90      		pop r8
 327               	.LVL28:
  96:quantum/split_common/transactions.c **** 
 328               		.loc 1 96 1 view .LVU55
 329 00b0 7F90      		pop r7
 330               	.LVL29:
  96:quantum/split_common/transactions.c **** 
 331               		.loc 1 96 1 view .LVU56
 332 00b2 0895      		ret
 333               	.LVL30:
 334               	.L10:
  86:quantum/split_common/transactions.c ****         okay &= transport_read(trans_id_retrieve, destination, length);
 335               		.loc 1 86 95 discriminator 2 view .LVU57
 336 00b4 B701      		movw r22,r14
 337 00b6 C601      		movw r24,r12
 338 00b8 0E94 0000 		call crc8
 339               	.LVL31:
  86:quantum/split_common/transactions.c ****         okay &= transport_read(trans_id_retrieve, destination, length);
 340               		.loc 1 86 75 discriminator 2 view .LVU58
 341 00bc 9981      		ldd r25,Y+1
 342 00be 8913      		cpse r24,r25
 343 00c0 00C0      		rjmp .L14
 344               	.L9:
  93:quantum/split_common/transactions.c ****     }
 345               		.loc 1 93 9 is_stmt 1 view .LVU59
 346 00c2 A701      		movw r20,r14
 347 00c4 B601      		movw r22,r12
 348 00c6 C501      		movw r24,r10
 349 00c8 0E94 0000 		call memcpy
 350               	.LVL32:
  95:quantum/split_common/transactions.c **** }
 351               		.loc 1 95 5 view .LVU60
  95:quantum/split_common/transactions.c **** }
 352               		.loc 1 95 12 is_stmt 0 view .LVU61
 353 00cc 00C0      		rjmp .L8
 354               		.cfi_endproc
 355               	.LFE28:
 357               		.section	.text.encoder_handlers_master,"ax",@progbits
 359               	encoder_handlers_master:
 360               	.LVL33:
 361               	.LFB33:
 177:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
 362               		.loc 1 177 96 is_stmt 1 view -0
 363               		.cfi_startproc
 177:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
 364               		.loc 1 177 96 is_stmt 0 view .LVU63
 365 0000 EF92      		push r14
 366               	.LCFI21:
 367               		.cfi_def_cfa_offset 3
 368               		.cfi_offset 14, -2
 369 0002 FF92      		push r15
 370               	.LCFI22:
 371               		.cfi_def_cfa_offset 4
 372               		.cfi_offset 15, -3
 373 0004 0F93      		push r16
 374               	.LCFI23:
 375               		.cfi_def_cfa_offset 5
 376               		.cfi_offset 16, -4
 377 0006 1F93      		push r17
 378               	.LCFI24:
 379               		.cfi_def_cfa_offset 6
 380               		.cfi_offset 17, -5
 381 0008 CF93      		push r28
 382               	.LCFI25:
 383               		.cfi_def_cfa_offset 7
 384               		.cfi_offset 28, -6
 385 000a DF93      		push r29
 386               	.LCFI26:
 387               		.cfi_def_cfa_offset 8
 388               		.cfi_offset 29, -7
 389 000c 0F92      		push __tmp_reg__
 390               	.LCFI27:
 391               		.cfi_def_cfa_offset 9
 392 000e CDB7      		in r28,__SP_L__
 393 0010 DEB7      		in r29,__SP_H__
 394               	.LCFI28:
 395               		.cfi_def_cfa_register 28
 396               	/* prologue: function */
 397               	/* frame size = 1 */
 398               	/* stack size = 7 */
 399               	.L__stack_usage = 7
 178:quantum/split_common/transactions.c ****     uint8_t         temp_state[NUMBER_OF_ENCODERS];
 400               		.loc 1 178 5 is_stmt 1 view .LVU64
 179:quantum/split_common/transactions.c **** 
 401               		.loc 1 179 5 view .LVU65
 181:quantum/split_common/transactions.c ****     if (okay) encoder_update_raw(temp_state);
 402               		.loc 1 181 5 view .LVU66
 181:quantum/split_common/transactions.c ****     if (okay) encoder_update_raw(temp_state);
 403               		.loc 1 181 132 is_stmt 0 view .LVU67
 404 0012 0091 0000 		lds r16,split_shmem
 405 0016 1091 0000 		lds r17,split_shmem+1
 406 001a 095F      		subi r16,-7
 407 001c 1F4F      		sbci r17,-1
 181:quantum/split_common/transactions.c ****     if (okay) encoder_update_raw(temp_state);
 408               		.loc 1 181 17 view .LVU68
 409 001e EE24      		clr r14
 410 0020 E394      		inc r14
 411 0022 F12C      		mov r15,__zero_reg__
 412               	.LVL34:
 181:quantum/split_common/transactions.c ****     if (okay) encoder_update_raw(temp_state);
 413               		.loc 1 181 17 view .LVU69
 414 0024 9E01      		movw r18,r28
 415 0026 2F5F      		subi r18,-1
 416 0028 3F4F      		sbci r19,-1
 417 002a 40E0      		ldi r20,lo8(last_update.4330)
 418 002c 50E0      		ldi r21,hi8(last_update.4330)
 419 002e 63E0      		ldi r22,lo8(3)
 420               	.LVL35:
 181:quantum/split_common/transactions.c ****     if (okay) encoder_update_raw(temp_state);
 421               		.loc 1 181 17 view .LVU70
 422 0030 82E0      		ldi r24,lo8(2)
 423 0032 0E94 0000 		call read_if_checksum_mismatch
 424               	.LVL36:
 425 0036 182F      		mov r17,r24
 426               	.LVL37:
 182:quantum/split_common/transactions.c ****     return okay;
 427               		.loc 1 182 5 is_stmt 1 view .LVU71
 182:quantum/split_common/transactions.c ****     return okay;
 428               		.loc 1 182 8 is_stmt 0 view .LVU72
 429 0038 8823      		tst r24
 430 003a 01F0      		breq .L18
 182:quantum/split_common/transactions.c ****     return okay;
 431               		.loc 1 182 15 is_stmt 1 discriminator 1 view .LVU73
 432 003c CE01      		movw r24,r28
 433 003e 0196      		adiw r24,1
 434 0040 0E94 0000 		call encoder_update_raw
 435               	.LVL38:
 183:quantum/split_common/transactions.c **** }
 436               		.loc 1 183 5 discriminator 1 view .LVU74
 437               	.L18:
 184:quantum/split_common/transactions.c **** 
 438               		.loc 1 184 1 is_stmt 0 view .LVU75
 439 0044 812F      		mov r24,r17
 440               	/* epilogue start */
 441 0046 0F90      		pop __tmp_reg__
 442 0048 DF91      		pop r29
 443 004a CF91      		pop r28
 444 004c 1F91      		pop r17
 445               	.LVL39:
 184:quantum/split_common/transactions.c **** 
 446               		.loc 1 184 1 view .LVU76
 447 004e 0F91      		pop r16
 448 0050 FF90      		pop r15
 449 0052 EF90      		pop r14
 450 0054 0895      		ret
 451               		.cfi_endproc
 452               	.LFE33:
 454               		.section	.text.slave_matrix_handlers_master,"ax",@progbits
 456               	slave_matrix_handlers_master:
 457               	.LVL40:
 458               	.LFB31:
 117:quantum/split_common/transactions.c ****     static uint32_t     last_update                    = 0;
 459               		.loc 1 117 101 is_stmt 1 view -0
 460               		.cfi_startproc
 117:quantum/split_common/transactions.c ****     static uint32_t     last_update                    = 0;
 461               		.loc 1 117 101 is_stmt 0 view .LVU78
 462 0000 CF92      		push r12
 463               	.LCFI29:
 464               		.cfi_def_cfa_offset 3
 465               		.cfi_offset 12, -2
 466 0002 DF92      		push r13
 467               	.LCFI30:
 468               		.cfi_def_cfa_offset 4
 469               		.cfi_offset 13, -3
 470 0004 EF92      		push r14
 471               	.LCFI31:
 472               		.cfi_def_cfa_offset 5
 473               		.cfi_offset 14, -4
 474 0006 FF92      		push r15
 475               	.LCFI32:
 476               		.cfi_def_cfa_offset 6
 477               		.cfi_offset 15, -5
 478 0008 0F93      		push r16
 479               	.LCFI33:
 480               		.cfi_def_cfa_offset 7
 481               		.cfi_offset 16, -6
 482 000a 1F93      		push r17
 483               	.LCFI34:
 484               		.cfi_def_cfa_offset 8
 485               		.cfi_offset 17, -7
 486 000c CF93      		push r28
 487               	.LCFI35:
 488               		.cfi_def_cfa_offset 9
 489               		.cfi_offset 28, -8
 490 000e DF93      		push r29
 491               	.LCFI36:
 492               		.cfi_def_cfa_offset 10
 493               		.cfi_offset 29, -9
 494 0010 00D0      		rcall .
 495 0012 00D0      		rcall .
 496 0014 0F92      		push __tmp_reg__
 497               	.LCFI37:
 498               		.cfi_def_cfa_offset 15
 499 0016 CDB7      		in r28,__SP_L__
 500 0018 DEB7      		in r29,__SP_H__
 501               	.LCFI38:
 502               		.cfi_def_cfa_register 28
 503               	/* prologue: function */
 504               	/* frame size = 5 */
 505               	/* stack size = 13 */
 506               	.L__stack_usage = 13
 507 001a 6B01      		movw r12,r22
 118:quantum/split_common/transactions.c ****     static matrix_row_t last_matrix[(MATRIX_ROWS) / 2] = {0};  // last successfully-read matrix, so
 508               		.loc 1 118 5 is_stmt 1 view .LVU79
 119:quantum/split_common/transactions.c ****     matrix_row_t        temp_matrix[(MATRIX_ROWS) / 2];        // holding area while we test whethe
 509               		.loc 1 119 5 view .LVU80
 120:quantum/split_common/transactions.c **** 
 510               		.loc 1 120 5 view .LVU81
 122:quantum/split_common/transactions.c ****     if (okay) {
 511               		.loc 1 122 5 view .LVU82
 122:quantum/split_common/transactions.c ****     if (okay) {
 512               		.loc 1 122 140 is_stmt 0 view .LVU83
 513 001c 0091 0000 		lds r16,split_shmem
 514 0020 1091 0000 		lds r17,split_shmem+1
 515 0024 0F5F      		subi r16,-1
 516 0026 1F4F      		sbci r17,-1
 122:quantum/split_common/transactions.c ****     if (okay) {
 517               		.loc 1 122 17 view .LVU84
 518 0028 85E0      		ldi r24,lo8(5)
 519 002a E82E      		mov r14,r24
 520 002c F12C      		mov r15,__zero_reg__
 521               	.LVL41:
 122:quantum/split_common/transactions.c ****     if (okay) {
 522               		.loc 1 122 17 view .LVU85
 523 002e 9E01      		movw r18,r28
 524 0030 2F5F      		subi r18,-1
 525 0032 3F4F      		sbci r19,-1
 526 0034 40E0      		ldi r20,lo8(last_update.4318)
 527 0036 50E0      		ldi r21,hi8(last_update.4318)
 528 0038 61E0      		ldi r22,lo8(1)
 529               	.LVL42:
 122:quantum/split_common/transactions.c ****     if (okay) {
 530               		.loc 1 122 17 view .LVU86
 531 003a 80E0      		ldi r24,0
 532 003c 0E94 0000 		call read_if_checksum_mismatch
 533               	.LVL43:
 123:quantum/split_common/transactions.c ****         // Checksum matches the received data, save as the last matrix state
 534               		.loc 1 123 5 is_stmt 1 view .LVU87
 123:quantum/split_common/transactions.c ****         // Checksum matches the received data, save as the last matrix state
 535               		.loc 1 123 8 is_stmt 0 view .LVU88
 536 0040 8823      		tst r24
 537 0042 01F0      		breq .L24
 125:quantum/split_common/transactions.c ****     }
 538               		.loc 1 125 9 is_stmt 1 view .LVU89
 539 0044 95E0      		ldi r25,lo8(5)
 540 0046 FE01      		movw r30,r28
 541 0048 3196      		adiw r30,1
 542 004a A0E0      		ldi r26,lo8(last_matrix.4319)
 543 004c B0E0      		ldi r27,hi8(last_matrix.4319)
 544               		0:
 545 004e 0190      		ld r0,Z+
 546 0050 0D92      		st X+,r0
 547 0052 9A95      		dec r25
 548 0054 01F4      		brne 0b
 549               	.L24:
 128:quantum/split_common/transactions.c ****     return okay;
 550               		.loc 1 128 5 view .LVU90
 551 0056 95E0      		ldi r25,lo8(5)
 552 0058 E0E0      		ldi r30,lo8(last_matrix.4319)
 553 005a F0E0      		ldi r31,hi8(last_matrix.4319)
 554 005c D601      		movw r26,r12
 555               		0:
 556 005e 0190      		ld r0,Z+
 557 0060 0D92      		st X+,r0
 558 0062 9A95      		dec r25
 559 0064 01F4      		brne 0b
 129:quantum/split_common/transactions.c **** }
 560               		.loc 1 129 5 view .LVU91
 561               	/* epilogue start */
 130:quantum/split_common/transactions.c **** 
 562               		.loc 1 130 1 is_stmt 0 view .LVU92
 563 0066 0F90      		pop __tmp_reg__
 564 0068 0F90      		pop __tmp_reg__
 565 006a 0F90      		pop __tmp_reg__
 566 006c 0F90      		pop __tmp_reg__
 567 006e 0F90      		pop __tmp_reg__
 568 0070 DF91      		pop r29
 569 0072 CF91      		pop r28
 570 0074 1F91      		pop r17
 571 0076 0F91      		pop r16
 572 0078 FF90      		pop r15
 573 007a EF90      		pop r14
 574 007c DF90      		pop r13
 575 007e CF90      		pop r12
 576               	.LVL44:
 130:quantum/split_common/transactions.c **** 
 577               		.loc 1 130 1 view .LVU93
 578 0080 0895      		ret
 579               		.cfi_endproc
 580               	.LFE31:
 582               		.section	.text.transaction_handler_master.isra.3,"ax",@progbits
 584               	transaction_handler_master.isra.3:
 585               	.LVL45:
 586               	.LFB42:
  57:quantum/split_common/transactions.c ****     int num_retries = is_transport_connected() ? 10 : 1;
 587               		.loc 1 57 13 is_stmt 1 view -0
 588               		.cfi_startproc
  57:quantum/split_common/transactions.c ****     int num_retries = is_transport_connected() ? 10 : 1;
 589               		.loc 1 57 13 is_stmt 0 view .LVU95
 590 0000 AF92      		push r10
 591               	.LCFI39:
 592               		.cfi_def_cfa_offset 3
 593               		.cfi_offset 10, -2
 594 0002 BF92      		push r11
 595               	.LCFI40:
 596               		.cfi_def_cfa_offset 4
 597               		.cfi_offset 11, -3
 598 0004 CF92      		push r12
 599               	.LCFI41:
 600               		.cfi_def_cfa_offset 5
 601               		.cfi_offset 12, -4
 602 0006 DF92      		push r13
 603               	.LCFI42:
 604               		.cfi_def_cfa_offset 6
 605               		.cfi_offset 13, -5
 606 0008 EF92      		push r14
 607               	.LCFI43:
 608               		.cfi_def_cfa_offset 7
 609               		.cfi_offset 14, -6
 610 000a FF92      		push r15
 611               	.LCFI44:
 612               		.cfi_def_cfa_offset 8
 613               		.cfi_offset 15, -7
 614 000c 0F93      		push r16
 615               	.LCFI45:
 616               		.cfi_def_cfa_offset 9
 617               		.cfi_offset 16, -8
 618 000e 1F93      		push r17
 619               	.LCFI46:
 620               		.cfi_def_cfa_offset 10
 621               		.cfi_offset 17, -9
 622 0010 CF93      		push r28
 623               	.LCFI47:
 624               		.cfi_def_cfa_offset 11
 625               		.cfi_offset 28, -10
 626 0012 DF93      		push r29
 627               	.LCFI48:
 628               		.cfi_def_cfa_offset 12
 629               		.cfi_offset 29, -11
 630               	/* prologue: function */
 631               	/* frame size = 0 */
 632               	/* stack size = 10 */
 633               	.L__stack_usage = 10
 634 0014 7C01      		movw r14,r24
 635 0016 5B01      		movw r10,r22
 636 0018 6A01      		movw r12,r20
 637               	.LVL46:
  58:quantum/split_common/transactions.c ****     for (int iter = 1; iter <= num_retries; ++iter) {
 638               		.loc 1 58 5 is_stmt 1 view .LVU96
  58:quantum/split_common/transactions.c ****     for (int iter = 1; iter <= num_retries; ++iter) {
 639               		.loc 1 58 23 is_stmt 0 view .LVU97
 640 001a 0E94 0000 		call is_transport_connected
 641               	.LVL47:
  58:quantum/split_common/transactions.c ****     for (int iter = 1; iter <= num_retries; ++iter) {
 642               		.loc 1 58 53 view .LVU98
 643 001e 01E0      		ldi r16,lo8(1)
 644 0020 10E0      		ldi r17,0
 645 0022 8823      		tst r24
 646 0024 01F0      		breq .L29
 647 0026 0AE0      		ldi r16,lo8(10)
 648 0028 10E0      		ldi r17,0
 649               	.L29:
 650               	.LVL48:
  59:quantum/split_common/transactions.c ****         if (iter > 1) {
 651               		.loc 1 59 5 is_stmt 1 view .LVU99
 652               	.LBB48:
  59:quantum/split_common/transactions.c ****         if (iter > 1) {
 653               		.loc 1 59 10 view .LVU100
 654               	.LBB49:
  60:quantum/split_common/transactions.c ****             for (int i = 0; i < iter * iter; ++i) {
 655               		.loc 1 60 9 view .LVU101
 656               	.LBE49:
  59:quantum/split_common/transactions.c ****         if (iter > 1) {
 657               		.loc 1 59 14 is_stmt 0 view .LVU102
 658 002a C1E0      		ldi r28,lo8(1)
 659 002c D0E0      		ldi r29,0
 660               	.LVL49:
 661               	.L30:
 662               	.LBB58:
  65:quantum/split_common/transactions.c ****         ATOMIC_BLOCK_FORCEON { this_okay = handler(master_matrix, slave_matrix); };
 663               		.loc 1 65 9 is_stmt 1 view .LVU103
  66:quantum/split_common/transactions.c ****         if (this_okay) return true;
 664               		.loc 1 66 9 view .LVU104
 665               	.LBB50:
  66:quantum/split_common/transactions.c ****         if (this_okay) return true;
 666               		.loc 1 66 9 view .LVU105
 667               	.LBB51:
 668               	.LBI51:
 669               		.file 2 "/usr/avr/include/util/atomic.h"
   1:/usr/avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/usr/avr/include/util/atomic.h ****    All rights reserved.
   3:/usr/avr/include/util/atomic.h **** 
   4:/usr/avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/usr/avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/usr/avr/include/util/atomic.h **** 
   7:/usr/avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/usr/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/usr/avr/include/util/atomic.h **** 
  10:/usr/avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/usr/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/usr/avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/usr/avr/include/util/atomic.h ****      distribution.
  14:/usr/avr/include/util/atomic.h **** 
  15:/usr/avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/usr/avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/usr/avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/usr/avr/include/util/atomic.h **** 
  19:/usr/avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/usr/avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/usr/avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/usr/avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/usr/avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/usr/avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/usr/avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/usr/avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/usr/avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/usr/avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/usr/avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/usr/avr/include/util/atomic.h **** */
  31:/usr/avr/include/util/atomic.h **** 
  32:/usr/avr/include/util/atomic.h **** /* $Id: atomic.h 2158 2010-06-10 15:48:28Z joerg_wunsch $ */
  33:/usr/avr/include/util/atomic.h **** 
  34:/usr/avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/usr/avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/usr/avr/include/util/atomic.h **** 
  37:/usr/avr/include/util/atomic.h **** #include <avr/io.h>
  38:/usr/avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/usr/avr/include/util/atomic.h **** 
  40:/usr/avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/usr/avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/usr/avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/usr/avr/include/util/atomic.h **** {
  44:/usr/avr/include/util/atomic.h ****     sei();
  45:/usr/avr/include/util/atomic.h ****     return 1;
  46:/usr/avr/include/util/atomic.h **** }
  47:/usr/avr/include/util/atomic.h **** 
  48:/usr/avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
 670               		.loc 2 48 27 view .LVU106
 671               	.LBB52:
  49:/usr/avr/include/util/atomic.h **** {
  50:/usr/avr/include/util/atomic.h ****     cli();
 672               		.loc 2 50 5 view .LVU107
 673               	/* #APP */
 674               	 ;  50 "/usr/avr/include/util/atomic.h" 1
 675 002e F894      		cli
 676               	 ;  0 "" 2
  51:/usr/avr/include/util/atomic.h ****     return 1;
 677               		.loc 2 51 5 view .LVU108
 678               	.LVL50:
 679               		.loc 2 51 5 is_stmt 0 view .LVU109
 680               	/* #NOAPP */
 681               	.LBE52:
 682               	.LBE51:
  66:quantum/split_common/transactions.c ****         if (this_okay) return true;
 683               		.loc 1 66 32 is_stmt 1 view .LVU110
  66:quantum/split_common/transactions.c ****         if (this_okay) return true;
 684               		.loc 1 66 44 is_stmt 0 view .LVU111
 685 0030 B501      		movw r22,r10
 686 0032 C701      		movw r24,r14
 687 0034 F601      		movw r30,r12
 688 0036 0995      		icall
 689               	.LVL51:
 690               	.LBB53:
 691               	.LBI53:
  52:/usr/avr/include/util/atomic.h **** }
  53:/usr/avr/include/util/atomic.h **** 
  54:/usr/avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
 692               		.loc 2 54 24 is_stmt 1 view .LVU112
 693               	.LBB54:
  55:/usr/avr/include/util/atomic.h **** {
  56:/usr/avr/include/util/atomic.h ****     sei();
 694               		.loc 2 56 5 view .LVU113
 695               	/* #APP */
 696               	 ;  56 "/usr/avr/include/util/atomic.h" 1
 697 0038 7894      		sei
 698               	 ;  0 "" 2
  57:/usr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 699               		.loc 2 57 5 view .LVU114
  58:/usr/avr/include/util/atomic.h ****     (void)__s;
 700               		.loc 2 58 5 view .LVU115
 701               	.LVL52:
 702               		.loc 2 58 5 is_stmt 0 view .LVU116
 703               	/* #NOAPP */
 704               	.LBE54:
 705               	.LBE53:
 706               	.LBE50:
  66:quantum/split_common/transactions.c ****         if (this_okay) return true;
 707               		.loc 1 66 83 is_stmt 1 view .LVU117
  67:quantum/split_common/transactions.c ****     }
 708               		.loc 1 67 9 view .LVU118
  67:quantum/split_common/transactions.c ****     }
 709               		.loc 1 67 12 is_stmt 0 view .LVU119
 710 003a 8111      		cpse r24,__zero_reg__
 711 003c 00C0      		rjmp .L28
 712               	.LBE58:
  59:quantum/split_common/transactions.c ****         if (iter > 1) {
 713               		.loc 1 59 45 view .LVU120
 714 003e 2196      		adiw r28,1
 715               	.LVL53:
  59:quantum/split_common/transactions.c ****         if (iter > 1) {
 716               		.loc 1 59 5 view .LVU121
 717 0040 0C17      		cp r16,r28
 718 0042 1D07      		cpc r17,r29
 719 0044 04F4      		brge .L33
 720               	.LVL54:
 721               	.L28:
 722               	/* epilogue start */
  59:quantum/split_common/transactions.c ****         if (iter > 1) {
 723               		.loc 1 59 5 view .LVU122
 724               	.LBE48:
  71:quantum/split_common/transactions.c **** 
 725               		.loc 1 71 1 view .LVU123
 726 0046 DF91      		pop r29
 727 0048 CF91      		pop r28
 728 004a 1F91      		pop r17
 729 004c 0F91      		pop r16
 730               	.LVL55:
  71:quantum/split_common/transactions.c **** 
 731               		.loc 1 71 1 view .LVU124
 732 004e FF90      		pop r15
 733 0050 EF90      		pop r14
 734               	.LVL56:
  71:quantum/split_common/transactions.c **** 
 735               		.loc 1 71 1 view .LVU125
 736 0052 DF90      		pop r13
 737 0054 CF90      		pop r12
 738               	.LVL57:
  71:quantum/split_common/transactions.c **** 
 739               		.loc 1 71 1 view .LVU126
 740 0056 BF90      		pop r11
 741 0058 AF90      		pop r10
 742               	.LVL58:
  71:quantum/split_common/transactions.c **** 
 743               		.loc 1 71 1 view .LVU127
 744 005a 0895      		ret
 745               	.LVL59:
 746               	.L33:
 747               	.LBB60:
 748               	.LBB59:
 749               	.LBB55:
  61:quantum/split_common/transactions.c ****                 wait_us(10);
 750               		.loc 1 61 38 view .LVU128
 751 005c CC9F      		mul r28,r28
 752 005e 9001      		movw r18,r0
 753 0060 CD9F      		mul r28,r29
 754 0062 300D      		add r19,r0
 755 0064 300D      		add r19,r0
 756 0066 1124      		clr r1
  61:quantum/split_common/transactions.c ****                 wait_us(10);
 757               		.loc 1 61 22 view .LVU129
 758 0068 90E0      		ldi r25,0
 759 006a 80E0      		ldi r24,0
 760               	.LVL60:
 761               	.L31:
  62:quantum/split_common/transactions.c ****             }
 762               		.loc 1 62 17 is_stmt 1 view .LVU130
  62:quantum/split_common/transactions.c ****             }
 763               		.loc 1 62 17 view .LVU131
  62:quantum/split_common/transactions.c ****             }
 764               		.loc 1 62 17 view .LVU132
 765               	.LBB56:
 766               	.LBI56:
 767               		.file 3 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/avr/include/util/delay.h **** #endif
 210:/usr/avr/include/util/delay.h **** }
 211:/usr/avr/include/util/delay.h **** 
 212:/usr/avr/include/util/delay.h **** /**
 213:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/avr/include/util/delay.h **** 
 215:/usr/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/avr/include/util/delay.h **** 
 217:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/avr/include/util/delay.h **** 
 220:/usr/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/avr/include/util/delay.h **** 
 222:/usr/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/avr/include/util/delay.h **** 
 226:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/avr/include/util/delay.h **** 
 231:/usr/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/avr/include/util/delay.h **** 
 236:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/avr/include/util/delay.h ****    respectively.
 240:/usr/avr/include/util/delay.h **** 
 241:/usr/avr/include/util/delay.h ****    \note
 242:/usr/avr/include/util/delay.h **** 
 243:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/avr/include/util/delay.h **** 
 253:/usr/avr/include/util/delay.h ****  */
 254:/usr/avr/include/util/delay.h **** void
 255:/usr/avr/include/util/delay.h **** _delay_us(double __us)
 768               		.loc 3 255 1 view .LVU133
 769               	.LBB57:
 256:/usr/avr/include/util/delay.h **** {
 257:/usr/avr/include/util/delay.h **** 	double __tmp ;
 770               		.loc 3 257 2 view .LVU134
 258:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 771               		.loc 3 261 2 view .LVU135
 262:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 772               		.loc 3 262 2 view .LVU136
 263:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 773               		.loc 3 263 2 view .LVU137
 264:/usr/avr/include/util/delay.h **** 
 265:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/avr/include/util/delay.h **** 
 268:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/avr/include/util/delay.h **** 
 271:/usr/avr/include/util/delay.h **** 	#else
 272:/usr/avr/include/util/delay.h **** 		//round up by default
 273:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 774               		.loc 3 273 3 view .LVU138
 274:/usr/avr/include/util/delay.h **** 	#endif
 275:/usr/avr/include/util/delay.h **** 
 276:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 775               		.loc 3 276 2 view .LVU139
 776 006c 45E3      		ldi r20,lo8(53)
 777 006e 4A95      	1:	dec r20
 778 0070 01F4      		brne 1b
 779 0072 0000      		nop
 780               	.LVL61:
 781               		.loc 3 276 2 is_stmt 0 view .LVU140
 782               	.LBE57:
 783               	.LBE56:
  61:quantum/split_common/transactions.c ****                 wait_us(10);
 784               		.loc 1 61 46 view .LVU141
 785 0074 0196      		adiw r24,1
 786               	.LVL62:
  61:quantum/split_common/transactions.c ****                 wait_us(10);
 787               		.loc 1 61 13 view .LVU142
 788 0076 8217      		cp r24,r18
 789 0078 9307      		cpc r25,r19
 790 007a 01F4      		brne .L31
 791 007c 00C0      		rjmp .L30
 792               	.LBE55:
 793               	.LBE59:
 794               	.LBE60:
 795               		.cfi_endproc
 796               	.LFE42:
 798               		.section	.text.transactions_master,"ax",@progbits
 799               	.global	transactions_master
 801               	transactions_master:
 802               	.LVL63:
 803               	.LFB37:
 229:quantum/split_common/transactions.c **** 
 230:quantum/split_common/transactions.c **** static void sync_timer_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 231:quantum/split_common/transactions.c ****     static uint32_t last_sync_timer = 0;
 232:quantum/split_common/transactions.c ****     if (last_sync_timer != split_shmem->sync_timer) {
 233:quantum/split_common/transactions.c ****         last_sync_timer = split_shmem->sync_timer;
 234:quantum/split_common/transactions.c ****         sync_timer_update(last_sync_timer);
 235:quantum/split_common/transactions.c ****     }
 236:quantum/split_common/transactions.c **** }
 237:quantum/split_common/transactions.c **** 
 238:quantum/split_common/transactions.c **** #    define TRANSACTIONS_SYNC_TIMER_MASTER()      TRANSACTION_HANDLER_MASTER(sync_timer)
 239:quantum/split_common/transactions.c **** #    define TRANSACTIONS_SYNC_TIMER_SLAVE()       TRANSACTION_HANDLER_SLAVE(sync_timer)
 240:quantum/split_common/transactions.c **** #    define TRANSACTIONS_SYNC_TIMER_REGISTRATIONS [PUT_SYNC_TIMER] = trans_initiator2target_initial
 241:quantum/split_common/transactions.c **** 
 242:quantum/split_common/transactions.c **** #else  // DISABLE_SYNC_TIMER
 243:quantum/split_common/transactions.c **** 
 244:quantum/split_common/transactions.c **** #    define TRANSACTIONS_SYNC_TIMER_MASTER()
 245:quantum/split_common/transactions.c **** #    define TRANSACTIONS_SYNC_TIMER_SLAVE()
 246:quantum/split_common/transactions.c **** #    define TRANSACTIONS_SYNC_TIMER_REGISTRATIONS
 247:quantum/split_common/transactions.c **** 
 248:quantum/split_common/transactions.c **** #endif  // DISABLE_SYNC_TIMER
 249:quantum/split_common/transactions.c **** 
 250:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 251:quantum/split_common/transactions.c **** // Layer state
 252:quantum/split_common/transactions.c **** 
 253:quantum/split_common/transactions.c **** #if !defined(NO_ACTION_LAYER) && defined(SPLIT_LAYER_STATE_ENABLE)
 254:quantum/split_common/transactions.c **** 
 255:quantum/split_common/transactions.c **** static bool layer_state_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) 
 256:quantum/split_common/transactions.c ****     static uint32_t last_layer_state_update         = 0;
 257:quantum/split_common/transactions.c ****     static uint32_t last_default_layer_state_update = 0;
 258:quantum/split_common/transactions.c **** 
 259:quantum/split_common/transactions.c ****     bool okay = send_if_condition(PUT_LAYER_STATE, &last_layer_state_update, (layer_state != split_
 260:quantum/split_common/transactions.c ****     if (okay) {
 261:quantum/split_common/transactions.c ****         okay &= send_if_condition(PUT_DEFAULT_LAYER_STATE, &last_default_layer_state_update, (defau
 262:quantum/split_common/transactions.c ****     }
 263:quantum/split_common/transactions.c ****     return okay;
 264:quantum/split_common/transactions.c **** }
 265:quantum/split_common/transactions.c **** 
 266:quantum/split_common/transactions.c **** static void layer_state_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 267:quantum/split_common/transactions.c ****     layer_state         = split_shmem->layers.layer_state;
 268:quantum/split_common/transactions.c ****     default_layer_state = split_shmem->layers.default_layer_state;
 269:quantum/split_common/transactions.c **** }
 270:quantum/split_common/transactions.c **** 
 271:quantum/split_common/transactions.c **** // clang-format off
 272:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LAYER_STATE_MASTER() TRANSACTION_HANDLER_MASTER(layer_state)
 273:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LAYER_STATE_SLAVE() TRANSACTION_HANDLER_SLAVE(layer_state)
 274:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LAYER_STATE_REGISTRATIONS \
 275:quantum/split_common/transactions.c ****     [PUT_LAYER_STATE]         = trans_initiator2target_initializer(layers.layer_state), \
 276:quantum/split_common/transactions.c ****     [PUT_DEFAULT_LAYER_STATE] = trans_initiator2target_initializer(layers.default_layer_state),
 277:quantum/split_common/transactions.c **** // clang-format on
 278:quantum/split_common/transactions.c **** 
 279:quantum/split_common/transactions.c **** #else  // !defined(NO_ACTION_LAYER) && defined(SPLIT_LAYER_STATE_ENABLE)
 280:quantum/split_common/transactions.c **** 
 281:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LAYER_STATE_MASTER()
 282:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LAYER_STATE_SLAVE()
 283:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LAYER_STATE_REGISTRATIONS
 284:quantum/split_common/transactions.c **** 
 285:quantum/split_common/transactions.c **** #endif  // !defined(NO_ACTION_LAYER) && defined(SPLIT_LAYER_STATE_ENABLE)
 286:quantum/split_common/transactions.c **** 
 287:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 288:quantum/split_common/transactions.c **** // LED state
 289:quantum/split_common/transactions.c **** 
 290:quantum/split_common/transactions.c **** #ifdef SPLIT_LED_STATE_ENABLE
 291:quantum/split_common/transactions.c **** 
 292:quantum/split_common/transactions.c **** static bool led_state_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 293:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
 294:quantum/split_common/transactions.c ****     uint8_t         led_state   = host_keyboard_leds();
 295:quantum/split_common/transactions.c ****     return send_if_data_mismatch(PUT_LED_STATE, &last_update, &led_state, &split_shmem->led_state, 
 296:quantum/split_common/transactions.c **** }
 297:quantum/split_common/transactions.c **** 
 298:quantum/split_common/transactions.c **** static void led_state_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 299:quantum/split_common/transactions.c ****     void set_split_host_keyboard_leds(uint8_t led_state);
 300:quantum/split_common/transactions.c ****     set_split_host_keyboard_leds(split_shmem->led_state);
 301:quantum/split_common/transactions.c **** }
 302:quantum/split_common/transactions.c **** 
 303:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_STATE_MASTER()      TRANSACTION_HANDLER_MASTER(led_state)
 304:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_STATE_SLAVE()       TRANSACTION_HANDLER_SLAVE(led_state)
 305:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_STATE_REGISTRATIONS [PUT_LED_STATE] = trans_initiator2target_initializ
 306:quantum/split_common/transactions.c **** 
 307:quantum/split_common/transactions.c **** #else  // SPLIT_LED_STATE_ENABLE
 308:quantum/split_common/transactions.c **** 
 309:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_STATE_MASTER()
 310:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_STATE_SLAVE()
 311:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_STATE_REGISTRATIONS
 312:quantum/split_common/transactions.c **** 
 313:quantum/split_common/transactions.c **** #endif  // SPLIT_LED_STATE_ENABLE
 314:quantum/split_common/transactions.c **** 
 315:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 316:quantum/split_common/transactions.c **** // Mods
 317:quantum/split_common/transactions.c **** 
 318:quantum/split_common/transactions.c **** #ifdef SPLIT_MODS_ENABLE
 319:quantum/split_common/transactions.c **** 
 320:quantum/split_common/transactions.c **** static bool mods_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 321:quantum/split_common/transactions.c ****     static uint32_t   last_update    = 0;
 322:quantum/split_common/transactions.c ****     bool              mods_need_sync = timer_elapsed32(last_update) >= FORCED_SYNC_THROTTLE_MS;
 323:quantum/split_common/transactions.c ****     split_mods_sync_t new_mods;
 324:quantum/split_common/transactions.c ****     new_mods.real_mods = get_mods();
 325:quantum/split_common/transactions.c ****     if (!mods_need_sync && new_mods.real_mods != split_shmem->mods.real_mods) {
 326:quantum/split_common/transactions.c ****         mods_need_sync = true;
 327:quantum/split_common/transactions.c ****     }
 328:quantum/split_common/transactions.c **** 
 329:quantum/split_common/transactions.c ****     new_mods.weak_mods = get_weak_mods();
 330:quantum/split_common/transactions.c ****     if (!mods_need_sync && new_mods.weak_mods != split_shmem->mods.weak_mods) {
 331:quantum/split_common/transactions.c ****         mods_need_sync = true;
 332:quantum/split_common/transactions.c ****     }
 333:quantum/split_common/transactions.c **** 
 334:quantum/split_common/transactions.c **** #    ifndef NO_ACTION_ONESHOT
 335:quantum/split_common/transactions.c ****     new_mods.oneshot_mods = get_oneshot_mods();
 336:quantum/split_common/transactions.c ****     if (!mods_need_sync && new_mods.oneshot_mods != split_shmem->mods.oneshot_mods) {
 337:quantum/split_common/transactions.c ****         mods_need_sync = true;
 338:quantum/split_common/transactions.c ****     }
 339:quantum/split_common/transactions.c **** #    endif  // NO_ACTION_ONESHOT
 340:quantum/split_common/transactions.c **** 
 341:quantum/split_common/transactions.c ****     bool okay = true;
 342:quantum/split_common/transactions.c ****     if (mods_need_sync) {
 343:quantum/split_common/transactions.c ****         okay &= transport_write(PUT_MODS, &new_mods, sizeof(new_mods));
 344:quantum/split_common/transactions.c ****         if (okay) {
 345:quantum/split_common/transactions.c ****             last_update = timer_read32();
 346:quantum/split_common/transactions.c ****         }
 347:quantum/split_common/transactions.c ****     }
 348:quantum/split_common/transactions.c **** 
 349:quantum/split_common/transactions.c ****     return okay;
 350:quantum/split_common/transactions.c **** }
 351:quantum/split_common/transactions.c **** 
 352:quantum/split_common/transactions.c **** static void mods_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 353:quantum/split_common/transactions.c ****     set_mods(split_shmem->mods.real_mods);
 354:quantum/split_common/transactions.c ****     set_weak_mods(split_shmem->mods.weak_mods);
 355:quantum/split_common/transactions.c **** #    ifndef NO_ACTION_ONESHOT
 356:quantum/split_common/transactions.c ****     set_oneshot_mods(split_shmem->mods.oneshot_mods);
 357:quantum/split_common/transactions.c **** #    endif
 358:quantum/split_common/transactions.c **** }
 359:quantum/split_common/transactions.c **** 
 360:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MODS_MASTER()      TRANSACTION_HANDLER_MASTER(mods)
 361:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MODS_SLAVE()       TRANSACTION_HANDLER_SLAVE(mods)
 362:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MODS_REGISTRATIONS [PUT_MODS] = trans_initiator2target_initializer(mods),
 363:quantum/split_common/transactions.c **** 
 364:quantum/split_common/transactions.c **** #else  // SPLIT_MODS_ENABLE
 365:quantum/split_common/transactions.c **** 
 366:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MODS_MASTER()
 367:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MODS_SLAVE()
 368:quantum/split_common/transactions.c **** #    define TRANSACTIONS_MODS_REGISTRATIONS
 369:quantum/split_common/transactions.c **** 
 370:quantum/split_common/transactions.c **** #endif  // SPLIT_MODS_ENABLE
 371:quantum/split_common/transactions.c **** 
 372:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 373:quantum/split_common/transactions.c **** // Backlight
 374:quantum/split_common/transactions.c **** 
 375:quantum/split_common/transactions.c **** #ifdef BACKLIGHT_ENABLE
 376:quantum/split_common/transactions.c **** 
 377:quantum/split_common/transactions.c **** static bool backlight_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 378:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
 379:quantum/split_common/transactions.c ****     uint8_t         level       = is_backlight_enabled() ? get_backlight_level() : 0;
 380:quantum/split_common/transactions.c ****     return send_if_condition(PUT_BACKLIGHT, &last_update, (level != split_shmem->backlight_level), 
 381:quantum/split_common/transactions.c **** }
 382:quantum/split_common/transactions.c **** 
 383:quantum/split_common/transactions.c **** static void backlight_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) { b
 384:quantum/split_common/transactions.c **** 
 385:quantum/split_common/transactions.c **** #    define TRANSACTIONS_BACKLIGHT_MASTER()      TRANSACTION_HANDLER_MASTER(backlight)
 386:quantum/split_common/transactions.c **** #    define TRANSACTIONS_BACKLIGHT_SLAVE()       TRANSACTION_HANDLER_SLAVE(backlight)
 387:quantum/split_common/transactions.c **** #    define TRANSACTIONS_BACKLIGHT_REGISTRATIONS [PUT_BACKLIGHT] = trans_initiator2target_initializ
 388:quantum/split_common/transactions.c **** 
 389:quantum/split_common/transactions.c **** #else  // BACKLIGHT_ENABLE
 390:quantum/split_common/transactions.c **** 
 391:quantum/split_common/transactions.c **** #    define TRANSACTIONS_BACKLIGHT_MASTER()
 392:quantum/split_common/transactions.c **** #    define TRANSACTIONS_BACKLIGHT_SLAVE()
 393:quantum/split_common/transactions.c **** #    define TRANSACTIONS_BACKLIGHT_REGISTRATIONS
 394:quantum/split_common/transactions.c **** 
 395:quantum/split_common/transactions.c **** #endif  // BACKLIGHT_ENABLE
 396:quantum/split_common/transactions.c **** 
 397:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 398:quantum/split_common/transactions.c **** // RGBLIGHT
 399:quantum/split_common/transactions.c **** 
 400:quantum/split_common/transactions.c **** #if defined(RGBLIGHT_ENABLE) && defined(RGBLIGHT_SPLIT)
 401:quantum/split_common/transactions.c **** 
 402:quantum/split_common/transactions.c **** static bool rgblight_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 403:quantum/split_common/transactions.c ****     static uint32_t     last_update = 0;
 404:quantum/split_common/transactions.c ****     rgblight_syncinfo_t rgblight_sync;
 405:quantum/split_common/transactions.c ****     rgblight_get_syncinfo(&rgblight_sync);
 406:quantum/split_common/transactions.c ****     if (send_if_condition(PUT_RGBLIGHT, &last_update, (rgblight_sync.status.change_flags != 0), &rg
 407:quantum/split_common/transactions.c ****         rgblight_clear_change_flags();
 408:quantum/split_common/transactions.c ****     } else {
 409:quantum/split_common/transactions.c ****         return false;
 410:quantum/split_common/transactions.c ****     }
 411:quantum/split_common/transactions.c ****     return true;
 412:quantum/split_common/transactions.c **** }
 413:quantum/split_common/transactions.c **** 
 414:quantum/split_common/transactions.c **** static void rgblight_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 415:quantum/split_common/transactions.c ****     // Update the RGB with the new data
 416:quantum/split_common/transactions.c ****     if (split_shmem->rgblight_sync.status.change_flags != 0) {
 417:quantum/split_common/transactions.c ****         rgblight_update_sync(&split_shmem->rgblight_sync, false);
 418:quantum/split_common/transactions.c ****         split_shmem->rgblight_sync.status.change_flags = 0;
 419:quantum/split_common/transactions.c ****     }
 420:quantum/split_common/transactions.c **** }
 421:quantum/split_common/transactions.c **** 
 422:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGBLIGHT_MASTER()      TRANSACTION_HANDLER_MASTER(rgblight)
 423:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGBLIGHT_SLAVE()       TRANSACTION_HANDLER_SLAVE(rgblight)
 424:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGBLIGHT_REGISTRATIONS [PUT_RGBLIGHT] = trans_initiator2target_initializer
 425:quantum/split_common/transactions.c **** 
 426:quantum/split_common/transactions.c **** #else  // defined(RGBLIGHT_ENABLE) && defined(RGBLIGHT_SPLIT)
 427:quantum/split_common/transactions.c **** 
 428:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGBLIGHT_MASTER()
 429:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGBLIGHT_SLAVE()
 430:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGBLIGHT_REGISTRATIONS
 431:quantum/split_common/transactions.c **** 
 432:quantum/split_common/transactions.c **** #endif  // defined(RGBLIGHT_ENABLE) && defined(RGBLIGHT_SPLIT)
 433:quantum/split_common/transactions.c **** 
 434:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 435:quantum/split_common/transactions.c **** // LED Matrix
 436:quantum/split_common/transactions.c **** 
 437:quantum/split_common/transactions.c **** #if defined(LED_MATRIX_ENABLE) && defined(LED_MATRIX_SPLIT)
 438:quantum/split_common/transactions.c **** 
 439:quantum/split_common/transactions.c **** static bool led_matrix_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 440:quantum/split_common/transactions.c ****     static uint32_t   last_update = 0;
 441:quantum/split_common/transactions.c ****     led_matrix_sync_t led_matrix_sync;
 442:quantum/split_common/transactions.c ****     memcpy(&led_matrix_sync.led_matrix, &led_matrix_eeconfig, sizeof(led_eeconfig_t));
 443:quantum/split_common/transactions.c ****     led_matrix_sync.led_suspend_state = led_matrix_get_suspend_state();
 444:quantum/split_common/transactions.c ****     return send_if_data_mismatch(PUT_LED_MATRIX, &last_update, &led_matrix_sync, &split_shmem->led_
 445:quantum/split_common/transactions.c **** }
 446:quantum/split_common/transactions.c **** 
 447:quantum/split_common/transactions.c **** static void led_matrix_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 448:quantum/split_common/transactions.c ****     memcpy(&led_matrix_eeconfig, &split_shmem->led_matrix_sync.led_matrix, sizeof(led_eeconfig_t));
 449:quantum/split_common/transactions.c ****     led_matrix_set_suspend_state(split_shmem->led_matrix_sync.led_suspend_state);
 450:quantum/split_common/transactions.c **** }
 451:quantum/split_common/transactions.c **** 
 452:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_MATRIX_MASTER()      TRANSACTION_HANDLER_MASTER(led_matrix)
 453:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_MATRIX_SLAVE()       TRANSACTION_HANDLER_SLAVE(led_matrix)
 454:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_MATRIX_REGISTRATIONS [PUT_LED_MATRIX] = trans_initiator2target_initial
 455:quantum/split_common/transactions.c **** 
 456:quantum/split_common/transactions.c **** #else  // defined(LED_MATRIX_ENABLE) && defined(LED_MATRIX_SPLIT)
 457:quantum/split_common/transactions.c **** 
 458:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_MATRIX_MASTER()
 459:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_MATRIX_SLAVE()
 460:quantum/split_common/transactions.c **** #    define TRANSACTIONS_LED_MATRIX_REGISTRATIONS
 461:quantum/split_common/transactions.c **** 
 462:quantum/split_common/transactions.c **** #endif  // defined(LED_MATRIX_ENABLE) && defined(LED_MATRIX_SPLIT)
 463:quantum/split_common/transactions.c **** 
 464:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 465:quantum/split_common/transactions.c **** // RGB Matrix
 466:quantum/split_common/transactions.c **** 
 467:quantum/split_common/transactions.c **** #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_SPLIT)
 468:quantum/split_common/transactions.c **** 
 469:quantum/split_common/transactions.c **** static bool rgb_matrix_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 470:quantum/split_common/transactions.c ****     static uint32_t   last_update = 0;
 471:quantum/split_common/transactions.c ****     rgb_matrix_sync_t rgb_matrix_sync;
 472:quantum/split_common/transactions.c ****     memcpy(&rgb_matrix_sync.rgb_matrix, &rgb_matrix_config, sizeof(rgb_config_t));
 473:quantum/split_common/transactions.c ****     rgb_matrix_sync.rgb_suspend_state = rgb_matrix_get_suspend_state();
 474:quantum/split_common/transactions.c ****     return send_if_data_mismatch(PUT_RGB_MATRIX, &last_update, &rgb_matrix_sync, &split_shmem->rgb_
 475:quantum/split_common/transactions.c **** }
 476:quantum/split_common/transactions.c **** 
 477:quantum/split_common/transactions.c **** static void rgb_matrix_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 478:quantum/split_common/transactions.c ****     memcpy(&rgb_matrix_config, &split_shmem->rgb_matrix_sync.rgb_matrix, sizeof(rgb_config_t));
 479:quantum/split_common/transactions.c ****     rgb_matrix_set_suspend_state(split_shmem->rgb_matrix_sync.rgb_suspend_state);
 480:quantum/split_common/transactions.c **** }
 481:quantum/split_common/transactions.c **** 
 482:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGB_MATRIX_MASTER()      TRANSACTION_HANDLER_MASTER(rgb_matrix)
 483:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGB_MATRIX_SLAVE()       TRANSACTION_HANDLER_SLAVE(rgb_matrix)
 484:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGB_MATRIX_REGISTRATIONS [PUT_RGB_MATRIX] = trans_initiator2target_initial
 485:quantum/split_common/transactions.c **** 
 486:quantum/split_common/transactions.c **** #else  // defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_SPLIT)
 487:quantum/split_common/transactions.c **** 
 488:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGB_MATRIX_MASTER()
 489:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGB_MATRIX_SLAVE()
 490:quantum/split_common/transactions.c **** #    define TRANSACTIONS_RGB_MATRIX_REGISTRATIONS
 491:quantum/split_common/transactions.c **** 
 492:quantum/split_common/transactions.c **** #endif  // defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_SPLIT)
 493:quantum/split_common/transactions.c **** 
 494:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 495:quantum/split_common/transactions.c **** // WPM
 496:quantum/split_common/transactions.c **** 
 497:quantum/split_common/transactions.c **** #if defined(WPM_ENABLE) && defined(SPLIT_WPM_ENABLE)
 498:quantum/split_common/transactions.c **** 
 499:quantum/split_common/transactions.c **** static bool wpm_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 500:quantum/split_common/transactions.c ****     static uint32_t last_update = 0;
 501:quantum/split_common/transactions.c ****     uint8_t         current_wpm = get_current_wpm();
 502:quantum/split_common/transactions.c ****     return send_if_condition(PUT_WPM, &last_update, (current_wpm != split_shmem->current_wpm), &cur
 503:quantum/split_common/transactions.c **** }
 504:quantum/split_common/transactions.c **** 
 505:quantum/split_common/transactions.c **** static void wpm_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) { set_cur
 506:quantum/split_common/transactions.c **** 
 507:quantum/split_common/transactions.c **** #    define TRANSACTIONS_WPM_MASTER()      TRANSACTION_HANDLER_MASTER(wpm)
 508:quantum/split_common/transactions.c **** #    define TRANSACTIONS_WPM_SLAVE()       TRANSACTION_HANDLER_SLAVE(wpm)
 509:quantum/split_common/transactions.c **** #    define TRANSACTIONS_WPM_REGISTRATIONS [PUT_WPM] = trans_initiator2target_initializer(current_w
 510:quantum/split_common/transactions.c **** 
 511:quantum/split_common/transactions.c **** #else  // defined(WPM_ENABLE) && defined(SPLIT_WPM_ENABLE)
 512:quantum/split_common/transactions.c **** 
 513:quantum/split_common/transactions.c **** #    define TRANSACTIONS_WPM_MASTER()
 514:quantum/split_common/transactions.c **** #    define TRANSACTIONS_WPM_SLAVE()
 515:quantum/split_common/transactions.c **** #    define TRANSACTIONS_WPM_REGISTRATIONS
 516:quantum/split_common/transactions.c **** 
 517:quantum/split_common/transactions.c **** #endif  // defined(WPM_ENABLE) && defined(SPLIT_WPM_ENABLE)
 518:quantum/split_common/transactions.c **** 
 519:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 520:quantum/split_common/transactions.c **** // OLED
 521:quantum/split_common/transactions.c **** 
 522:quantum/split_common/transactions.c **** #if defined(OLED_ENABLE) && defined(SPLIT_OLED_ENABLE)
 523:quantum/split_common/transactions.c **** 
 524:quantum/split_common/transactions.c **** static bool oled_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 525:quantum/split_common/transactions.c ****     static uint32_t last_update        = 0;
 526:quantum/split_common/transactions.c ****     bool            current_oled_state = is_oled_on();
 527:quantum/split_common/transactions.c ****     return send_if_condition(PUT_OLED, &last_update, (current_oled_state != split_shmem->current_ol
 528:quantum/split_common/transactions.c **** }
 529:quantum/split_common/transactions.c **** 
 530:quantum/split_common/transactions.c **** static void oled_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 531:quantum/split_common/transactions.c ****     if (split_shmem->current_oled_state) {
 532:quantum/split_common/transactions.c ****         oled_on();
 533:quantum/split_common/transactions.c ****     } else {
 534:quantum/split_common/transactions.c ****         oled_off();
 535:quantum/split_common/transactions.c ****     }
 536:quantum/split_common/transactions.c **** }
 537:quantum/split_common/transactions.c **** 
 538:quantum/split_common/transactions.c **** #    define TRANSACTIONS_OLED_MASTER()      TRANSACTION_HANDLER_MASTER(oled)
 539:quantum/split_common/transactions.c **** #    define TRANSACTIONS_OLED_SLAVE()       TRANSACTION_HANDLER_SLAVE(oled)
 540:quantum/split_common/transactions.c **** #    define TRANSACTIONS_OLED_REGISTRATIONS [PUT_OLED] = trans_initiator2target_initializer(current
 541:quantum/split_common/transactions.c **** 
 542:quantum/split_common/transactions.c **** #else  // defined(OLED_ENABLE) && defined(SPLIT_OLED_ENABLE)
 543:quantum/split_common/transactions.c **** 
 544:quantum/split_common/transactions.c **** #    define TRANSACTIONS_OLED_MASTER()
 545:quantum/split_common/transactions.c **** #    define TRANSACTIONS_OLED_SLAVE()
 546:quantum/split_common/transactions.c **** #    define TRANSACTIONS_OLED_REGISTRATIONS
 547:quantum/split_common/transactions.c **** 
 548:quantum/split_common/transactions.c **** #endif  // defined(OLED_ENABLE) && defined(SPLIT_OLED_ENABLE)
 549:quantum/split_common/transactions.c **** 
 550:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 551:quantum/split_common/transactions.c **** // ST7565
 552:quantum/split_common/transactions.c **** 
 553:quantum/split_common/transactions.c **** #if defined(ST7565_ENABLE) && defined(SPLIT_ST7565_ENABLE)
 554:quantum/split_common/transactions.c **** 
 555:quantum/split_common/transactions.c **** static bool st7565_handlers_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 556:quantum/split_common/transactions.c ****     static uint32_t last_update          = 0;
 557:quantum/split_common/transactions.c ****     bool            current_st7565_state = st7565_is_on();
 558:quantum/split_common/transactions.c ****     return send_if_condition(PUT_ST7565, &last_update, (current_st7565_state != split_shmem->curren
 559:quantum/split_common/transactions.c **** }
 560:quantum/split_common/transactions.c **** 
 561:quantum/split_common/transactions.c **** static void st7565_handlers_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 562:quantum/split_common/transactions.c ****     if (split_shmem->current_st7565_state) {
 563:quantum/split_common/transactions.c ****         st7565_on();
 564:quantum/split_common/transactions.c ****     } else {
 565:quantum/split_common/transactions.c ****         st7565_off();
 566:quantum/split_common/transactions.c ****     }
 567:quantum/split_common/transactions.c **** }
 568:quantum/split_common/transactions.c **** 
 569:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ST7565_MASTER()      TRANSACTION_HANDLER_MASTER(st7565)
 570:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ST7565_SLAVE()       TRANSACTION_HANDLER_SLAVE(st7565)
 571:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ST7565_REGISTRATIONS [PUT_ST7565] = trans_initiator2target_initializer(cur
 572:quantum/split_common/transactions.c **** 
 573:quantum/split_common/transactions.c **** #else  // defined(ST7565_ENABLE) && defined(SPLIT_ST7565_ENABLE)
 574:quantum/split_common/transactions.c **** 
 575:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ST7565_MASTER()
 576:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ST7565_SLAVE()
 577:quantum/split_common/transactions.c **** #    define TRANSACTIONS_ST7565_REGISTRATIONS
 578:quantum/split_common/transactions.c **** 
 579:quantum/split_common/transactions.c **** #endif  // defined(ST7565_ENABLE) && defined(SPLIT_ST7565_ENABLE)
 580:quantum/split_common/transactions.c **** 
 581:quantum/split_common/transactions.c **** ////////////////////////////////////////////////////
 582:quantum/split_common/transactions.c **** 
 583:quantum/split_common/transactions.c **** uint8_t                  dummy;
 584:quantum/split_common/transactions.c **** split_transaction_desc_t split_transaction_table[NUM_TOTAL_TRANSACTIONS] = {
 585:quantum/split_common/transactions.c ****     // Set defaults
 586:quantum/split_common/transactions.c ****     [0 ...(NUM_TOTAL_TRANSACTIONS - 1)] = {NULL, 0, 0, 0, 0, 0},
 587:quantum/split_common/transactions.c **** 
 588:quantum/split_common/transactions.c **** #ifdef USE_I2C
 589:quantum/split_common/transactions.c ****     [I2C_EXECUTE_CALLBACK] = trans_initiator2target_initializer(transaction_id),
 590:quantum/split_common/transactions.c **** #endif  // USE_I2C
 591:quantum/split_common/transactions.c **** 
 592:quantum/split_common/transactions.c ****     // clang-format off
 593:quantum/split_common/transactions.c ****     TRANSACTIONS_SLAVE_MATRIX_REGISTRATIONS
 594:quantum/split_common/transactions.c ****     TRANSACTIONS_MASTER_MATRIX_REGISTRATIONS
 595:quantum/split_common/transactions.c ****     TRANSACTIONS_ENCODERS_REGISTRATIONS
 596:quantum/split_common/transactions.c ****     TRANSACTIONS_SYNC_TIMER_REGISTRATIONS
 597:quantum/split_common/transactions.c ****     TRANSACTIONS_LAYER_STATE_REGISTRATIONS
 598:quantum/split_common/transactions.c ****     TRANSACTIONS_LED_STATE_REGISTRATIONS
 599:quantum/split_common/transactions.c ****     TRANSACTIONS_MODS_REGISTRATIONS
 600:quantum/split_common/transactions.c ****     TRANSACTIONS_BACKLIGHT_REGISTRATIONS
 601:quantum/split_common/transactions.c ****     TRANSACTIONS_RGBLIGHT_REGISTRATIONS
 602:quantum/split_common/transactions.c ****     TRANSACTIONS_LED_MATRIX_REGISTRATIONS
 603:quantum/split_common/transactions.c ****     TRANSACTIONS_RGB_MATRIX_REGISTRATIONS
 604:quantum/split_common/transactions.c ****     TRANSACTIONS_WPM_REGISTRATIONS
 605:quantum/split_common/transactions.c ****     TRANSACTIONS_OLED_REGISTRATIONS
 606:quantum/split_common/transactions.c ****     TRANSACTIONS_ST7565_REGISTRATIONS
 607:quantum/split_common/transactions.c **** // clang-format on
 608:quantum/split_common/transactions.c **** 
 609:quantum/split_common/transactions.c **** #if defined(SPLIT_TRANSACTION_IDS_KB) || defined(SPLIT_TRANSACTION_IDS_USER)
 610:quantum/split_common/transactions.c ****         [PUT_RPC_INFO]  = trans_initiator2target_initializer_cb(rpc_info, slave_rpc_info_callback),
 611:quantum/split_common/transactions.c ****     [PUT_RPC_REQ_DATA]  = trans_initiator2target_initializer(rpc_m2s_buffer),
 612:quantum/split_common/transactions.c ****     [EXECUTE_RPC]       = trans_initiator2target_initializer_cb(rpc_info.transaction_id, slave_rpc_
 613:quantum/split_common/transactions.c ****     [GET_RPC_RESP_DATA] = trans_target2initiator_initializer(rpc_s2m_buffer),
 614:quantum/split_common/transactions.c **** #endif  // defined(SPLIT_TRANSACTION_IDS_KB) || defined(SPLIT_TRANSACTION_IDS_USER)
 615:quantum/split_common/transactions.c **** };
 616:quantum/split_common/transactions.c **** 
 617:quantum/split_common/transactions.c **** bool transactions_master(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 804               		.loc 1 617 85 is_stmt 1 view -0
 805               		.cfi_startproc
 806               		.loc 1 617 85 is_stmt 0 view .LVU144
 807 0000 0F93      		push r16
 808               	.LCFI49:
 809               		.cfi_def_cfa_offset 3
 810               		.cfi_offset 16, -2
 811 0002 1F93      		push r17
 812               	.LCFI50:
 813               		.cfi_def_cfa_offset 4
 814               		.cfi_offset 17, -3
 815 0004 CF93      		push r28
 816               	.LCFI51:
 817               		.cfi_def_cfa_offset 5
 818               		.cfi_offset 28, -4
 819 0006 DF93      		push r29
 820               	.LCFI52:
 821               		.cfi_def_cfa_offset 6
 822               		.cfi_offset 29, -5
 823               	/* prologue: function */
 824               	/* frame size = 0 */
 825               	/* stack size = 4 */
 826               	.L__stack_usage = 4
 827 0008 EC01      		movw r28,r24
 828 000a 8B01      		movw r16,r22
 618:quantum/split_common/transactions.c ****     TRANSACTIONS_SLAVE_MATRIX_MASTER();
 829               		.loc 1 618 5 is_stmt 1 view .LVU145
 830               		.loc 1 618 5 view .LVU146
 831 000c 40E0      		ldi r20,lo8(gs(slave_matrix_handlers_master))
 832 000e 50E0      		ldi r21,hi8(gs(slave_matrix_handlers_master))
 833 0010 0E94 0000 		call transaction_handler_master.isra.3
 834               	.LVL64:
 835               		.loc 1 618 5 is_stmt 0 view .LVU147
 836 0014 8823      		tst r24
 837 0016 01F0      		breq .L38
 619:quantum/split_common/transactions.c ****     TRANSACTIONS_MASTER_MATRIX_MASTER();
 838               		.loc 1 619 40 is_stmt 1 view .LVU148
 620:quantum/split_common/transactions.c ****     TRANSACTIONS_ENCODERS_MASTER();
 839               		.loc 1 620 5 view .LVU149
 840               		.loc 1 620 5 view .LVU150
 841 0018 40E0      		ldi r20,lo8(gs(encoder_handlers_master))
 842 001a 50E0      		ldi r21,hi8(gs(encoder_handlers_master))
 843 001c B801      		movw r22,r16
 844 001e CE01      		movw r24,r28
 845 0020 0E94 0000 		call transaction_handler_master.isra.3
 846               	.LVL65:
 847 0024 8823      		tst r24
 848 0026 01F0      		breq .L38
 621:quantum/split_common/transactions.c ****     TRANSACTIONS_SYNC_TIMER_MASTER();
 849               		.loc 1 621 5 view .LVU151
 850               		.loc 1 621 5 view .LVU152
 851 0028 40E0      		ldi r20,lo8(gs(sync_timer_handlers_master))
 852 002a 50E0      		ldi r21,hi8(gs(sync_timer_handlers_master))
 853 002c B801      		movw r22,r16
 854 002e CE01      		movw r24,r28
 855               	/* epilogue start */
 622:quantum/split_common/transactions.c ****     TRANSACTIONS_LAYER_STATE_MASTER();
 623:quantum/split_common/transactions.c ****     TRANSACTIONS_LED_STATE_MASTER();
 624:quantum/split_common/transactions.c ****     TRANSACTIONS_MODS_MASTER();
 625:quantum/split_common/transactions.c ****     TRANSACTIONS_BACKLIGHT_MASTER();
 626:quantum/split_common/transactions.c ****     TRANSACTIONS_RGBLIGHT_MASTER();
 627:quantum/split_common/transactions.c ****     TRANSACTIONS_LED_MATRIX_MASTER();
 628:quantum/split_common/transactions.c ****     TRANSACTIONS_RGB_MATRIX_MASTER();
 629:quantum/split_common/transactions.c ****     TRANSACTIONS_WPM_MASTER();
 630:quantum/split_common/transactions.c ****     TRANSACTIONS_OLED_MASTER();
 631:quantum/split_common/transactions.c ****     TRANSACTIONS_ST7565_MASTER();
 632:quantum/split_common/transactions.c ****     return true;
 633:quantum/split_common/transactions.c **** }
 856               		.loc 1 633 1 is_stmt 0 view .LVU153
 857 0030 DF91      		pop r29
 858 0032 CF91      		pop r28
 859               	.LVL66:
 860               		.loc 1 633 1 view .LVU154
 861 0034 1F91      		pop r17
 862 0036 0F91      		pop r16
 863               	.LVL67:
 621:quantum/split_common/transactions.c ****     TRANSACTIONS_SYNC_TIMER_MASTER();
 864               		.loc 1 621 5 view .LVU155
 865 0038 0C94 0000 		jmp transaction_handler_master.isra.3
 866               	.LVL68:
 867               	.L38:
 868               		.loc 1 633 1 view .LVU156
 869 003c 80E0      		ldi r24,0
 870               	/* epilogue start */
 871 003e DF91      		pop r29
 872 0040 CF91      		pop r28
 873               	.LVL69:
 874               		.loc 1 633 1 view .LVU157
 875 0042 1F91      		pop r17
 876 0044 0F91      		pop r16
 877               	.LVL70:
 878               		.loc 1 633 1 view .LVU158
 879 0046 0895      		ret
 880               		.cfi_endproc
 881               	.LFE37:
 883               		.section	.text.transactions_slave,"ax",@progbits
 884               	.global	transactions_slave
 886               	transactions_slave:
 887               	.LVL71:
 888               	.LFB38:
 634:quantum/split_common/transactions.c **** 
 635:quantum/split_common/transactions.c **** void transactions_slave(matrix_row_t master_matrix[], matrix_row_t slave_matrix[]) {
 889               		.loc 1 635 84 is_stmt 1 view -0
 890               		.cfi_startproc
 891               		.loc 1 635 84 is_stmt 0 view .LVU160
 892 0000 0F93      		push r16
 893               	.LCFI53:
 894               		.cfi_def_cfa_offset 3
 895               		.cfi_offset 16, -2
 896 0002 1F93      		push r17
 897               	.LCFI54:
 898               		.cfi_def_cfa_offset 4
 899               		.cfi_offset 17, -3
 900 0004 CF93      		push r28
 901               	.LCFI55:
 902               		.cfi_def_cfa_offset 5
 903               		.cfi_offset 28, -4
 904 0006 DF93      		push r29
 905               	.LCFI56:
 906               		.cfi_def_cfa_offset 6
 907               		.cfi_offset 29, -5
 908 0008 0F92      		push __tmp_reg__
 909               	.LCFI57:
 910               		.cfi_def_cfa_offset 7
 911 000a CDB7      		in r28,__SP_L__
 912 000c DEB7      		in r29,__SP_H__
 913               	.LCFI58:
 914               		.cfi_def_cfa_register 28
 915               	/* prologue: function */
 916               	/* frame size = 1 */
 917               	/* stack size = 5 */
 918               	.L__stack_usage = 5
 636:quantum/split_common/transactions.c ****     TRANSACTIONS_SLAVE_MATRIX_SLAVE();
 919               		.loc 1 636 5 is_stmt 1 view .LVU161
 920               		.loc 1 636 5 view .LVU162
 921               	.LBB82:
 922               		.loc 1 636 5 view .LVU163
 923               	.LVL72:
 924               	.LBB83:
 925               	.LBI83:
  48:/usr/avr/include/util/atomic.h **** {
 926               		.loc 2 48 27 view .LVU164
 927               	.LBB84:
  50:/usr/avr/include/util/atomic.h ****     return 1;
 928               		.loc 2 50 5 view .LVU165
 929               	/* #APP */
 930               	 ;  50 "/usr/avr/include/util/atomic.h" 1
 931 000e F894      		cli
 932               	 ;  0 "" 2
  51:/usr/avr/include/util/atomic.h **** }
 933               		.loc 2 51 5 view .LVU166
 934               	.LVL73:
  51:/usr/avr/include/util/atomic.h **** }
 935               		.loc 2 51 5 is_stmt 0 view .LVU167
 936               	/* #NOAPP */
 937               	.LBE84:
 938               	.LBE83:
 939               		.loc 1 636 5 is_stmt 1 view .LVU168
 940               	.LBB85:
 941               	.LBI85:
 132:quantum/split_common/transactions.c ****     memcpy(split_shmem->smatrix.matrix, slave_matrix, sizeof(split_shmem->smatrix.matrix));
 942               		.loc 1 132 13 view .LVU169
 943               	.LBB86:
 133:quantum/split_common/transactions.c ****     split_shmem->smatrix.checksum = crc8(split_shmem->smatrix.matrix, sizeof(split_shmem->smatrix.m
 944               		.loc 1 133 5 view .LVU170
 133:quantum/split_common/transactions.c ****     split_shmem->smatrix.checksum = crc8(split_shmem->smatrix.matrix, sizeof(split_shmem->smatrix.m
 945               		.loc 1 133 23 is_stmt 0 view .LVU171
 946 0010 0091 0000 		lds r16,split_shmem
 947 0014 1091 0000 		lds r17,split_shmem+1
 133:quantum/split_common/transactions.c ****     split_shmem->smatrix.checksum = crc8(split_shmem->smatrix.matrix, sizeof(split_shmem->smatrix.m
 948               		.loc 1 133 32 view .LVU172
 949 0018 C801      		movw r24,r16
 950               	.LVL74:
 133:quantum/split_common/transactions.c ****     split_shmem->smatrix.checksum = crc8(split_shmem->smatrix.matrix, sizeof(split_shmem->smatrix.m
 951               		.loc 1 133 32 view .LVU173
 952 001a 0196      		adiw r24,1
 133:quantum/split_common/transactions.c ****     split_shmem->smatrix.checksum = crc8(split_shmem->smatrix.matrix, sizeof(split_shmem->smatrix.m
 953               		.loc 1 133 5 view .LVU174
 954 001c 25E0      		ldi r18,lo8(5)
 955 001e FB01      		movw r30,r22
 956 0020 DC01      		movw r26,r24
 957               		0:
 958 0022 0190      		ld r0,Z+
 959 0024 0D92      		st X+,r0
 960 0026 2A95      		dec r18
 961 0028 01F4      		brne 0b
 134:quantum/split_common/transactions.c **** }
 962               		.loc 1 134 5 is_stmt 1 view .LVU175
 134:quantum/split_common/transactions.c **** }
 963               		.loc 1 134 37 is_stmt 0 view .LVU176
 964 002a 65E0      		ldi r22,lo8(5)
 965 002c 70E0      		ldi r23,0
 966               	.LVL75:
 134:quantum/split_common/transactions.c **** }
 967               		.loc 1 134 37 view .LVU177
 968 002e 0E94 0000 		call crc8
 969               	.LVL76:
 134:quantum/split_common/transactions.c **** }
 970               		.loc 1 134 35 view .LVU178
 971 0032 F801      		movw r30,r16
 972 0034 8083      		st Z,r24
 973               	.LVL77:
 134:quantum/split_common/transactions.c **** }
 974               		.loc 1 134 35 view .LVU179
 975               	.LBE86:
 976               	.LBE85:
 977               	.LBB87:
 978               	.LBI87:
  54:/usr/avr/include/util/atomic.h **** {
 979               		.loc 2 54 24 is_stmt 1 view .LVU180
 980               	.LBB88:
  56:/usr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 981               		.loc 2 56 5 view .LVU181
 982               	/* #APP */
 983               	 ;  56 "/usr/avr/include/util/atomic.h" 1
 984 0036 7894      		sei
 985               	 ;  0 "" 2
  57:/usr/avr/include/util/atomic.h ****     (void)__s;
 986               		.loc 2 57 5 view .LVU182
 987               		.loc 2 58 5 view .LVU183
 988               	.LVL78:
 989               		.loc 2 58 5 is_stmt 0 view .LVU184
 990               	/* #NOAPP */
 991               	.LBE88:
 992               	.LBE87:
 993               	.LBE82:
 994               		.loc 1 636 5 is_stmt 1 view .LVU185
 637:quantum/split_common/transactions.c ****     TRANSACTIONS_MASTER_MATRIX_SLAVE();
 995               		.loc 1 637 39 view .LVU186
 638:quantum/split_common/transactions.c ****     TRANSACTIONS_ENCODERS_SLAVE();
 996               		.loc 1 638 5 view .LVU187
 997               		.loc 1 638 5 view .LVU188
 998               	.LBB89:
 999               		.loc 1 638 5 view .LVU189
 1000               	.LBB90:
 1001               	.LBI90:
  48:/usr/avr/include/util/atomic.h **** {
 1002               		.loc 2 48 27 view .LVU190
 1003               	.LBB91:
  50:/usr/avr/include/util/atomic.h ****     return 1;
 1004               		.loc 2 50 5 view .LVU191
 1005               	/* #APP */
 1006               	 ;  50 "/usr/avr/include/util/atomic.h" 1
 1007 0038 F894      		cli
 1008               	 ;  0 "" 2
  51:/usr/avr/include/util/atomic.h **** }
 1009               		.loc 2 51 5 view .LVU192
 1010               	.LVL79:
  51:/usr/avr/include/util/atomic.h **** }
 1011               		.loc 2 51 5 is_stmt 0 view .LVU193
 1012               	/* #NOAPP */
 1013               	.LBE91:
 1014               	.LBE90:
 1015               		.loc 1 638 5 is_stmt 1 view .LVU194
 1016               	.LBB92:
 1017               	.LBI92:
 186:quantum/split_common/transactions.c ****     uint8_t encoder_state[NUMBER_OF_ENCODERS];
 1018               		.loc 1 186 13 view .LVU195
 1019               	.LBB93:
 187:quantum/split_common/transactions.c ****     encoder_state_raw(encoder_state);
 1020               		.loc 1 187 5 view .LVU196
 188:quantum/split_common/transactions.c ****     // Always prepare the encoder state for read.
 1021               		.loc 1 188 5 view .LVU197
 1022 003a CE01      		movw r24,r28
 1023 003c 0196      		adiw r24,1
 1024 003e 0E94 0000 		call encoder_state_raw
 1025               	.LVL80:
 190:quantum/split_common/transactions.c ****     // Now update the checksum given that the encoders has been written to
 1026               		.loc 1 190 5 view .LVU198
 1027 0042 8981      		ldd r24,Y+1
 1028 0044 F801      		movw r30,r16
 1029 0046 8783      		std Z+7,r24
 192:quantum/split_common/transactions.c **** }
 1030               		.loc 1 192 5 view .LVU199
 192:quantum/split_common/transactions.c **** }
 1031               		.loc 1 192 38 is_stmt 0 view .LVU200
 1032 0048 61E0      		ldi r22,lo8(1)
 1033 004a 70E0      		ldi r23,0
 1034 004c CE01      		movw r24,r28
 1035 004e 0196      		adiw r24,1
 1036 0050 0E94 0000 		call crc8
 1037               	.LVL81:
 192:quantum/split_common/transactions.c **** }
 1038               		.loc 1 192 36 view .LVU201
 1039 0054 F801      		movw r30,r16
 1040 0056 8683      		std Z+6,r24
 1041               	.LVL82:
 192:quantum/split_common/transactions.c **** }
 1042               		.loc 1 192 36 view .LVU202
 1043               	.LBE93:
 1044               	.LBE92:
 1045               	.LBB94:
 1046               	.LBI94:
  54:/usr/avr/include/util/atomic.h **** {
 1047               		.loc 2 54 24 is_stmt 1 view .LVU203
 1048               	.LBB95:
  56:/usr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 1049               		.loc 2 56 5 view .LVU204
 1050               	/* #APP */
 1051               	 ;  56 "/usr/avr/include/util/atomic.h" 1
 1052 0058 7894      		sei
 1053               	 ;  0 "" 2
  57:/usr/avr/include/util/atomic.h ****     (void)__s;
 1054               		.loc 2 57 5 view .LVU205
 1055               		.loc 2 58 5 view .LVU206
 1056               	.LVL83:
 1057               		.loc 2 58 5 is_stmt 0 view .LVU207
 1058               	/* #NOAPP */
 1059               	.LBE95:
 1060               	.LBE94:
 1061               	.LBE89:
 1062               		.loc 1 638 5 is_stmt 1 view .LVU208
 639:quantum/split_common/transactions.c ****     TRANSACTIONS_SYNC_TIMER_SLAVE();
 1063               		.loc 1 639 5 view .LVU209
 1064               		.loc 1 639 5 view .LVU210
 1065               	.LBB96:
 1066               		.loc 1 639 5 view .LVU211
 1067               	.LBB97:
 1068               	.LBI97:
  48:/usr/avr/include/util/atomic.h **** {
 1069               		.loc 2 48 27 view .LVU212
 1070               	.LBB98:
  50:/usr/avr/include/util/atomic.h ****     return 1;
 1071               		.loc 2 50 5 view .LVU213
 1072               	/* #APP */
 1073               	 ;  50 "/usr/avr/include/util/atomic.h" 1
 1074 005a F894      		cli
 1075               	 ;  0 "" 2
  51:/usr/avr/include/util/atomic.h **** }
 1076               		.loc 2 51 5 view .LVU214
 1077               	.LVL84:
  51:/usr/avr/include/util/atomic.h **** }
 1078               		.loc 2 51 5 is_stmt 0 view .LVU215
 1079               	/* #NOAPP */
 1080               	.LBE98:
 1081               	.LBE97:
 1082               		.loc 1 639 5 is_stmt 1 view .LVU216
 1083               	.LBB99:
 1084               	.LBI99:
 230:quantum/split_common/transactions.c ****     static uint32_t last_sync_timer = 0;
 1085               		.loc 1 230 13 view .LVU217
 1086               	.LBB100:
 231:quantum/split_common/transactions.c ****     if (last_sync_timer != split_shmem->sync_timer) {
 1087               		.loc 1 231 5 view .LVU218
 232:quantum/split_common/transactions.c ****         last_sync_timer = split_shmem->sync_timer;
 1088               		.loc 1 232 5 view .LVU219
 232:quantum/split_common/transactions.c ****         last_sync_timer = split_shmem->sync_timer;
 1089               		.loc 1 232 39 is_stmt 0 view .LVU220
 1090 005c 6085      		ldd r22,Z+8
 1091 005e 7185      		ldd r23,Z+9
 1092 0060 8285      		ldd r24,Z+10
 1093 0062 9385      		ldd r25,Z+11
 232:quantum/split_common/transactions.c ****         last_sync_timer = split_shmem->sync_timer;
 1094               		.loc 1 232 8 view .LVU221
 1095 0064 0091 0000 		lds r16,last_sync_timer.4351
 1096 0068 1091 0000 		lds r17,last_sync_timer.4351+1
 1097 006c 2091 0000 		lds r18,last_sync_timer.4351+2
 1098 0070 3091 0000 		lds r19,last_sync_timer.4351+3
 1099 0074 6017      		cp r22,r16
 1100 0076 7107      		cpc r23,r17
 1101 0078 8207      		cpc r24,r18
 1102 007a 9307      		cpc r25,r19
 1103 007c 01F0      		breq .L44
 233:quantum/split_common/transactions.c ****         sync_timer_update(last_sync_timer);
 1104               		.loc 1 233 9 is_stmt 1 view .LVU222
 233:quantum/split_common/transactions.c ****         sync_timer_update(last_sync_timer);
 1105               		.loc 1 233 25 is_stmt 0 view .LVU223
 1106 007e 6093 0000 		sts last_sync_timer.4351,r22
 1107 0082 7093 0000 		sts last_sync_timer.4351+1,r23
 1108 0086 8093 0000 		sts last_sync_timer.4351+2,r24
 1109 008a 9093 0000 		sts last_sync_timer.4351+3,r25
 234:quantum/split_common/transactions.c ****     }
 1110               		.loc 1 234 9 is_stmt 1 view .LVU224
 1111 008e 0E94 0000 		call sync_timer_update
 1112               	.LVL85:
 1113               	.L44:
 234:quantum/split_common/transactions.c ****     }
 1114               		.loc 1 234 9 is_stmt 0 view .LVU225
 1115               	.LBE100:
 1116               	.LBE99:
 1117               	.LBB101:
 1118               	.LBI101:
  54:/usr/avr/include/util/atomic.h **** {
 1119               		.loc 2 54 24 is_stmt 1 view .LVU226
 1120               	.LBB102:
  56:/usr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 1121               		.loc 2 56 5 view .LVU227
 1122               	/* #APP */
 1123               	 ;  56 "/usr/avr/include/util/atomic.h" 1
 1124 0092 7894      		sei
 1125               	 ;  0 "" 2
  57:/usr/avr/include/util/atomic.h ****     (void)__s;
 1126               		.loc 2 57 5 view .LVU228
 1127               		.loc 2 58 5 view .LVU229
 1128               	.LVL86:
 1129               		.loc 2 58 5 is_stmt 0 view .LVU230
 1130               	/* #NOAPP */
 1131               	.LBE102:
 1132               	.LBE101:
 1133               	.LBE96:
 1134               		.loc 1 639 5 is_stmt 1 view .LVU231
 640:quantum/split_common/transactions.c ****     TRANSACTIONS_LAYER_STATE_SLAVE();
 1135               		.loc 1 640 37 view .LVU232
 641:quantum/split_common/transactions.c ****     TRANSACTIONS_LED_STATE_SLAVE();
 1136               		.loc 1 641 35 view .LVU233
 642:quantum/split_common/transactions.c ****     TRANSACTIONS_MODS_SLAVE();
 1137               		.loc 1 642 30 view .LVU234
 643:quantum/split_common/transactions.c ****     TRANSACTIONS_BACKLIGHT_SLAVE();
 1138               		.loc 1 643 35 view .LVU235
 644:quantum/split_common/transactions.c ****     TRANSACTIONS_RGBLIGHT_SLAVE();
 1139               		.loc 1 644 34 view .LVU236
 645:quantum/split_common/transactions.c ****     TRANSACTIONS_LED_MATRIX_SLAVE();
 1140               		.loc 1 645 36 view .LVU237
 646:quantum/split_common/transactions.c ****     TRANSACTIONS_RGB_MATRIX_SLAVE();
 1141               		.loc 1 646 36 view .LVU238
 647:quantum/split_common/transactions.c ****     TRANSACTIONS_WPM_SLAVE();
 1142               		.loc 1 647 29 view .LVU239
 648:quantum/split_common/transactions.c ****     TRANSACTIONS_OLED_SLAVE();
 1143               		.loc 1 648 30 view .LVU240
 649:quantum/split_common/transactions.c ****     TRANSACTIONS_ST7565_SLAVE();
 1144               		.loc 1 649 32 view .LVU241
 1145               	/* epilogue start */
 650:quantum/split_common/transactions.c **** }
 1146               		.loc 1 650 1 is_stmt 0 view .LVU242
 1147 0094 0F90      		pop __tmp_reg__
 1148 0096 DF91      		pop r29
 1149 0098 CF91      		pop r28
 1150 009a 1F91      		pop r17
 1151 009c 0F91      		pop r16
 1152 009e 0895      		ret
 1153               		.cfi_endproc
 1154               	.LFE38:
 1156               		.section	.bss.last_sync_timer.4351,"aw",@nobits
 1159               	last_sync_timer.4351:
 1160 0000 0000 0000 		.zero	4
 1161               		.section	.bss.last_matrix.4319,"aw",@nobits
 1164               	last_matrix.4319:
 1165 0000 0000 0000 		.zero	5
 1165      00
 1166               		.section	.bss.last_update.4318,"aw",@nobits
 1169               	last_update.4318:
 1170 0000 0000 0000 		.zero	4
 1171               		.section	.bss.last_update.4330,"aw",@nobits
 1174               	last_update.4330:
 1175 0000 0000 0000 		.zero	4
 1176               		.section	.bss.last_update.4344,"aw",@nobits
 1179               	last_update.4344:
 1180 0000 0000 0000 		.zero	4
 1181               	.global	split_transaction_table
 1182               		.section	.data.split_transaction_table,"aw"
 1185               	split_transaction_table:
 1186 0000 0000      		.word	dummy
 1187 0002 00        		.byte	0
 1188 0003 0000      		.word	0
 1189 0005 01        		.byte	1
 1190 0006 0000      		.word	0
 1191 0008 0000      		.word	0
 1192 000a 0000      		.word	dummy
 1193 000c 00        		.byte	0
 1194 000d 0000      		.word	0
 1195 000f 05        		.byte	5
 1196 0010 0100      		.word	1
 1197 0012 0000      		.word	0
 1198 0014 0000      		.word	dummy
 1199 0016 00        		.byte	0
 1200 0017 0000      		.word	0
 1201 0019 01        		.byte	1
 1202 001a 0600      		.word	6
 1203 001c 0000      		.word	0
 1204 001e 0000      		.word	dummy
 1205 0020 00        		.byte	0
 1206 0021 0000      		.word	0
 1207 0023 01        		.byte	1
 1208 0024 0700      		.word	7
 1209 0026 0000      		.word	0
 1210 0028 0000      		.word	dummy
 1211 002a 04        		.byte	4
 1212 002b 0800      		.word	8
 1213 002d 00        		.byte	0
 1214 002e 0000      		.word	0
 1215 0030 0000      		.word	0
 1216               		.comm	dummy,1,1
 1217               		.weak	crc8
 1218               		.text
 1219               	.Letext0:
 1220               		.file 4 "/usr/avr/include/stdint.h"
 1221               		.file 5 "/usr/lib/gcc/avr/8.3.0/include/stddef.h"
 1222               		.file 6 "quantum/matrix.h"
 1223               		.file 7 "quantum/keyboard.h"
 1224               		.file 8 "quantum/action.h"
 1225               		.file 9 "tmk_core/common/report.h"
 1226               		.file 10 "tmk_core/common/host.h"
 1227               		.file 11 "quantum/logging/debug.h"
 1228               		.file 12 "quantum/keycode_config.h"
 1229               		.file 13 "tmk_core/common/timer.h"
 1230               		.file 14 "quantum/sequencer/sequencer.h"
 1231               		.file 15 "quantum/keymap.h"
 1232               		.file 16 "quantum/action_layer.h"
 1233               		.file 17 "tmk_core/common/avr/gpio.h"
 1234               		.file 18 "quantum/action_util.h"
 1235               		.file 19 "quantum/send_string.h"
 1236               		.file 20 "/usr/avr/include/stdlib.h"
 1237               		.file 21 "quantum/split_common/transaction_id_define.h"
 1238               		.file 22 "quantum/split_common/transport.h"
 1239               		.file 23 "quantum/split_common/transactions.h"
 1240               		.file 24 "/usr/avr/include/stdio.h"
 1241               		.file 25 "quantum/split_common/split_util.h"
 1242               		.file 26 "quantum/crc.h"
 1243               		.file 27 "quantum/encoder.h"
 1244               		.file 28 "tmk_core/common/sync_timer.h"
 1245               		.file 29 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 transactions.c
     /tmp/ccpe8v4W.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccpe8v4W.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccpe8v4W.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccpe8v4W.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccpe8v4W.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccpe8v4W.s:12     .text.sync_timer_handlers_master:0000000000000000 sync_timer_handlers_master
     /tmp/ccpe8v4W.s:1179   .bss.last_update.4344:0000000000000000 last_update.4344
     /tmp/ccpe8v4W.s:133    .text.read_if_checksum_mismatch:0000000000000000 read_if_checksum_mismatch
     /tmp/ccpe8v4W.s:359    .text.encoder_handlers_master:0000000000000000 encoder_handlers_master
     /tmp/ccpe8v4W.s:1174   .bss.last_update.4330:0000000000000000 last_update.4330
     /tmp/ccpe8v4W.s:456    .text.slave_matrix_handlers_master:0000000000000000 slave_matrix_handlers_master
     /tmp/ccpe8v4W.s:1169   .bss.last_update.4318:0000000000000000 last_update.4318
     /tmp/ccpe8v4W.s:1164   .bss.last_matrix.4319:0000000000000000 last_matrix.4319
     /tmp/ccpe8v4W.s:584    .text.transaction_handler_master.isra.3:0000000000000000 transaction_handler_master.isra.3
     /tmp/ccpe8v4W.s:801    .text.transactions_master:0000000000000000 transactions_master
     /tmp/ccpe8v4W.s:886    .text.transactions_slave:0000000000000000 transactions_slave
     /tmp/ccpe8v4W.s:1159   .bss.last_sync_timer.4351:0000000000000000 last_sync_timer.4351
     /tmp/ccpe8v4W.s:1185   .data.split_transaction_table:0000000000000000 split_transaction_table
                            *COM*:0000000000000001 dummy

UNDEFINED SYMBOLS
timer_elapsed32
sync_timer_read32
transport_execute_transaction
timer_read32
crc8
memcpy
split_shmem
encoder_update_raw
is_transport_connected
encoder_state_raw
sync_timer_update
__do_copy_data
__do_clear_bss
