   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.process_hand_swap,"ax",@progbits
  11               	.global	process_hand_swap
  13               	process_hand_swap:
  14               	.LVL0:
  15               	.LFB17:
  16               		.file 1 "quantum/action.c"
   1:quantum/action.c **** /*
   2:quantum/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:quantum/action.c **** 
   4:quantum/action.c **** This program is free software: you can redistribute it and/or modify
   5:quantum/action.c **** it under the terms of the GNU General Public License as published by
   6:quantum/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/action.c **** (at your option) any later version.
   8:quantum/action.c **** 
   9:quantum/action.c **** This program is distributed in the hope that it will be useful,
  10:quantum/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/action.c **** GNU General Public License for more details.
  13:quantum/action.c **** 
  14:quantum/action.c **** You should have received a copy of the GNU General Public License
  15:quantum/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/action.c **** */
  17:quantum/action.c **** #include "host.h"
  18:quantum/action.c **** #include "keycode.h"
  19:quantum/action.c **** #include "keyboard.h"
  20:quantum/action.c **** #include "mousekey.h"
  21:quantum/action.c **** #include "command.h"
  22:quantum/action.c **** #include "led.h"
  23:quantum/action.c **** #include "action_layer.h"
  24:quantum/action.c **** #include "action_tapping.h"
  25:quantum/action.c **** #include "action_macro.h"
  26:quantum/action.c **** #include "action_util.h"
  27:quantum/action.c **** #include "action.h"
  28:quantum/action.c **** #include "wait.h"
  29:quantum/action.c **** 
  30:quantum/action.c **** #ifdef BACKLIGHT_ENABLE
  31:quantum/action.c **** #    include "backlight.h"
  32:quantum/action.c **** #endif
  33:quantum/action.c **** 
  34:quantum/action.c **** #ifdef DEBUG_ACTION
  35:quantum/action.c **** #    include "debug.h"
  36:quantum/action.c **** #else
  37:quantum/action.c **** #    include "nodebug.h"
  38:quantum/action.c **** #endif
  39:quantum/action.c **** 
  40:quantum/action.c **** #ifdef POINTING_DEVICE_ENABLE
  41:quantum/action.c **** #    include "pointing_device.h"
  42:quantum/action.c **** #endif
  43:quantum/action.c **** 
  44:quantum/action.c **** int tp_buttons;
  45:quantum/action.c **** 
  46:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  47:quantum/action.c **** int retro_tapping_counter = 0;
  48:quantum/action.c **** #endif
  49:quantum/action.c **** 
  50:quantum/action.c **** #ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
  51:quantum/action.c **** __attribute__((weak)) bool get_ignore_mod_tap_interrupt(uint16_t keycode, keyrecord_t *record) { re
  52:quantum/action.c **** #endif
  53:quantum/action.c **** 
  54:quantum/action.c **** #ifdef RETRO_TAPPING_PER_KEY
  55:quantum/action.c **** __attribute__((weak)) bool get_retro_tapping(uint16_t keycode, keyrecord_t *record) { return false;
  56:quantum/action.c **** #endif
  57:quantum/action.c **** 
  58:quantum/action.c **** __attribute__((weak)) bool pre_process_record_quantum(keyrecord_t *record) { return true; }
  59:quantum/action.c **** 
  60:quantum/action.c **** /** \brief Called to execute an action.
  61:quantum/action.c ****  *
  62:quantum/action.c ****  * FIXME: Needs documentation.
  63:quantum/action.c ****  */
  64:quantum/action.c **** void action_exec(keyevent_t event) {
  65:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  66:quantum/action.c ****         dprint("\n---- action_exec: start -----\n");
  67:quantum/action.c ****         dprint("EVENT: ");
  68:quantum/action.c ****         debug_event(event);
  69:quantum/action.c ****         dprintln();
  70:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
  71:quantum/action.c ****         retro_tapping_counter++;
  72:quantum/action.c **** #endif
  73:quantum/action.c ****     }
  74:quantum/action.c **** 
  75:quantum/action.c ****     if (event.pressed) {
  76:quantum/action.c ****         // clear the potential weak mods left by previously pressed keys
  77:quantum/action.c ****         clear_weak_mods();
  78:quantum/action.c ****     }
  79:quantum/action.c **** 
  80:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
  81:quantum/action.c ****     if (!IS_NOEVENT(event)) {
  82:quantum/action.c ****         process_hand_swap(&event);
  83:quantum/action.c ****     }
  84:quantum/action.c **** #endif
  85:quantum/action.c **** 
  86:quantum/action.c ****     keyrecord_t record = {.event = event};
  87:quantum/action.c **** 
  88:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
  89:quantum/action.c **** #    if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  90:quantum/action.c ****     if (has_oneshot_layer_timed_out()) {
  91:quantum/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  92:quantum/action.c ****     }
  93:quantum/action.c ****     if (has_oneshot_mods_timed_out()) {
  94:quantum/action.c ****         clear_oneshot_mods();
  95:quantum/action.c ****     }
  96:quantum/action.c **** #        ifdef SWAP_HANDS_ENABLE
  97:quantum/action.c ****     if (has_oneshot_swaphands_timed_out()) {
  98:quantum/action.c ****         clear_oneshot_swaphands();
  99:quantum/action.c ****     }
 100:quantum/action.c **** #        endif
 101:quantum/action.c **** #    endif
 102:quantum/action.c **** #endif
 103:quantum/action.c **** 
 104:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 105:quantum/action.c ****     if (IS_NOEVENT(record.event) || pre_process_record_quantum(&record)) {
 106:quantum/action.c ****         action_tapping_process(record);
 107:quantum/action.c ****     }
 108:quantum/action.c **** #else
 109:quantum/action.c ****     if (IS_NOEVENT(record.event) || pre_process_record_quantum(&record)) {
 110:quantum/action.c ****         process_record(&record);
 111:quantum/action.c ****     }
 112:quantum/action.c ****     if (!IS_NOEVENT(record.event)) {
 113:quantum/action.c ****         dprint("processed: ");
 114:quantum/action.c ****         debug_record(record);
 115:quantum/action.c ****         dprintln();
 116:quantum/action.c ****     }
 117:quantum/action.c **** #endif
 118:quantum/action.c **** }
 119:quantum/action.c **** 
 120:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 121:quantum/action.c **** bool swap_hands = false;
 122:quantum/action.c **** bool swap_held  = false;
 123:quantum/action.c **** 
 124:quantum/action.c **** /** \brief Process Hand Swap
 125:quantum/action.c ****  *
 126:quantum/action.c ****  * FIXME: Needs documentation.
 127:quantum/action.c ****  */
 128:quantum/action.c **** void process_hand_swap(keyevent_t *event) {
  17               		.loc 1 128 43 view -0
  18               		.cfi_startproc
  19               		.loc 1 128 43 is_stmt 0 view .LVU1
  20 0000 CF93      		push r28
  21               	.LCFI0:
  22               		.cfi_def_cfa_offset 3
  23               		.cfi_offset 28, -2
  24 0002 DF93      		push r29
  25               	.LCFI1:
  26               		.cfi_def_cfa_offset 4
  27               		.cfi_offset 29, -3
  28               	/* prologue: function */
  29               	/* frame size = 0 */
  30               	/* stack size = 2 */
  31               	.L__stack_usage = 2
  32 0004 EC01      		movw r28,r24
 129:quantum/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
  33               		.loc 1 129 5 is_stmt 1 view .LVU2
 130:quantum/action.c **** 
 131:quantum/action.c ****     keypos_t         pos     = event->key;
  34               		.loc 1 131 5 view .LVU3
  35               		.loc 1 131 22 is_stmt 0 view .LVU4
  36 0006 2881      		ld r18,Y
  37               	.LVL1:
  38               		.loc 1 131 22 view .LVU5
  39 0008 8981      		ldd r24,Y+1
  40               	.LVL2:
 132:quantum/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1 << pos.col;
  41               		.loc 1 132 5 is_stmt 1 view .LVU6
  42               		.loc 1 132 52 is_stmt 0 view .LVU7
  43 000a 41E0      		ldi r20,lo8(1)
  44 000c 50E0      		ldi r21,0
  45 000e 022E      		mov r0,r18
  46 0010 00C0      		rjmp 2f
  47               		1:
  48 0012 440F      		lsl r20
  49               		2:
  50 0014 0A94      		dec r0
  51 0016 02F4      		brpl 1b
  52               	.LVL3:
 133:quantum/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
  53               		.loc 1 133 5 is_stmt 1 view .LVU8
  54 0018 A82F      		mov r26,r24
  55 001a B0E0      		ldi r27,0
  56 001c A050      		subi r26,lo8(-(swap_state.2819))
  57 001e B040      		sbci r27,hi8(-(swap_state.2819))
  58 0020 9C91      		ld r25,X
  59               		.loc 1 133 60 is_stmt 0 view .LVU9
  60 0022 3A81      		ldd r19,Y+2
  61 0024 3323      		tst r19
  62 0026 01F0      		breq .L2
  63               		.loc 1 133 60 discriminator 1 view .LVU10
  64 0028 3091 0000 		lds r19,swap_hands
  65               	.LVL4:
 134:quantum/action.c **** 
 135:quantum/action.c ****     if (do_swap) {
  66               		.loc 1 135 5 is_stmt 1 discriminator 1 view .LVU11
  67               	.L11:
 133:quantum/action.c ****     bool             do_swap = event->pressed ? swap_hands : swap_state[pos.row] & (col_bit);
  68               		.loc 1 133 60 is_stmt 0 discriminator 2 view .LVU12
  69 002c 3323      		tst r19
  70 002e 01F0      		breq .L5
 136:quantum/action.c ****         event->key.row = pgm_read_byte(&hand_swap_config[pos.row][pos.col].row);
  71               		.loc 1 136 9 is_stmt 1 view .LVU13
  72               	.LBB19:
  73               		.loc 1 136 26 view .LVU14
  74 0030 30E0      		ldi r19,0
  75 0032 66E0      		ldi r22,lo8(6)
  76 0034 869F      		mul r24,r22
  77 0036 200D      		add r18,r0
  78 0038 311D      		adc r19,r1
  79 003a 1124      		clr __zero_reg__
  80               	.LVL5:
  81               		.loc 1 136 26 is_stmt 0 view .LVU15
  82 003c 220F      		lsl r18
  83 003e 331F      		rol r19
  84               	.LVL6:
  85               		.loc 1 136 26 is_stmt 1 view .LVU16
  86               		.loc 1 136 26 view .LVU17
  87 0040 F901      		movw r30,r18
  88 0042 E050      		subi r30,lo8(-(hand_swap_config+1))
  89 0044 F040      		sbci r31,hi8(-(hand_swap_config+1))
  90               	.LVL7:
  91               		.loc 1 136 26 is_stmt 0 view .LVU18
  92               	/* #APP */
  93               	 ;  136 "quantum/action.c" 1
  94 0046 E491      		lpm r30, Z
  95               		
  96               	 ;  0 "" 2
  97               	.LVL8:
  98               		.loc 1 136 26 is_stmt 1 view .LVU19
  99               	/* #NOAPP */
 100               	.LBE19:
 101               		.loc 1 136 24 is_stmt 0 view .LVU20
 102 0048 E983      		std Y+1,r30
 103               	.LVL9:
 137:quantum/action.c ****         event->key.col = pgm_read_byte(&hand_swap_config[pos.row][pos.col].col);
 104               		.loc 1 137 9 is_stmt 1 view .LVU21
 105               	.LBB20:
 106               		.loc 1 137 26 view .LVU22
 107               		.loc 1 137 26 view .LVU23
 108               		.loc 1 137 26 view .LVU24
 109 004a F901      		movw r30,r18
 110               	.LVL10:
 111               		.loc 1 137 26 is_stmt 0 view .LVU25
 112 004c E050      		subi r30,lo8(-(hand_swap_config))
 113 004e F040      		sbci r31,hi8(-(hand_swap_config))
 114               	.LVL11:
 115               		.loc 1 137 26 view .LVU26
 116               	/* #APP */
 117               	 ;  137 "quantum/action.c" 1
 118 0050 E491      		lpm r30, Z
 119               		
 120               	 ;  0 "" 2
 121               	.LVL12:
 122               		.loc 1 137 26 is_stmt 1 view .LVU27
 123               	/* #NOAPP */
 124               	.LBE20:
 125               		.loc 1 137 24 is_stmt 0 view .LVU28
 126 0052 E883      		st Y,r30
 127               	.LVL13:
 138:quantum/action.c ****         swap_state[pos.row] |= col_bit;
 128               		.loc 1 138 9 is_stmt 1 view .LVU29
 129               		.loc 1 138 29 is_stmt 0 view .LVU30
 130 0054 492B      		or r20,r25
 131               	.LVL14:
 132               	.L12:
 139:quantum/action.c ****     } else {
 140:quantum/action.c ****         swap_state[pos.row] &= ~(col_bit);
 133               		.loc 1 140 29 view .LVU31
 134 0056 4C93      		st X,r20
 135               	/* epilogue start */
 141:quantum/action.c ****     }
 142:quantum/action.c **** }
 136               		.loc 1 142 1 view .LVU32
 137 0058 DF91      		pop r29
 138 005a CF91      		pop r28
 139               	.LVL15:
 140               		.loc 1 142 1 view .LVU33
 141 005c 0895      		ret
 142               	.LVL16:
 143               	.L2:
 133:quantum/action.c **** 
 144               		.loc 1 133 60 discriminator 2 view .LVU34
 145 005e 392F      		mov r19,r25
 146 0060 3423      		and r19,r20
 147 0062 00C0      		rjmp .L11
 148               	.L5:
 140:quantum/action.c ****     }
 149               		.loc 1 140 9 is_stmt 1 view .LVU35
 140:quantum/action.c ****     }
 150               		.loc 1 140 29 is_stmt 0 view .LVU36
 151 0064 4095      		com r20
 152               	.LVL17:
 140:quantum/action.c ****     }
 153               		.loc 1 140 29 view .LVU37
 154 0066 4923      		and r20,r25
 155 0068 00C0      		rjmp .L12
 156               		.cfi_endproc
 157               	.LFE17:
 159               		.section	.text.process_record_quantum,"ax",@progbits
 160               		.weak	process_record_quantum
 162               	process_record_quantum:
 163               	.LVL18:
 164               	.LFB19:
 143:quantum/action.c **** #endif
 144:quantum/action.c **** 
 145:quantum/action.c **** #if !defined(NO_ACTION_LAYER) && !defined(STRICT_LAYER_RELEASE)
 146:quantum/action.c **** bool disable_action_cache = false;
 147:quantum/action.c **** 
 148:quantum/action.c **** void process_record_nocache(keyrecord_t *record) {
 149:quantum/action.c ****     disable_action_cache = true;
 150:quantum/action.c ****     process_record(record);
 151:quantum/action.c ****     disable_action_cache = false;
 152:quantum/action.c **** }
 153:quantum/action.c **** #else
 154:quantum/action.c **** void process_record_nocache(keyrecord_t *record) { process_record(record); }
 155:quantum/action.c **** #endif
 156:quantum/action.c **** 
 157:quantum/action.c **** __attribute__((weak)) bool process_record_quantum(keyrecord_t *record) { return true; }
 165               		.loc 1 157 72 is_stmt 1 view -0
 166               		.cfi_startproc
 167               	/* prologue: function */
 168               	/* frame size = 0 */
 169               	/* stack size = 0 */
 170               	.L__stack_usage = 0
 171               		.loc 1 157 74 view .LVU39
 172               		.loc 1 157 1 is_stmt 0 view .LVU40
 173 0000 81E0      		ldi r24,lo8(1)
 174               	.LVL19:
 175               	/* epilogue start */
 176               		.loc 1 157 1 view .LVU41
 177 0002 0895      		ret
 178               		.cfi_endproc
 179               	.LFE19:
 181               		.set	process_record_quantum.localalias.1,process_record_quantum
 182               		.section	.text.pre_process_record_quantum,"ax",@progbits
 183               		.weak	pre_process_record_quantum
 185               	pre_process_record_quantum:
 186               	.LFB44:
 187               		.cfi_startproc
 188               	/* prologue: function */
 189               	/* frame size = 0 */
 190               	/* stack size = 0 */
 191               	.L__stack_usage = 0
 192 0000 0C94 0000 		jmp process_record_quantum.localalias.1
 193               		.cfi_endproc
 194               	.LFE44:
 196               		.section	.text.action_exec,"ax",@progbits
 197               	.global	action_exec
 199               	action_exec:
 200               	.LFB16:
  64:quantum/action.c ****     if (!IS_NOEVENT(event)) {
 201               		.loc 1 64 36 is_stmt 1 view -0
 202               		.cfi_startproc
  64:quantum/action.c ****     if (!IS_NOEVENT(event)) {
 203               		.loc 1 64 36 is_stmt 0 view .LVU43
 204 0000 CF93      		push r28
 205               	.LCFI2:
 206               		.cfi_def_cfa_offset 3
 207               		.cfi_offset 28, -2
 208 0002 DF93      		push r29
 209               	.LCFI3:
 210               		.cfi_def_cfa_offset 4
 211               		.cfi_offset 29, -3
 212 0004 CDB7      		in r28,__SP_L__
 213 0006 DEB7      		in r29,__SP_H__
 214               	.LCFI4:
 215               		.cfi_def_cfa_register 28
 216 0008 2B97      		sbiw r28,11
 217               	.LCFI5:
 218               		.cfi_def_cfa_offset 15
 219 000a 0FB6      		in __tmp_reg__,__SREG__
 220 000c F894      		cli
 221 000e DEBF      		out __SP_H__,r29
 222 0010 0FBE      		out __SREG__,__tmp_reg__
 223 0012 CDBF      		out __SP_L__,r28
 224               	/* prologue: function */
 225               	/* frame size = 11 */
 226               	/* stack size = 13 */
 227               	.L__stack_usage = 13
 228 0014 4F83      		std Y+7,r20
 229 0016 5887      		std Y+8,r21
 230 0018 6987      		std Y+9,r22
 231 001a 7A87      		std Y+10,r23
 232 001c 8B87      		std Y+11,r24
  65:quantum/action.c ****         dprint("\n---- action_exec: start -----\n");
 233               		.loc 1 65 5 is_stmt 1 view .LVU44
  69:quantum/action.c **** #if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 234               		.loc 1 69 19 view .LVU45
  75:quantum/action.c ****         // clear the potential weak mods left by previously pressed keys
 235               		.loc 1 75 5 view .LVU46
  75:quantum/action.c ****         // clear the potential weak mods left by previously pressed keys
 236               		.loc 1 75 8 is_stmt 0 view .LVU47
 237 001e 6111      		cpse r22,__zero_reg__
  77:quantum/action.c ****     }
 238               		.loc 1 77 9 is_stmt 1 view .LVU48
 239 0020 0E94 0000 		call clear_weak_mods
 240               	.LVL20:
 241               	.L16:
  81:quantum/action.c ****         process_hand_swap(&event);
 242               		.loc 1 81 5 view .LVU49
 243               	.LBB25:
 244               	.LBI25:
 245               		.file 2 "quantum/keyboard.h"
   1:quantum/keyboard.h **** /*
   2:quantum/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:quantum/keyboard.h **** 
   4:quantum/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:quantum/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:quantum/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:quantum/keyboard.h **** (at your option) any later version.
   8:quantum/keyboard.h **** 
   9:quantum/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:quantum/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:quantum/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:quantum/keyboard.h **** GNU General Public License for more details.
  13:quantum/keyboard.h **** 
  14:quantum/keyboard.h **** You should have received a copy of the GNU General Public License
  15:quantum/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:quantum/keyboard.h **** */
  17:quantum/keyboard.h **** 
  18:quantum/keyboard.h **** #pragma once
  19:quantum/keyboard.h **** 
  20:quantum/keyboard.h **** #include <stdbool.h>
  21:quantum/keyboard.h **** #include <stdint.h>
  22:quantum/keyboard.h **** 
  23:quantum/keyboard.h **** #ifdef __cplusplus
  24:quantum/keyboard.h **** extern "C" {
  25:quantum/keyboard.h **** #endif
  26:quantum/keyboard.h **** 
  27:quantum/keyboard.h **** /* key matrix position */
  28:quantum/keyboard.h **** typedef struct {
  29:quantum/keyboard.h ****     uint8_t col;
  30:quantum/keyboard.h ****     uint8_t row;
  31:quantum/keyboard.h **** } keypos_t;
  32:quantum/keyboard.h **** 
  33:quantum/keyboard.h **** /* key event */
  34:quantum/keyboard.h **** typedef struct {
  35:quantum/keyboard.h ****     keypos_t key;
  36:quantum/keyboard.h ****     bool     pressed;
  37:quantum/keyboard.h ****     uint16_t time;
  38:quantum/keyboard.h **** } keyevent_t;
  39:quantum/keyboard.h **** 
  40:quantum/keyboard.h **** /* equivalent test of keypos_t */
  41:quantum/keyboard.h **** #define KEYEQ(keya, keyb) ((keya).row == (keyb).row && (keya).col == (keyb).col)
  42:quantum/keyboard.h **** 
  43:quantum/keyboard.h **** /* Rules for No Event:
  44:quantum/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  45:quantum/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  46:quantum/keyboard.h ****  */
  47:quantum/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 246               		.loc 2 47 20 view .LVU50
 247               	.LBB26:
 248               		.loc 2 47 51 view .LVU51
 249               		.loc 2 47 74 is_stmt 0 view .LVU52
 250 0024 8A85      		ldd r24,Y+10
 251 0026 9B85      		ldd r25,Y+11
 252 0028 892B      		or r24,r25
 253 002a 01F0      		breq .L17
 254 002c 8F81      		ldd r24,Y+7
 255 002e 9885      		ldd r25,Y+8
 256 0030 8923      		and r24,r25
 257 0032 8F3F      		cpi r24,lo8(-1)
 258 0034 01F4      		brne .L18
 259               	.L17:
 260               	.LBE26:
 261               	.LBE25:
  86:quantum/action.c **** 
 262               		.loc 1 86 5 is_stmt 1 view .LVU53
  86:quantum/action.c **** 
 263               		.loc 1 86 17 is_stmt 0 view .LVU54
 264 0036 1E82      		std Y+6,__zero_reg__
 265 0038 1D82      		std Y+5,__zero_reg__
 266 003a 85E0      		ldi r24,lo8(5)
 267 003c FE01      		movw r30,r28
 268 003e 3796      		adiw r30,7
 269 0040 DE01      		movw r26,r28
 270 0042 1196      		adiw r26,1
 271               		0:
 272 0044 0190      		ld r0,Z+
 273 0046 0D92      		st X+,r0
 274 0048 8A95      		dec r24
 275 004a 01F4      		brne 0b
 105:quantum/action.c ****         action_tapping_process(record);
 276               		.loc 1 105 5 is_stmt 1 view .LVU55
 277               	.LBB27:
 278               	.LBI27:
 279               		.loc 2 47 20 view .LVU56
 280               	.LBB28:
 281               		.loc 2 47 51 view .LVU57
 282               		.loc 2 47 74 is_stmt 0 view .LVU58
 283 004c 8C81      		ldd r24,Y+4
 284 004e 9D81      		ldd r25,Y+5
 285 0050 892B      		or r24,r25
 286 0052 01F4      		brne .L19
 287               	.L21:
 288               	.LBE28:
 289               	.LBE27:
 106:quantum/action.c ****     }
 290               		.loc 1 106 9 is_stmt 1 view .LVU59
 291 0054 4981      		ldd r20,Y+1
 292 0056 5A81      		ldd r21,Y+2
 293 0058 6B81      		ldd r22,Y+3
 294 005a 7C81      		ldd r23,Y+4
 295 005c 8D81      		ldd r24,Y+5
 296 005e 9E81      		ldd r25,Y+6
 297 0060 0E94 0000 		call action_tapping_process
 298               	.LVL21:
 299               	.L15:
 300               	/* epilogue start */
 118:quantum/action.c **** 
 301               		.loc 1 118 1 is_stmt 0 view .LVU60
 302 0064 2B96      		adiw r28,11
 303 0066 0FB6      		in __tmp_reg__,__SREG__
 304 0068 F894      		cli
 305 006a DEBF      		out __SP_H__,r29
 306 006c 0FBE      		out __SREG__,__tmp_reg__
 307 006e CDBF      		out __SP_L__,r28
 308 0070 DF91      		pop r29
 309 0072 CF91      		pop r28
 310 0074 0895      		ret
 311               	.L19:
 312               	.LBB30:
 313               	.LBB29:
 314               		.loc 2 47 74 view .LVU61
 315 0076 8981      		ldd r24,Y+1
 316 0078 9A81      		ldd r25,Y+2
 317 007a 8923      		and r24,r25
 318 007c 8F3F      		cpi r24,lo8(-1)
 319 007e 01F0      		breq .L21
 320               	.LBE29:
 321               	.LBE30:
 105:quantum/action.c ****         action_tapping_process(record);
 322               		.loc 1 105 37 view .LVU62
 323 0080 CE01      		movw r24,r28
 324 0082 0196      		adiw r24,1
 325 0084 0E94 0000 		call pre_process_record_quantum
 326               	.LVL22:
 105:quantum/action.c ****         action_tapping_process(record);
 327               		.loc 1 105 34 view .LVU63
 328 0088 8111      		cpse r24,__zero_reg__
 329 008a 00C0      		rjmp .L21
 330 008c 00C0      		rjmp .L15
 331               	.L18:
  82:quantum/action.c ****     }
 332               		.loc 1 82 9 is_stmt 1 view .LVU64
 333 008e CE01      		movw r24,r28
 334 0090 0796      		adiw r24,7
 335 0092 0E94 0000 		call process_hand_swap
 336               	.LVL23:
 337 0096 00C0      		rjmp .L17
 338               		.cfi_endproc
 339               	.LFE16:
 341               		.section	.text.post_process_record_quantum,"ax",@progbits
 342               		.weak	post_process_record_quantum
 344               	post_process_record_quantum:
 345               	.LVL24:
 346               	.LFB20:
 158:quantum/action.c **** 
 159:quantum/action.c **** __attribute__((weak)) void post_process_record_quantum(keyrecord_t *record) {}
 347               		.loc 1 159 77 view -0
 348               		.cfi_startproc
 349               	/* prologue: function */
 350               	/* frame size = 0 */
 351               	/* stack size = 0 */
 352               	.L__stack_usage = 0
 353               		.loc 1 159 78 view .LVU66
 354               	/* epilogue start */
 355               		.loc 1 159 1 is_stmt 0 view .LVU67
 356 0000 0895      		ret
 357               		.cfi_endproc
 358               	.LFE20:
 360               		.section	.text.process_record_tap_hint,"ax",@progbits
 361               	.global	process_record_tap_hint
 363               	process_record_tap_hint:
 364               	.LVL25:
 365               	.LFB21:
 160:quantum/action.c **** 
 161:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 162:quantum/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 163:quantum/action.c ****  *
 164:quantum/action.c ****  * FIXME: Needs documentation.
 165:quantum/action.c ****  */
 166:quantum/action.c **** void process_record_tap_hint(keyrecord_t *record) {
 366               		.loc 1 166 51 is_stmt 1 view -0
 367               		.cfi_startproc
 368               	/* prologue: function */
 369               	/* frame size = 0 */
 370               	/* stack size = 0 */
 371               	.L__stack_usage = 0
 167:quantum/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 372               		.loc 1 167 5 view .LVU69
 373               		.loc 1 167 23 is_stmt 0 view .LVU70
 374 0000 FC01      		movw r30,r24
 375 0002 8081      		ld r24,Z
 376 0004 9181      		ldd r25,Z+1
 377               	.LVL26:
 378               		.loc 1 167 23 view .LVU71
 379 0006 0E94 0000 		call layer_switch_get_action
 380               	.LVL27:
 168:quantum/action.c **** 
 169:quantum/action.c ****     switch (action.kind.id) {
 381               		.loc 1 169 5 is_stmt 1 view .LVU72
 382               		.loc 1 169 24 is_stmt 0 view .LVU73
 383 000a 9295      		swap r25
 384 000c 9F70      		andi r25,lo8(15)
 385               		.loc 1 169 5 view .LVU74
 386 000e 9630      		cpi r25,lo8(6)
 387 0010 01F4      		brne .L33
 170:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 171:quantum/action.c ****         case ACT_SWAP_HANDS:
 172:quantum/action.c ****             switch (action.swap.code) {
 388               		.loc 1 172 13 is_stmt 1 view .LVU75
 389               	.LVL28:
 390               		.loc 1 172 13 is_stmt 0 view .LVU76
 391 0012 863F      		cpi r24,lo8(-10)
 392 0014 01F0      		breq .L33
 173:quantum/action.c ****                 case OP_SH_ONESHOT:
 174:quantum/action.c ****                     break;
 175:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
 176:quantum/action.c ****                 default:
 177:quantum/action.c ****                     swap_hands = !swap_hands;
 393               		.loc 1 177 21 is_stmt 1 view .LVU77
 394 0016 8091 0000 		lds r24,swap_hands
 395               		.loc 1 177 21 is_stmt 0 view .LVU78
 396 001a 91E0      		ldi r25,lo8(1)
 397 001c 8927      		eor r24,r25
 398               		.loc 1 177 32 view .LVU79
 399 001e 8093 0000 		sts swap_hands,r24
 178:quantum/action.c ****                     swap_held  = true;
 400               		.loc 1 178 21 is_stmt 1 view .LVU80
 401               		.loc 1 178 32 is_stmt 0 view .LVU81
 402 0022 9093 0000 		sts swap_held,r25
 403               	.L33:
 404               	/* epilogue start */
 179:quantum/action.c ****             }
 180:quantum/action.c ****             break;
 181:quantum/action.c **** #    endif
 182:quantum/action.c ****     }
 183:quantum/action.c **** }
 405               		.loc 1 183 1 view .LVU82
 406 0026 0895      		ret
 407               		.cfi_endproc
 408               	.LFE21:
 410               		.section	.text.register_code,"ax",@progbits
 411               	.global	register_code
 413               	register_code:
 414               	.LVL29:
 415               	.LFB25:
 184:quantum/action.c **** #endif
 185:quantum/action.c **** 
 186:quantum/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 187:quantum/action.c ****  *
 188:quantum/action.c ****  * FIXME: Needs documentation.
 189:quantum/action.c ****  */
 190:quantum/action.c **** void process_record(keyrecord_t *record) {
 191:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 192:quantum/action.c ****         return;
 193:quantum/action.c ****     }
 194:quantum/action.c **** 
 195:quantum/action.c ****     if (!process_record_quantum(record)) {
 196:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 197:quantum/action.c ****         if (is_oneshot_layer_active() && record->event.pressed) {
 198:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 199:quantum/action.c ****         }
 200:quantum/action.c **** #endif
 201:quantum/action.c ****         return;
 202:quantum/action.c ****     }
 203:quantum/action.c **** 
 204:quantum/action.c ****     process_record_handler(record);
 205:quantum/action.c ****     post_process_record_quantum(record);
 206:quantum/action.c **** }
 207:quantum/action.c **** 
 208:quantum/action.c **** void process_record_handler(keyrecord_t *record) {
 209:quantum/action.c **** #ifdef COMBO_ENABLE
 210:quantum/action.c ****     action_t action;
 211:quantum/action.c ****     if (record->keycode) {
 212:quantum/action.c ****         action = action_for_keycode(record->keycode);
 213:quantum/action.c ****     } else {
 214:quantum/action.c ****         action = store_or_get_action(record->event.pressed, record->event.key);
 215:quantum/action.c ****     }
 216:quantum/action.c **** #else
 217:quantum/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 218:quantum/action.c **** #endif
 219:quantum/action.c ****     dprint("ACTION: ");
 220:quantum/action.c ****     debug_action(action);
 221:quantum/action.c **** #ifndef NO_ACTION_LAYER
 222:quantum/action.c ****     dprint(" layer_state: ");
 223:quantum/action.c ****     layer_debug();
 224:quantum/action.c ****     dprint(" default_layer_state: ");
 225:quantum/action.c ****     default_layer_debug();
 226:quantum/action.c **** #endif
 227:quantum/action.c ****     dprintln();
 228:quantum/action.c **** 
 229:quantum/action.c ****     process_action(record, action);
 230:quantum/action.c **** }
 231:quantum/action.c **** 
 232:quantum/action.c **** #if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 233:quantum/action.c **** void register_button(bool pressed, enum mouse_buttons button) {
 234:quantum/action.c **** #    ifdef PS2_MOUSE_ENABLE
 235:quantum/action.c ****     tp_buttons = pressed ? tp_buttons | button : tp_buttons & ~button;
 236:quantum/action.c **** #    endif
 237:quantum/action.c **** #    ifdef POINTING_DEVICE_ENABLE
 238:quantum/action.c ****     report_mouse_t currentReport = pointing_device_get_report();
 239:quantum/action.c ****     currentReport.buttons        = pressed ? currentReport.buttons | button : currentReport.buttons
 240:quantum/action.c ****     pointing_device_set_report(currentReport);
 241:quantum/action.c **** #    endif
 242:quantum/action.c **** }
 243:quantum/action.c **** #endif
 244:quantum/action.c **** 
 245:quantum/action.c **** /** \brief Take an action and processes it.
 246:quantum/action.c ****  *
 247:quantum/action.c ****  * FIXME: Needs documentation.
 248:quantum/action.c ****  */
 249:quantum/action.c **** void process_action(keyrecord_t *record, action_t action) {
 250:quantum/action.c ****     keyevent_t event = record->event;
 251:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 252:quantum/action.c ****     uint8_t tap_count = record->tap.count;
 253:quantum/action.c **** #endif
 254:quantum/action.c **** 
 255:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 256:quantum/action.c ****     bool do_release_oneshot = false;
 257:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 258:quantum/action.c ****     if (is_oneshot_layer_active() && event.pressed && (action.kind.id == ACT_USAGE || !IS_MOD(actio
 259:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 260:quantum/action.c ****         && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)
 261:quantum/action.c **** #    endif
 262:quantum/action.c ****     ) {
 263:quantum/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 264:quantum/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 265:quantum/action.c ****     }
 266:quantum/action.c **** #endif
 267:quantum/action.c **** 
 268:quantum/action.c ****     switch (action.kind.id) {
 269:quantum/action.c ****         /* Key and Mods */
 270:quantum/action.c ****         case ACT_LMODS:
 271:quantum/action.c ****         case ACT_RMODS: {
 272:quantum/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS) ? action.key.mods : action.key.mods << 4;
 273:quantum/action.c ****             if (event.pressed) {
 274:quantum/action.c ****                 if (mods) {
 275:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 276:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 277:quantum/action.c ****                         // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSFT).
 278:quantum/action.c ****                         // Same applies for some keys like KC_MEH which are declared as MEH(KC_NO).
 279:quantum/action.c ****                         add_mods(mods);
 280:quantum/action.c ****                     } else {
 281:quantum/action.c ****                         add_weak_mods(mods);
 282:quantum/action.c ****                     }
 283:quantum/action.c ****                     send_keyboard_report();
 284:quantum/action.c ****                 }
 285:quantum/action.c ****                 register_code(action.key.code);
 286:quantum/action.c ****             } else {
 287:quantum/action.c ****                 unregister_code(action.key.code);
 288:quantum/action.c ****                 if (mods) {
 289:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 290:quantum/action.c ****                         del_mods(mods);
 291:quantum/action.c ****                     } else {
 292:quantum/action.c ****                         del_weak_mods(mods);
 293:quantum/action.c ****                     }
 294:quantum/action.c ****                     send_keyboard_report();
 295:quantum/action.c ****                 }
 296:quantum/action.c ****             }
 297:quantum/action.c ****         } break;
 298:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 299:quantum/action.c ****         case ACT_LMODS_TAP:
 300:quantum/action.c ****         case ACT_RMODS_TAP: {
 301:quantum/action.c ****             uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ? action.key.mods : action.key.mods <<
 302:quantum/action.c ****             switch (action.layer_tap.code) {
 303:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 304:quantum/action.c ****                 case MODS_ONESHOT:
 305:quantum/action.c ****                     // Oneshot modifier
 306:quantum/action.c ****                     if (event.pressed) {
 307:quantum/action.c ****                         if (tap_count == 0) {
 308:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 309:quantum/action.c ****                             register_mods(mods | get_oneshot_mods());
 310:quantum/action.c ****                         } else if (tap_count == 1) {
 311:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 312:quantum/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 313:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 314:quantum/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 315:quantum/action.c ****                             dprint("MODS_TAP: Toggling oneshot");
 316:quantum/action.c ****                             clear_oneshot_mods();
 317:quantum/action.c ****                             set_oneshot_locked_mods(mods);
 318:quantum/action.c ****                             register_mods(mods);
 319:quantum/action.c **** #        endif
 320:quantum/action.c ****                         } else {
 321:quantum/action.c ****                             register_mods(mods | get_oneshot_mods());
 322:quantum/action.c ****                         }
 323:quantum/action.c ****                     } else {
 324:quantum/action.c ****                         if (tap_count == 0) {
 325:quantum/action.c ****                             clear_oneshot_mods();
 326:quantum/action.c ****                             unregister_mods(mods);
 327:quantum/action.c ****                         } else if (tap_count == 1) {
 328:quantum/action.c ****                             // Retain Oneshot mods
 329:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 330:quantum/action.c ****                             if (mods & get_mods()) {
 331:quantum/action.c ****                                 clear_oneshot_locked_mods();
 332:quantum/action.c ****                                 clear_oneshot_mods();
 333:quantum/action.c ****                                 unregister_mods(mods);
 334:quantum/action.c ****                             }
 335:quantum/action.c ****                         } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 336:quantum/action.c ****                             // Toggle Oneshot Layer
 337:quantum/action.c **** #        endif
 338:quantum/action.c ****                         } else {
 339:quantum/action.c ****                             clear_oneshot_mods();
 340:quantum/action.c ****                             unregister_mods(mods);
 341:quantum/action.c ****                         }
 342:quantum/action.c ****                     }
 343:quantum/action.c ****                     break;
 344:quantum/action.c **** #    endif
 345:quantum/action.c ****                 case MODS_TAP_TOGGLE:
 346:quantum/action.c ****                     if (event.pressed) {
 347:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 348:quantum/action.c ****                             register_mods(mods);
 349:quantum/action.c ****                         }
 350:quantum/action.c ****                     } else {
 351:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 352:quantum/action.c ****                             unregister_mods(mods);
 353:quantum/action.c ****                         }
 354:quantum/action.c ****                     }
 355:quantum/action.c ****                     break;
 356:quantum/action.c ****                 default:
 357:quantum/action.c ****                     if (event.pressed) {
 358:quantum/action.c ****                         if (tap_count > 0) {
 359:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 360:quantum/action.c ****                             if (
 361:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 362:quantum/action.c ****                                 !get_ignore_mod_tap_interrupt(get_event_keycode(record->event, fals
 363:quantum/action.c **** #        endif
 364:quantum/action.c ****                                 record->tap.interrupted) {
 365:quantum/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 366:quantum/action.c ****                                 // ad hoc: set 0 to cancel tap
 367:quantum/action.c ****                                 record->tap.count = 0;
 368:quantum/action.c ****                                 register_mods(mods);
 369:quantum/action.c ****                             } else
 370:quantum/action.c **** #    endif
 371:quantum/action.c ****                             {
 372:quantum/action.c ****                                 dprint("MODS_TAP: Tap: register_code\n");
 373:quantum/action.c ****                                 register_code(action.key.code);
 374:quantum/action.c ****                             }
 375:quantum/action.c ****                         } else {
 376:quantum/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 377:quantum/action.c ****                             register_mods(mods);
 378:quantum/action.c ****                         }
 379:quantum/action.c ****                     } else {
 380:quantum/action.c ****                         if (tap_count > 0) {
 381:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 382:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 383:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 384:quantum/action.c ****                             } else {
 385:quantum/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 386:quantum/action.c ****                             }
 387:quantum/action.c ****                             unregister_code(action.key.code);
 388:quantum/action.c ****                         } else {
 389:quantum/action.c ****                             dprint("MODS_TAP: No tap: add_mods\n");
 390:quantum/action.c ****                             unregister_mods(mods);
 391:quantum/action.c ****                         }
 392:quantum/action.c ****                     }
 393:quantum/action.c ****                     break;
 394:quantum/action.c ****             }
 395:quantum/action.c ****         } break;
 396:quantum/action.c **** #endif
 397:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 398:quantum/action.c ****         /* other HID usage */
 399:quantum/action.c ****         case ACT_USAGE:
 400:quantum/action.c ****             switch (action.usage.page) {
 401:quantum/action.c ****                 case PAGE_SYSTEM:
 402:quantum/action.c ****                     if (event.pressed) {
 403:quantum/action.c ****                         host_system_send(action.usage.code);
 404:quantum/action.c ****                     } else {
 405:quantum/action.c ****                         host_system_send(0);
 406:quantum/action.c ****                     }
 407:quantum/action.c ****                     break;
 408:quantum/action.c ****                 case PAGE_CONSUMER:
 409:quantum/action.c ****                     if (event.pressed) {
 410:quantum/action.c ****                         host_consumer_send(action.usage.code);
 411:quantum/action.c ****                     } else {
 412:quantum/action.c ****                         host_consumer_send(0);
 413:quantum/action.c ****                     }
 414:quantum/action.c ****                     break;
 415:quantum/action.c ****             }
 416:quantum/action.c ****             break;
 417:quantum/action.c **** #endif
 418:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 419:quantum/action.c ****         /* Mouse key */
 420:quantum/action.c ****         case ACT_MOUSEKEY:
 421:quantum/action.c ****             if (event.pressed) {
 422:quantum/action.c ****                 mousekey_on(action.key.code);
 423:quantum/action.c ****             } else {
 424:quantum/action.c ****                 mousekey_off(action.key.code);
 425:quantum/action.c ****             }
 426:quantum/action.c ****             switch (action.key.code) {
 427:quantum/action.c **** #    if defined(PS2_MOUSE_ENABLE) || defined(POINTING_DEVICE_ENABLE)
 428:quantum/action.c **** #        ifdef POINTING_DEVICE_ENABLE
 429:quantum/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN8:
 430:quantum/action.c **** #        else
 431:quantum/action.c ****                 case KC_MS_BTN1 ... KC_MS_BTN3:
 432:quantum/action.c **** #        endif
 433:quantum/action.c ****                     register_button(event.pressed, MOUSE_BTN_MASK(action.key.code - KC_MS_BTN1));
 434:quantum/action.c ****                     break;
 435:quantum/action.c **** #    endif
 436:quantum/action.c ****                 default:
 437:quantum/action.c ****                     mousekey_send();
 438:quantum/action.c ****                     break;
 439:quantum/action.c ****             }
 440:quantum/action.c ****             break;
 441:quantum/action.c **** #endif
 442:quantum/action.c **** #ifndef NO_ACTION_LAYER
 443:quantum/action.c ****         case ACT_LAYER:
 444:quantum/action.c ****             if (action.layer_bitop.on == 0) {
 445:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 446:quantum/action.c ****                 if (!event.pressed) {
 447:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 448:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 449:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 450:quantum/action.c ****                     switch (action.layer_bitop.op) {
 451:quantum/action.c ****                         case OP_BIT_AND:
 452:quantum/action.c ****                             default_layer_and(bits | mask);
 453:quantum/action.c ****                             break;
 454:quantum/action.c ****                         case OP_BIT_OR:
 455:quantum/action.c ****                             default_layer_or(bits | mask);
 456:quantum/action.c ****                             break;
 457:quantum/action.c ****                         case OP_BIT_XOR:
 458:quantum/action.c ****                             default_layer_xor(bits | mask);
 459:quantum/action.c ****                             break;
 460:quantum/action.c ****                         case OP_BIT_SET:
 461:quantum/action.c ****                             default_layer_set(bits | mask);
 462:quantum/action.c ****                             break;
 463:quantum/action.c ****                     }
 464:quantum/action.c ****                 }
 465:quantum/action.c ****             } else {
 466:quantum/action.c ****                 /* Layer Bitwise Operation */
 467:quantum/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) : (action.layer_bitop.on & O
 468:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 469:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 470:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 471:quantum/action.c ****                     switch (action.layer_bitop.op) {
 472:quantum/action.c ****                         case OP_BIT_AND:
 473:quantum/action.c ****                             layer_and(bits | mask);
 474:quantum/action.c ****                             break;
 475:quantum/action.c ****                         case OP_BIT_OR:
 476:quantum/action.c ****                             layer_or(bits | mask);
 477:quantum/action.c ****                             break;
 478:quantum/action.c ****                         case OP_BIT_XOR:
 479:quantum/action.c ****                             layer_xor(bits | mask);
 480:quantum/action.c ****                             break;
 481:quantum/action.c ****                         case OP_BIT_SET:
 482:quantum/action.c ****                             layer_state_set(bits | mask);
 483:quantum/action.c ****                             break;
 484:quantum/action.c ****                     }
 485:quantum/action.c ****                 }
 486:quantum/action.c ****             }
 487:quantum/action.c ****             break;
 488:quantum/action.c ****         case ACT_LAYER_MODS:
 489:quantum/action.c ****             if (event.pressed) {
 490:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 491:quantum/action.c ****                 register_mods(action.layer_mods.mods);
 492:quantum/action.c ****             } else {
 493:quantum/action.c ****                 unregister_mods(action.layer_mods.mods);
 494:quantum/action.c ****                 layer_off(action.layer_mods.layer);
 495:quantum/action.c ****             }
 496:quantum/action.c ****             break;
 497:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 498:quantum/action.c ****         case ACT_LAYER_TAP:
 499:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
 500:quantum/action.c ****             switch (action.layer_tap.code) {
 501:quantum/action.c ****                 case OP_TAP_TOGGLE:
 502:quantum/action.c ****                     /* tap toggle */
 503:quantum/action.c ****                     if (event.pressed) {
 504:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 505:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 506:quantum/action.c ****                         }
 507:quantum/action.c ****                     } else {
 508:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 509:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 510:quantum/action.c ****                         }
 511:quantum/action.c ****                     }
 512:quantum/action.c ****                     break;
 513:quantum/action.c ****                 case OP_ON_OFF:
 514:quantum/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) : layer_off(action.layer_tap.val
 515:quantum/action.c ****                     break;
 516:quantum/action.c ****                 case OP_OFF_ON:
 517:quantum/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) : layer_on(action.layer_tap.val
 518:quantum/action.c ****                     break;
 519:quantum/action.c ****                 case OP_SET_CLEAR:
 520:quantum/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) : layer_clear();
 521:quantum/action.c ****                     break;
 522:quantum/action.c **** #        ifndef NO_ACTION_ONESHOT
 523:quantum/action.c ****                 case OP_ONESHOT:
 524:quantum/action.c ****                     // Oneshot modifier
 525:quantum/action.c **** #            if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 526:quantum/action.c ****                     do_release_oneshot = false;
 527:quantum/action.c ****                     if (event.pressed) {
 528:quantum/action.c ****                         del_mods(get_oneshot_locked_mods());
 529:quantum/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 530:quantum/action.c ****                             reset_oneshot_layer();
 531:quantum/action.c ****                             layer_off(action.layer_tap.val);
 532:quantum/action.c ****                             break;
 533:quantum/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 534:quantum/action.c ****                             layer_on(action.layer_tap.val);
 535:quantum/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 536:quantum/action.c ****                         }
 537:quantum/action.c ****                     } else {
 538:quantum/action.c ****                         add_mods(get_oneshot_locked_mods());
 539:quantum/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 540:quantum/action.c ****                             reset_oneshot_layer();
 541:quantum/action.c ****                             clear_oneshot_locked_mods();
 542:quantum/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 543:quantum/action.c ****                         } else {
 544:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 545:quantum/action.c ****                         }
 546:quantum/action.c ****                     }
 547:quantum/action.c **** #            else
 548:quantum/action.c ****                     if (event.pressed) {
 549:quantum/action.c ****                         layer_on(action.layer_tap.val);
 550:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 551:quantum/action.c ****                     } else {
 552:quantum/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 553:quantum/action.c ****                         if (tap_count > 1) {
 554:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 555:quantum/action.c ****                         }
 556:quantum/action.c ****                     }
 557:quantum/action.c **** #            endif
 558:quantum/action.c ****                     break;
 559:quantum/action.c **** #        endif
 560:quantum/action.c ****                 default:
 561:quantum/action.c ****                     /* tap key */
 562:quantum/action.c ****                     if (event.pressed) {
 563:quantum/action.c ****                         if (tap_count > 0) {
 564:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 565:quantum/action.c ****                             register_code(action.layer_tap.code);
 566:quantum/action.c ****                         } else {
 567:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 568:quantum/action.c ****                             layer_on(action.layer_tap.val);
 569:quantum/action.c ****                         }
 570:quantum/action.c ****                     } else {
 571:quantum/action.c ****                         if (tap_count > 0) {
 572:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 573:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 574:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 575:quantum/action.c ****                             } else {
 576:quantum/action.c ****                                 wait_ms(TAP_CODE_DELAY);
 577:quantum/action.c ****                             }
 578:quantum/action.c ****                             unregister_code(action.layer_tap.code);
 579:quantum/action.c ****                         } else {
 580:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 581:quantum/action.c ****                             layer_off(action.layer_tap.val);
 582:quantum/action.c ****                         }
 583:quantum/action.c ****                     }
 584:quantum/action.c ****                     break;
 585:quantum/action.c ****             }
 586:quantum/action.c ****             break;
 587:quantum/action.c **** #    endif
 588:quantum/action.c **** #endif
 589:quantum/action.c ****             /* Extentions */
 590:quantum/action.c **** #ifndef NO_ACTION_MACRO
 591:quantum/action.c ****         case ACT_MACRO:
 592:quantum/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 593:quantum/action.c ****             break;
 594:quantum/action.c **** #endif
 595:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 596:quantum/action.c ****         case ACT_SWAP_HANDS:
 597:quantum/action.c ****             switch (action.swap.code) {
 598:quantum/action.c ****                 case OP_SH_TOGGLE:
 599:quantum/action.c ****                     if (event.pressed) {
 600:quantum/action.c ****                         swap_hands = !swap_hands;
 601:quantum/action.c ****                     }
 602:quantum/action.c ****                     break;
 603:quantum/action.c ****                 case OP_SH_ON_OFF:
 604:quantum/action.c ****                     swap_hands = event.pressed;
 605:quantum/action.c ****                     break;
 606:quantum/action.c ****                 case OP_SH_OFF_ON:
 607:quantum/action.c ****                     swap_hands = !event.pressed;
 608:quantum/action.c ****                     break;
 609:quantum/action.c ****                 case OP_SH_ON:
 610:quantum/action.c ****                     if (!event.pressed) {
 611:quantum/action.c ****                         swap_hands = true;
 612:quantum/action.c ****                     }
 613:quantum/action.c ****                     break;
 614:quantum/action.c ****                 case OP_SH_OFF:
 615:quantum/action.c ****                     if (!event.pressed) {
 616:quantum/action.c ****                         swap_hands = false;
 617:quantum/action.c ****                     }
 618:quantum/action.c ****                     break;
 619:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 620:quantum/action.c ****                 case OP_SH_ONESHOT:
 621:quantum/action.c ****                     if (event.pressed) {
 622:quantum/action.c ****                         set_oneshot_swaphands();
 623:quantum/action.c ****                     } else {
 624:quantum/action.c ****                         release_oneshot_swaphands();
 625:quantum/action.c ****                     }
 626:quantum/action.c ****                     break;
 627:quantum/action.c **** #    endif
 628:quantum/action.c **** 
 629:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 630:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
 631:quantum/action.c ****                     /* tap toggle */
 632:quantum/action.c **** 
 633:quantum/action.c ****                     if (event.pressed) {
 634:quantum/action.c ****                         if (swap_held) {
 635:quantum/action.c ****                             swap_held = false;
 636:quantum/action.c ****                         } else {
 637:quantum/action.c ****                             swap_hands = !swap_hands;
 638:quantum/action.c ****                         }
 639:quantum/action.c ****                     } else {
 640:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 641:quantum/action.c ****                             swap_hands = !swap_hands;
 642:quantum/action.c ****                         }
 643:quantum/action.c ****                     }
 644:quantum/action.c ****                     break;
 645:quantum/action.c ****                 default:
 646:quantum/action.c ****                     /* tap key */
 647:quantum/action.c ****                     if (tap_count > 0) {
 648:quantum/action.c ****                         if (swap_held) {
 649:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 650:quantum/action.c ****                             swap_held  = false;
 651:quantum/action.c ****                         }
 652:quantum/action.c ****                         if (event.pressed) {
 653:quantum/action.c ****                             register_code(action.swap.code);
 654:quantum/action.c ****                         } else {
 655:quantum/action.c ****                             wait_ms(TAP_CODE_DELAY);
 656:quantum/action.c ****                             unregister_code(action.swap.code);
 657:quantum/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 658:quantum/action.c ****                         }
 659:quantum/action.c ****                     } else {
 660:quantum/action.c ****                         if (swap_held && !event.pressed) {
 661:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 662:quantum/action.c ****                             swap_held  = false;
 663:quantum/action.c ****                         }
 664:quantum/action.c ****                     }
 665:quantum/action.c **** #    endif
 666:quantum/action.c ****             }
 667:quantum/action.c **** #endif
 668:quantum/action.c **** #ifndef NO_ACTION_FUNCTION
 669:quantum/action.c ****         case ACT_FUNCTION:
 670:quantum/action.c ****             action_function(record, action.func.id, action.func.opt);
 671:quantum/action.c ****             break;
 672:quantum/action.c **** #endif
 673:quantum/action.c ****         default:
 674:quantum/action.c ****             break;
 675:quantum/action.c ****     }
 676:quantum/action.c **** 
 677:quantum/action.c **** #ifndef NO_ACTION_LAYER
 678:quantum/action.c ****     // if this event is a layer action, update the leds
 679:quantum/action.c ****     switch (action.kind.id) {
 680:quantum/action.c ****         case ACT_LAYER:
 681:quantum/action.c ****         case ACT_LAYER_MODS:
 682:quantum/action.c **** #    ifndef NO_ACTION_TAPPING
 683:quantum/action.c ****         case ACT_LAYER_TAP:
 684:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
 685:quantum/action.c **** #    endif
 686:quantum/action.c ****             led_set(host_keyboard_leds());
 687:quantum/action.c ****             break;
 688:quantum/action.c ****         default:
 689:quantum/action.c ****             break;
 690:quantum/action.c ****     }
 691:quantum/action.c **** #endif
 692:quantum/action.c **** 
 693:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 694:quantum/action.c **** #    if defined(RETRO_TAPPING) || defined(RETRO_TAPPING_PER_KEY)
 695:quantum/action.c ****     if (!is_tap_action(action)) {
 696:quantum/action.c ****         retro_tapping_counter = 0;
 697:quantum/action.c ****     } else {
 698:quantum/action.c ****         if (event.pressed) {
 699:quantum/action.c ****             if (tap_count > 0) {
 700:quantum/action.c ****                 retro_tapping_counter = 0;
 701:quantum/action.c ****             }
 702:quantum/action.c ****         } else {
 703:quantum/action.c ****             if (tap_count > 0) {
 704:quantum/action.c ****                 retro_tapping_counter = 0;
 705:quantum/action.c ****             } else {
 706:quantum/action.c ****                 if (
 707:quantum/action.c **** #        ifdef RETRO_TAPPING_PER_KEY
 708:quantum/action.c ****                     get_retro_tapping(get_event_keycode(record->event, false), record) &&
 709:quantum/action.c **** #        endif
 710:quantum/action.c ****                     retro_tapping_counter == 2) {
 711:quantum/action.c ****                     tap_code(action.layer_tap.code);
 712:quantum/action.c ****                 }
 713:quantum/action.c ****                 retro_tapping_counter = 0;
 714:quantum/action.c ****             }
 715:quantum/action.c ****         }
 716:quantum/action.c ****     }
 717:quantum/action.c **** #    endif
 718:quantum/action.c **** #endif
 719:quantum/action.c **** 
 720:quantum/action.c **** #ifdef SWAP_HANDS_ENABLE
 721:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 722:quantum/action.c ****     if (event.pressed && !(action.kind.id == ACT_SWAP_HANDS && action.swap.code == OP_SH_ONESHOT)) 
 723:quantum/action.c ****         use_oneshot_swaphands();
 724:quantum/action.c ****     }
 725:quantum/action.c **** #    endif
 726:quantum/action.c **** #endif
 727:quantum/action.c **** 
 728:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 729:quantum/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 730:quantum/action.c ****      * key before we leave the layer or no key up event will be generated.
 731:quantum/action.c ****      */
 732:quantum/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED)) {
 733:quantum/action.c ****         record->event.pressed = false;
 734:quantum/action.c ****         layer_on(get_oneshot_layer());
 735:quantum/action.c ****         process_record(record);
 736:quantum/action.c ****         layer_off(get_oneshot_layer());
 737:quantum/action.c ****     }
 738:quantum/action.c **** #endif
 739:quantum/action.c **** }
 740:quantum/action.c **** 
 741:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 742:quantum/action.c ****  *
 743:quantum/action.c ****  * FIXME: Needs documentation.
 744:quantum/action.c ****  */
 745:quantum/action.c **** void register_code(uint8_t code) {
 416               		.loc 1 745 34 is_stmt 1 view -0
 417               		.cfi_startproc
 418               		.loc 1 745 34 is_stmt 0 view .LVU84
 419 0000 CF93      		push r28
 420               	.LCFI6:
 421               		.cfi_def_cfa_offset 3
 422               		.cfi_offset 28, -2
 423               	/* prologue: function */
 424               	/* frame size = 0 */
 425               	/* stack size = 1 */
 426               	.L__stack_usage = 1
 427 0002 C82F      		mov r28,r24
 746:quantum/action.c ****     if (code == KC_NO) {
 428               		.loc 1 746 5 is_stmt 1 view .LVU85
 429               		.loc 1 746 8 is_stmt 0 view .LVU86
 430 0004 8823      		tst r24
 431 0006 01F4      		brne .+2
 432 0008 00C0      		rjmp .L38
 747:quantum/action.c ****         return;
 748:quantum/action.c ****     }
 749:quantum/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 750:quantum/action.c ****     else if (KC_LOCKING_CAPS == code) {
 751:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 752:quantum/action.c ****         // Resync: ignore if caps lock already is on
 753:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK)) return;
 754:quantum/action.c **** #    endif
 755:quantum/action.c ****         add_key(KC_CAPSLOCK);
 756:quantum/action.c ****         send_keyboard_report();
 757:quantum/action.c ****         wait_ms(100);
 758:quantum/action.c ****         del_key(KC_CAPSLOCK);
 759:quantum/action.c ****         send_keyboard_report();
 760:quantum/action.c ****     }
 761:quantum/action.c **** 
 762:quantum/action.c ****     else if (KC_LOCKING_NUM == code) {
 763:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 764:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_NUM_LOCK)) return;
 765:quantum/action.c **** #    endif
 766:quantum/action.c ****         add_key(KC_NUMLOCK);
 767:quantum/action.c ****         send_keyboard_report();
 768:quantum/action.c ****         wait_ms(100);
 769:quantum/action.c ****         del_key(KC_NUMLOCK);
 770:quantum/action.c ****         send_keyboard_report();
 771:quantum/action.c ****     }
 772:quantum/action.c **** 
 773:quantum/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 774:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 775:quantum/action.c ****         if (host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK)) return;
 776:quantum/action.c **** #    endif
 777:quantum/action.c ****         add_key(KC_SCROLLLOCK);
 778:quantum/action.c ****         send_keyboard_report();
 779:quantum/action.c ****         wait_ms(100);
 780:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 781:quantum/action.c ****         send_keyboard_report();
 782:quantum/action.c ****     }
 783:quantum/action.c **** #endif
 784:quantum/action.c **** 
 785:quantum/action.c ****     else if IS_KEY (code) {
 433               		.loc 1 785 10 is_stmt 1 view .LVU87
 434               		.loc 1 785 13 is_stmt 0 view .LVU88
 435 000a 8CEF      		ldi r24,lo8(-4)
 436               	.LVL30:
 437               		.loc 1 785 13 view .LVU89
 438 000c 8C0F      		add r24,r28
 439 000e 813A      		cpi r24,lo8(-95)
 440 0010 00F4      		brsh .L40
 786:quantum/action.c ****         // TODO: should push command_proc out of this block?
 787:quantum/action.c ****         if (command_proc(code)) return;
 441               		.loc 1 787 9 is_stmt 1 view .LVU90
 788:quantum/action.c **** 
 789:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 790:quantum/action.c **** /* TODO: remove
 791:quantum/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 792:quantum/action.c ****             uint8_t tmp_mods = get_mods();
 793:quantum/action.c ****             add_mods(oneshot_state.mods);
 794:quantum/action.c **** 
 795:quantum/action.c ****             add_key(code);
 796:quantum/action.c ****             send_keyboard_report();
 797:quantum/action.c **** 
 798:quantum/action.c ****             set_mods(tmp_mods);
 799:quantum/action.c ****             send_keyboard_report();
 800:quantum/action.c ****             oneshot_cancel();
 801:quantum/action.c ****         } else
 802:quantum/action.c **** */
 803:quantum/action.c **** #endif
 804:quantum/action.c ****         {
 805:quantum/action.c ****             // Force a new key press if the key is already pressed
 806:quantum/action.c ****             // without this, keys with the same keycode, but different
 807:quantum/action.c ****             // modifiers will be reported incorrectly, see issue #1708
 808:quantum/action.c ****             if (is_key_pressed(keyboard_report, code)) {
 442               		.loc 1 808 13 view .LVU91
 443               		.loc 1 808 17 is_stmt 0 view .LVU92
 444 0012 6C2F      		mov r22,r28
 445 0014 8091 0000 		lds r24,keyboard_report
 446 0018 9091 0000 		lds r25,keyboard_report+1
 447 001c 0E94 0000 		call is_key_pressed
 448               	.LVL31:
 449               		.loc 1 808 16 view .LVU93
 450 0020 8823      		tst r24
 451 0022 01F0      		breq .L41
 809:quantum/action.c ****                 del_key(code);
 452               		.loc 1 809 17 is_stmt 1 view .LVU94
 453 0024 8C2F      		mov r24,r28
 454 0026 0E94 0000 		call del_key
 455               	.LVL32:
 810:quantum/action.c ****                 send_keyboard_report();
 456               		.loc 1 810 17 view .LVU95
 457 002a 0E94 0000 		call send_keyboard_report
 458               	.LVL33:
 459               	.L41:
 811:quantum/action.c ****             }
 812:quantum/action.c ****             add_key(code);
 460               		.loc 1 812 13 view .LVU96
 461 002e 8C2F      		mov r24,r28
 462 0030 0E94 0000 		call add_key
 463               	.LVL34:
 813:quantum/action.c ****             send_keyboard_report();
 464               		.loc 1 813 13 view .LVU97
 465               	.L50:
 814:quantum/action.c ****         }
 815:quantum/action.c ****     } else if IS_MOD (code) {
 816:quantum/action.c ****         add_mods(MOD_BIT(code));
 817:quantum/action.c ****         send_keyboard_report();
 466               		.loc 1 817 9 view .LVU98
 467               	/* epilogue start */
 818:quantum/action.c ****     }
 819:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 820:quantum/action.c ****     else if IS_SYSTEM (code) {
 821:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 822:quantum/action.c ****     } else if IS_CONSUMER (code) {
 823:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 824:quantum/action.c ****     }
 825:quantum/action.c **** #endif
 826:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 827:quantum/action.c ****     else if IS_MOUSEKEY (code) {
 828:quantum/action.c ****         mousekey_on(code);
 829:quantum/action.c ****         mousekey_send();
 830:quantum/action.c ****     }
 831:quantum/action.c **** #endif
 832:quantum/action.c **** }
 468               		.loc 1 832 1 is_stmt 0 view .LVU99
 469 0034 CF91      		pop r28
 817:quantum/action.c ****     }
 470               		.loc 1 817 9 view .LVU100
 471 0036 0C94 0000 		jmp send_keyboard_report
 472               	.LVL35:
 473               	.L40:
 815:quantum/action.c ****         add_mods(MOD_BIT(code));
 474               		.loc 1 815 12 is_stmt 1 view .LVU101
 815:quantum/action.c ****         add_mods(MOD_BIT(code));
 475               		.loc 1 815 15 is_stmt 0 view .LVU102
 476 003a 80E2      		ldi r24,lo8(32)
 477 003c 8C0F      		add r24,r28
 478 003e 8830      		cpi r24,lo8(8)
 479 0040 00F4      		brsh .L42
 816:quantum/action.c ****         send_keyboard_report();
 480               		.loc 1 816 9 is_stmt 1 view .LVU103
 816:quantum/action.c ****         send_keyboard_report();
 481               		.loc 1 816 18 is_stmt 0 view .LVU104
 482 0042 C770      		andi r28,lo8(7)
 483               	.LVL36:
 816:quantum/action.c ****         send_keyboard_report();
 484               		.loc 1 816 9 view .LVU105
 485 0044 81E0      		ldi r24,lo8(1)
 486 0046 00C0      		rjmp 2f
 487               		1:
 488 0048 880F      		lsl r24
 489               		2:
 490 004a CA95      		dec r28
 491 004c 02F4      		brpl 1b
 492 004e 0E94 0000 		call add_mods
 493               	.LVL37:
 494 0052 00C0      		rjmp .L50
 495               	.LVL38:
 496               	.L42:
 820:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 497               		.loc 1 820 10 is_stmt 1 view .LVU106
 820:quantum/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 498               		.loc 1 820 13 is_stmt 0 view .LVU107
 499 0054 EBE5      		ldi r30,lo8(91)
 500 0056 EC0F      		add r30,r28
 501 0058 E330      		cpi r30,lo8(3)
 502 005a 00F4      		brsh .L43
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 503               		.loc 1 821 9 is_stmt 1 view .LVU108
 504               	.LVL39:
 505               	.LBB35:
 506               	.LBI35:
 507               		.file 3 "tmk_core/common/report.h"
   1:tmk_core/common/report.h **** /*
   2:tmk_core/common/report.h **** Copyright 2011,2012 Jun Wako <wakojun@gmail.com>
   3:tmk_core/common/report.h **** 
   4:tmk_core/common/report.h **** This program is free software: you can redistribute it and/or modify
   5:tmk_core/common/report.h **** it under the terms of the GNU General Public License as published by
   6:tmk_core/common/report.h **** the Free Software Foundation, either version 2 of the License, or
   7:tmk_core/common/report.h **** (at your option) any later version.
   8:tmk_core/common/report.h **** 
   9:tmk_core/common/report.h **** This program is distributed in the hope that it will be useful,
  10:tmk_core/common/report.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:tmk_core/common/report.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:tmk_core/common/report.h **** GNU General Public License for more details.
  13:tmk_core/common/report.h **** 
  14:tmk_core/common/report.h **** You should have received a copy of the GNU General Public License
  15:tmk_core/common/report.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:tmk_core/common/report.h **** */
  17:tmk_core/common/report.h **** 
  18:tmk_core/common/report.h **** #pragma once
  19:tmk_core/common/report.h **** 
  20:tmk_core/common/report.h **** #include <stdint.h>
  21:tmk_core/common/report.h **** #include <stdbool.h>
  22:tmk_core/common/report.h **** #include "keycode.h"
  23:tmk_core/common/report.h **** 
  24:tmk_core/common/report.h **** // clang-format off
  25:tmk_core/common/report.h **** 
  26:tmk_core/common/report.h **** /* HID report IDs */
  27:tmk_core/common/report.h **** enum hid_report_ids {
  28:tmk_core/common/report.h ****     REPORT_ID_KEYBOARD = 1,
  29:tmk_core/common/report.h ****     REPORT_ID_MOUSE,
  30:tmk_core/common/report.h ****     REPORT_ID_SYSTEM,
  31:tmk_core/common/report.h ****     REPORT_ID_CONSUMER,
  32:tmk_core/common/report.h ****     REPORT_ID_NKRO,
  33:tmk_core/common/report.h ****     REPORT_ID_JOYSTICK,
  34:tmk_core/common/report.h ****     REPORT_ID_DIGITIZER
  35:tmk_core/common/report.h **** };
  36:tmk_core/common/report.h **** 
  37:tmk_core/common/report.h **** /* Mouse buttons */
  38:tmk_core/common/report.h **** #define MOUSE_BTN_MASK(n) (1 << (n))
  39:tmk_core/common/report.h **** enum mouse_buttons {
  40:tmk_core/common/report.h ****     MOUSE_BTN1 = MOUSE_BTN_MASK(0),
  41:tmk_core/common/report.h ****     MOUSE_BTN2 = MOUSE_BTN_MASK(1),
  42:tmk_core/common/report.h ****     MOUSE_BTN3 = MOUSE_BTN_MASK(2),
  43:tmk_core/common/report.h ****     MOUSE_BTN4 = MOUSE_BTN_MASK(3),
  44:tmk_core/common/report.h ****     MOUSE_BTN5 = MOUSE_BTN_MASK(4),
  45:tmk_core/common/report.h ****     MOUSE_BTN6 = MOUSE_BTN_MASK(5),
  46:tmk_core/common/report.h ****     MOUSE_BTN7 = MOUSE_BTN_MASK(6),
  47:tmk_core/common/report.h ****     MOUSE_BTN8 = MOUSE_BTN_MASK(7)
  48:tmk_core/common/report.h **** };
  49:tmk_core/common/report.h **** 
  50:tmk_core/common/report.h **** /* Consumer Page (0x0C)
  51:tmk_core/common/report.h ****  *
  52:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=75
  53:tmk_core/common/report.h ****  */
  54:tmk_core/common/report.h **** enum consumer_usages {
  55:tmk_core/common/report.h ****     // 15.5 Display Controls
  56:tmk_core/common/report.h ****     SNAPSHOT               = 0x065,
  57:tmk_core/common/report.h ****     BRIGHTNESS_UP          = 0x06F, // https://www.usb.org/sites/default/files/hutrr41_0.pdf
  58:tmk_core/common/report.h ****     BRIGHTNESS_DOWN        = 0x070,
  59:tmk_core/common/report.h ****     // 15.7 Transport Controls
  60:tmk_core/common/report.h ****     TRANSPORT_RECORD       = 0x0B2,
  61:tmk_core/common/report.h ****     TRANSPORT_FAST_FORWARD = 0x0B3,
  62:tmk_core/common/report.h ****     TRANSPORT_REWIND       = 0x0B4,
  63:tmk_core/common/report.h ****     TRANSPORT_NEXT_TRACK   = 0x0B5,
  64:tmk_core/common/report.h ****     TRANSPORT_PREV_TRACK   = 0x0B6,
  65:tmk_core/common/report.h ****     TRANSPORT_STOP         = 0x0B7,
  66:tmk_core/common/report.h ****     TRANSPORT_EJECT        = 0x0B8,
  67:tmk_core/common/report.h ****     TRANSPORT_RANDOM_PLAY  = 0x0B9,
  68:tmk_core/common/report.h ****     TRANSPORT_STOP_EJECT   = 0x0CC,
  69:tmk_core/common/report.h ****     TRANSPORT_PLAY_PAUSE   = 0x0CD,
  70:tmk_core/common/report.h ****     // 15.9.1 Audio Controls - Volume
  71:tmk_core/common/report.h ****     AUDIO_MUTE             = 0x0E2,
  72:tmk_core/common/report.h ****     AUDIO_VOL_UP           = 0x0E9,
  73:tmk_core/common/report.h ****     AUDIO_VOL_DOWN         = 0x0EA,
  74:tmk_core/common/report.h ****     // 15.15 Application Launch Buttons
  75:tmk_core/common/report.h ****     AL_CC_CONFIG           = 0x183,
  76:tmk_core/common/report.h ****     AL_EMAIL               = 0x18A,
  77:tmk_core/common/report.h ****     AL_CALCULATOR          = 0x192,
  78:tmk_core/common/report.h ****     AL_LOCAL_BROWSER       = 0x194,
  79:tmk_core/common/report.h ****     AL_LOCK                = 0x19E,
  80:tmk_core/common/report.h ****     AL_CONTROL_PANEL       = 0x19F,
  81:tmk_core/common/report.h ****     AL_ASSISTANT           = 0x1CB,
  82:tmk_core/common/report.h ****     AL_KEYBOARD_LAYOUT     = 0x1AE,
  83:tmk_core/common/report.h ****     // 15.16 Generic GUI Application Controls
  84:tmk_core/common/report.h ****     AC_NEW                 = 0x201,
  85:tmk_core/common/report.h ****     AC_OPEN                = 0x202,
  86:tmk_core/common/report.h ****     AC_CLOSE               = 0x203,
  87:tmk_core/common/report.h ****     AC_EXIT                = 0x204,
  88:tmk_core/common/report.h ****     AC_MAXIMIZE            = 0x205,
  89:tmk_core/common/report.h ****     AC_MINIMIZE            = 0x206,
  90:tmk_core/common/report.h ****     AC_SAVE                = 0x207,
  91:tmk_core/common/report.h ****     AC_PRINT               = 0x208,
  92:tmk_core/common/report.h ****     AC_PROPERTIES          = 0x209,
  93:tmk_core/common/report.h ****     AC_UNDO                = 0x21A,
  94:tmk_core/common/report.h ****     AC_COPY                = 0x21B,
  95:tmk_core/common/report.h ****     AC_CUT                 = 0x21C,
  96:tmk_core/common/report.h ****     AC_PASTE               = 0x21D,
  97:tmk_core/common/report.h ****     AC_SELECT_ALL          = 0x21E,
  98:tmk_core/common/report.h ****     AC_FIND                = 0x21F,
  99:tmk_core/common/report.h ****     AC_SEARCH              = 0x221,
 100:tmk_core/common/report.h ****     AC_HOME                = 0x223,
 101:tmk_core/common/report.h ****     AC_BACK                = 0x224,
 102:tmk_core/common/report.h ****     AC_FORWARD             = 0x225,
 103:tmk_core/common/report.h ****     AC_STOP                = 0x226,
 104:tmk_core/common/report.h ****     AC_REFRESH             = 0x227,
 105:tmk_core/common/report.h ****     AC_BOOKMARKS           = 0x22A
 106:tmk_core/common/report.h **** };
 107:tmk_core/common/report.h **** 
 108:tmk_core/common/report.h **** /* Generic Desktop Page (0x01)
 109:tmk_core/common/report.h ****  *
 110:tmk_core/common/report.h ****  * See https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf#page=26
 111:tmk_core/common/report.h ****  */
 112:tmk_core/common/report.h **** enum desktop_usages {
 113:tmk_core/common/report.h ****     // 4.5.1 System Controls - Power Controls
 114:tmk_core/common/report.h ****     SYSTEM_POWER_DOWN             = 0x81,
 115:tmk_core/common/report.h ****     SYSTEM_SLEEP                  = 0x82,
 116:tmk_core/common/report.h ****     SYSTEM_WAKE_UP                = 0x83,
 117:tmk_core/common/report.h ****     SYSTEM_RESTART                = 0x8F,
 118:tmk_core/common/report.h ****     // 4.10 System Display Controls
 119:tmk_core/common/report.h ****     SYSTEM_DISPLAY_TOGGLE_INT_EXT = 0xB5
 120:tmk_core/common/report.h **** };
 121:tmk_core/common/report.h **** 
 122:tmk_core/common/report.h **** // clang-format on
 123:tmk_core/common/report.h **** 
 124:tmk_core/common/report.h **** #define NKRO_SHARED_EP
 125:tmk_core/common/report.h **** /* key report size(NKRO or boot mode) */
 126:tmk_core/common/report.h **** #if defined(NKRO_ENABLE)
 127:tmk_core/common/report.h **** #    if defined(PROTOCOL_LUFA) || defined(PROTOCOL_CHIBIOS)
 128:tmk_core/common/report.h **** #        include "protocol/usb_descriptor.h"
 129:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (SHARED_EPSIZE - 2)
 130:tmk_core/common/report.h **** #    elif defined(PROTOCOL_ARM_ATSAM)
 131:tmk_core/common/report.h **** #        include "protocol/arm_atsam/usb/udi_device_epsize.h"
 132:tmk_core/common/report.h **** #        define KEYBOARD_REPORT_BITS (NKRO_EPSIZE - 1)
 133:tmk_core/common/report.h **** #        undef NKRO_SHARED_EP
 134:tmk_core/common/report.h **** #        undef MOUSE_SHARED_EP
 135:tmk_core/common/report.h **** #    else
 136:tmk_core/common/report.h **** #        error "NKRO not supported with this protocol"
 137:tmk_core/common/report.h **** #    endif
 138:tmk_core/common/report.h **** #endif
 139:tmk_core/common/report.h **** 
 140:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 141:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 9
 142:tmk_core/common/report.h **** #else
 143:tmk_core/common/report.h **** #    define KEYBOARD_REPORT_SIZE 8
 144:tmk_core/common/report.h **** #endif
 145:tmk_core/common/report.h **** 
 146:tmk_core/common/report.h **** #define KEYBOARD_REPORT_KEYS 6
 147:tmk_core/common/report.h **** 
 148:tmk_core/common/report.h **** #ifdef __cplusplus
 149:tmk_core/common/report.h **** extern "C" {
 150:tmk_core/common/report.h **** #endif
 151:tmk_core/common/report.h **** 
 152:tmk_core/common/report.h **** /*
 153:tmk_core/common/report.h ****  * keyboard report is 8-byte array retains state of 8 modifiers and 6 keys.
 154:tmk_core/common/report.h ****  *
 155:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7
 156:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 157:tmk_core/common/report.h ****  * desc |mods    |reserved|keys[0] |keys[1] |keys[2] |keys[3] |keys[4] |keys[5]
 158:tmk_core/common/report.h ****  *
 159:tmk_core/common/report.h ****  * It is exended to 16 bytes to retain 120keys+8mods when NKRO mode.
 160:tmk_core/common/report.h ****  *
 161:tmk_core/common/report.h ****  * byte |0       |1       |2       |3       |4       |5       |6       |7        ... |15
 162:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------     +--------
 163:tmk_core/common/report.h ****  * desc |mods    |bits[0] |bits[1] |bits[2] |bits[3] |bits[4] |bits[5] |bits[6]  ... |bit[14]
 164:tmk_core/common/report.h ****  *
 165:tmk_core/common/report.h ****  * mods retains state of 8 modifiers.
 166:tmk_core/common/report.h ****  *
 167:tmk_core/common/report.h ****  *  bit |0       |1       |2       |3       |4       |5       |6       |7
 168:tmk_core/common/report.h ****  * -----+--------+--------+--------+--------+--------+--------+--------+--------
 169:tmk_core/common/report.h ****  * desc |Lcontrol|Lshift  |Lalt    |Lgui    |Rcontrol|Rshift  |Ralt    |Rgui
 170:tmk_core/common/report.h ****  *
 171:tmk_core/common/report.h ****  */
 172:tmk_core/common/report.h **** typedef union {
 173:tmk_core/common/report.h ****     uint8_t raw[KEYBOARD_REPORT_SIZE];
 174:tmk_core/common/report.h ****     struct {
 175:tmk_core/common/report.h **** #ifdef KEYBOARD_SHARED_EP
 176:tmk_core/common/report.h ****         uint8_t report_id;
 177:tmk_core/common/report.h **** #endif
 178:tmk_core/common/report.h ****         uint8_t mods;
 179:tmk_core/common/report.h ****         uint8_t reserved;
 180:tmk_core/common/report.h ****         uint8_t keys[KEYBOARD_REPORT_KEYS];
 181:tmk_core/common/report.h ****     };
 182:tmk_core/common/report.h **** #ifdef NKRO_ENABLE
 183:tmk_core/common/report.h ****     struct nkro_report {
 184:tmk_core/common/report.h **** #    ifdef NKRO_SHARED_EP
 185:tmk_core/common/report.h ****         uint8_t report_id;
 186:tmk_core/common/report.h **** #    endif
 187:tmk_core/common/report.h ****         uint8_t mods;
 188:tmk_core/common/report.h ****         uint8_t bits[KEYBOARD_REPORT_BITS];
 189:tmk_core/common/report.h ****     } nkro;
 190:tmk_core/common/report.h **** #endif
 191:tmk_core/common/report.h **** } __attribute__((packed)) report_keyboard_t;
 192:tmk_core/common/report.h **** 
 193:tmk_core/common/report.h **** typedef struct {
 194:tmk_core/common/report.h ****     uint8_t  report_id;
 195:tmk_core/common/report.h ****     uint16_t usage;
 196:tmk_core/common/report.h **** } __attribute__((packed)) report_extra_t;
 197:tmk_core/common/report.h **** 
 198:tmk_core/common/report.h **** typedef struct {
 199:tmk_core/common/report.h **** #ifdef MOUSE_SHARED_EP
 200:tmk_core/common/report.h ****     uint8_t report_id;
 201:tmk_core/common/report.h **** #endif
 202:tmk_core/common/report.h ****     uint8_t buttons;
 203:tmk_core/common/report.h ****     int8_t  x;
 204:tmk_core/common/report.h ****     int8_t  y;
 205:tmk_core/common/report.h ****     int8_t  v;
 206:tmk_core/common/report.h ****     int8_t  h;
 207:tmk_core/common/report.h **** } __attribute__((packed)) report_mouse_t;
 208:tmk_core/common/report.h **** 
 209:tmk_core/common/report.h **** typedef struct {
 210:tmk_core/common/report.h **** #ifdef DIGITIZER_SHARED_EP
 211:tmk_core/common/report.h ****     uint8_t report_id;
 212:tmk_core/common/report.h **** #endif
 213:tmk_core/common/report.h ****     uint8_t  tip : 1;
 214:tmk_core/common/report.h ****     uint8_t  inrange : 1;
 215:tmk_core/common/report.h ****     uint8_t  pad2 : 6;
 216:tmk_core/common/report.h ****     uint16_t x;
 217:tmk_core/common/report.h ****     uint16_t y;
 218:tmk_core/common/report.h **** } __attribute__((packed)) report_digitizer_t;
 219:tmk_core/common/report.h **** 
 220:tmk_core/common/report.h **** typedef struct {
 221:tmk_core/common/report.h **** #if JOYSTICK_AXES_COUNT > 0
 222:tmk_core/common/report.h **** #    if JOYSTICK_AXES_RESOLUTION > 8
 223:tmk_core/common/report.h ****     int16_t axes[JOYSTICK_AXES_COUNT];
 224:tmk_core/common/report.h **** #    else
 225:tmk_core/common/report.h ****     int8_t axes[JOYSTICK_AXES_COUNT];
 226:tmk_core/common/report.h **** #    endif
 227:tmk_core/common/report.h **** #endif
 228:tmk_core/common/report.h **** 
 229:tmk_core/common/report.h **** #if JOYSTICK_BUTTON_COUNT > 0
 230:tmk_core/common/report.h ****     uint8_t buttons[(JOYSTICK_BUTTON_COUNT - 1) / 8 + 1];
 231:tmk_core/common/report.h **** #endif
 232:tmk_core/common/report.h **** } __attribute__((packed)) joystick_report_t;
 233:tmk_core/common/report.h **** 
 234:tmk_core/common/report.h **** /* keycode to system usage */
 235:tmk_core/common/report.h **** static inline uint16_t KEYCODE2SYSTEM(uint8_t key) {
 508               		.loc 3 235 24 view .LVU109
 509               	.LBE35:
 236:tmk_core/common/report.h ****     switch (key) {
 510               		.loc 3 236 5 view .LVU110
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 511               		.loc 1 821 9 is_stmt 0 view .LVU111
 512 005c F0E0      		ldi r31,0
 513 005e E050      		subi r30,lo8(-(CSWTCH.23))
 514 0060 F040      		sbci r31,hi8(-(CSWTCH.23))
 515 0062 8081      		ld r24,Z
 516 0064 90E0      		ldi r25,0
 517               	/* epilogue start */
 518               		.loc 1 832 1 view .LVU112
 519 0066 CF91      		pop r28
 520               	.LVL40:
 821:quantum/action.c ****     } else if IS_CONSUMER (code) {
 521               		.loc 1 821 9 view .LVU113
 522 0068 0C94 0000 		jmp host_system_send
 523               	.LVL41:
 524               	.L43:
 822:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 525               		.loc 1 822 12 is_stmt 1 view .LVU114
 822:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 526               		.loc 1 822 15 is_stmt 0 view .LVU115
 527 006c C85A      		subi r28,lo8(-(88))
 528               	.LVL42:
 822:quantum/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 529               		.loc 1 822 15 view .LVU116
 530 006e C731      		cpi r28,lo8(23)
 531 0070 00F4      		brsh .L38
 823:quantum/action.c ****     }
 532               		.loc 1 823 9 is_stmt 1 view .LVU117
 533               	.LVL43:
 534               	.LBB36:
 535               	.LBI36:
 237:tmk_core/common/report.h ****         case KC_SYSTEM_POWER:
 238:tmk_core/common/report.h ****             return SYSTEM_POWER_DOWN;
 239:tmk_core/common/report.h ****         case KC_SYSTEM_SLEEP:
 240:tmk_core/common/report.h ****             return SYSTEM_SLEEP;
 241:tmk_core/common/report.h ****         case KC_SYSTEM_WAKE:
 242:tmk_core/common/report.h ****             return SYSTEM_WAKE_UP;
 243:tmk_core/common/report.h ****         default:
 244:tmk_core/common/report.h ****             return 0;
 245:tmk_core/common/report.h ****     }
 246:tmk_core/common/report.h **** }
 247:tmk_core/common/report.h **** 
 248:tmk_core/common/report.h **** /* keycode to consumer usage */
 249:tmk_core/common/report.h **** static inline uint16_t KEYCODE2CONSUMER(uint8_t key) {
 536               		.loc 3 249 24 view .LVU118
 537               	.LBE36:
 250:tmk_core/common/report.h ****     switch (key) {
 538               		.loc 3 250 5 view .LVU119
 823:quantum/action.c ****     }
 539               		.loc 1 823 9 is_stmt 0 view .LVU120
 540 0072 EC2F      		mov r30,r28
 541 0074 F0E0      		ldi r31,0
 542 0076 EE0F      		lsl r30
 543 0078 FF1F      		rol r31
 544 007a E050      		subi r30,lo8(-(CSWTCH.24))
 545 007c F040      		sbci r31,hi8(-(CSWTCH.24))
 546 007e 8081      		ld r24,Z
 547 0080 9181      		ldd r25,Z+1
 548               	/* epilogue start */
 549               		.loc 1 832 1 view .LVU121
 550 0082 CF91      		pop r28
 551               	.LVL44:
 823:quantum/action.c ****     }
 552               		.loc 1 823 9 view .LVU122
 553 0084 0C94 0000 		jmp host_consumer_send
 554               	.LVL45:
 555               	.L38:
 556               	/* epilogue start */
 557               		.loc 1 832 1 view .LVU123
 558 0088 CF91      		pop r28
 559 008a 0895      		ret
 560               		.cfi_endproc
 561               	.LFE25:
 563               		.section	.text.unregister_code,"ax",@progbits
 564               	.global	unregister_code
 566               	unregister_code:
 567               	.LVL46:
 568               	.LFB26:
 833:quantum/action.c **** 
 834:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 835:quantum/action.c ****  *
 836:quantum/action.c ****  * FIXME: Needs documentation.
 837:quantum/action.c ****  */
 838:quantum/action.c **** void unregister_code(uint8_t code) {
 569               		.loc 1 838 36 is_stmt 1 view -0
 570               		.cfi_startproc
 571               	/* prologue: function */
 572               	/* frame size = 0 */
 573               	/* stack size = 0 */
 574               	.L__stack_usage = 0
 839:quantum/action.c ****     if (code == KC_NO) {
 575               		.loc 1 839 5 view .LVU125
 576               		.loc 1 839 8 is_stmt 0 view .LVU126
 577 0000 8823      		tst r24
 578 0002 01F0      		breq .L51
 840:quantum/action.c ****         return;
 841:quantum/action.c ****     }
 842:quantum/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 843:quantum/action.c ****     else if (KC_LOCKING_CAPS == code) {
 844:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 845:quantum/action.c ****         // Resync: ignore if caps lock already is off
 846:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_CAPS_LOCK))) return;
 847:quantum/action.c **** #    endif
 848:quantum/action.c ****         add_key(KC_CAPSLOCK);
 849:quantum/action.c ****         send_keyboard_report();
 850:quantum/action.c ****         del_key(KC_CAPSLOCK);
 851:quantum/action.c ****         send_keyboard_report();
 852:quantum/action.c ****     }
 853:quantum/action.c **** 
 854:quantum/action.c ****     else if (KC_LOCKING_NUM == code) {
 855:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 856:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_NUM_LOCK))) return;
 857:quantum/action.c **** #    endif
 858:quantum/action.c ****         add_key(KC_NUMLOCK);
 859:quantum/action.c ****         send_keyboard_report();
 860:quantum/action.c ****         del_key(KC_NUMLOCK);
 861:quantum/action.c ****         send_keyboard_report();
 862:quantum/action.c ****     }
 863:quantum/action.c **** 
 864:quantum/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 865:quantum/action.c **** #    ifdef LOCKING_RESYNC_ENABLE
 866:quantum/action.c ****         if (!(host_keyboard_leds() & (1 << USB_LED_SCROLL_LOCK))) return;
 867:quantum/action.c **** #    endif
 868:quantum/action.c ****         add_key(KC_SCROLLLOCK);
 869:quantum/action.c ****         send_keyboard_report();
 870:quantum/action.c ****         del_key(KC_SCROLLLOCK);
 871:quantum/action.c ****         send_keyboard_report();
 872:quantum/action.c ****     }
 873:quantum/action.c **** #endif
 874:quantum/action.c **** 
 875:quantum/action.c ****     else if IS_KEY (code) {
 579               		.loc 1 875 10 is_stmt 1 view .LVU127
 580               		.loc 1 875 13 is_stmt 0 view .LVU128
 581 0004 9CEF      		ldi r25,lo8(-4)
 582 0006 980F      		add r25,r24
 583 0008 913A      		cpi r25,lo8(-95)
 584 000a 00F4      		brsh .L53
 876:quantum/action.c ****         del_key(code);
 585               		.loc 1 876 9 is_stmt 1 view .LVU129
 586 000c 0E94 0000 		call del_key
 587               	.LVL47:
 877:quantum/action.c ****         send_keyboard_report();
 588               		.loc 1 877 9 view .LVU130
 589               	.L59:
 878:quantum/action.c ****     } else if IS_MOD (code) {
 879:quantum/action.c ****         del_mods(MOD_BIT(code));
 880:quantum/action.c ****         send_keyboard_report();
 590               		.loc 1 880 9 view .LVU131
 591 0010 0C94 0000 		jmp send_keyboard_report
 592               	.LVL48:
 593               	.L53:
 878:quantum/action.c ****     } else if IS_MOD (code) {
 594               		.loc 1 878 12 view .LVU132
 878:quantum/action.c ****     } else if IS_MOD (code) {
 595               		.loc 1 878 15 is_stmt 0 view .LVU133
 596 0014 90E2      		ldi r25,lo8(32)
 597 0016 980F      		add r25,r24
 598 0018 9830      		cpi r25,lo8(8)
 599 001a 00F4      		brsh .L54
 879:quantum/action.c ****         send_keyboard_report();
 600               		.loc 1 879 9 is_stmt 1 view .LVU134
 879:quantum/action.c ****         send_keyboard_report();
 601               		.loc 1 879 18 is_stmt 0 view .LVU135
 602 001c 8770      		andi r24,lo8(7)
 603               	.LVL49:
 879:quantum/action.c ****         send_keyboard_report();
 604               		.loc 1 879 9 view .LVU136
 605 001e 91E0      		ldi r25,lo8(1)
 606 0020 00C0      		rjmp 2f
 607               		1:
 608 0022 990F      		lsl r25
 609               		2:
 610 0024 8A95      		dec r24
 611 0026 02F4      		brpl 1b
 612 0028 892F      		mov r24,r25
 613 002a 0E94 0000 		call del_mods
 614               	.LVL50:
 615 002e 00C0      		rjmp .L59
 616               	.LVL51:
 617               	.L54:
 881:quantum/action.c ****     } else if IS_SYSTEM (code) {
 618               		.loc 1 881 12 is_stmt 1 view .LVU137
 619               		.loc 1 881 15 is_stmt 0 view .LVU138
 620 0030 9BE5      		ldi r25,lo8(91)
 621 0032 980F      		add r25,r24
 622 0034 9330      		cpi r25,lo8(3)
 623 0036 00F4      		brsh .L55
 882:quantum/action.c ****         host_system_send(0);
 624               		.loc 1 882 9 is_stmt 1 view .LVU139
 625 0038 90E0      		ldi r25,0
 626 003a 80E0      		ldi r24,0
 627               	.LVL52:
 628               		.loc 1 882 9 is_stmt 0 view .LVU140
 629 003c 0C94 0000 		jmp host_system_send
 630               	.LVL53:
 631               	.L55:
 883:quantum/action.c ****     } else if IS_CONSUMER (code) {
 632               		.loc 1 883 12 is_stmt 1 view .LVU141
 633               		.loc 1 883 15 is_stmt 0 view .LVU142
 634 0040 885A      		subi r24,lo8(-(88))
 635               	.LVL54:
 636               		.loc 1 883 15 view .LVU143
 637 0042 8731      		cpi r24,lo8(23)
 638 0044 00F4      		brsh .L51
 884:quantum/action.c ****         host_consumer_send(0);
 639               		.loc 1 884 9 is_stmt 1 view .LVU144
 640 0046 90E0      		ldi r25,0
 641 0048 80E0      		ldi r24,0
 642               	.LVL55:
 643               		.loc 1 884 9 is_stmt 0 view .LVU145
 644 004a 0C94 0000 		jmp host_consumer_send
 645               	.LVL56:
 646               	.L51:
 647               	/* epilogue start */
 885:quantum/action.c ****     }
 886:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 887:quantum/action.c ****     else if IS_MOUSEKEY (code) {
 888:quantum/action.c ****         mousekey_off(code);
 889:quantum/action.c ****         mousekey_send();
 890:quantum/action.c ****     }
 891:quantum/action.c **** #endif
 892:quantum/action.c **** }
 648               		.loc 1 892 1 view .LVU146
 649 004e 0895      		ret
 650               		.cfi_endproc
 651               	.LFE26:
 653               		.section	.text.tap_code_delay,"ax",@progbits
 654               	.global	tap_code_delay
 656               	tap_code_delay:
 657               	.LVL57:
 658               	.LFB27:
 893:quantum/action.c **** 
 894:quantum/action.c **** /** \brief Tap a keycode with a delay.
 895:quantum/action.c ****  *
 896:quantum/action.c ****  * \param code The basic keycode to tap.
 897:quantum/action.c ****  * \param delay The amount of time in milliseconds to leave the keycode registered, before unregist
 898:quantum/action.c ****  */
 899:quantum/action.c **** void tap_code_delay(uint8_t code, uint16_t delay) {
 659               		.loc 1 899 51 is_stmt 1 view -0
 660               		.cfi_startproc
 661               		.loc 1 899 51 is_stmt 0 view .LVU148
 662 0000 1F93      		push r17
 663               	.LCFI7:
 664               		.cfi_def_cfa_offset 3
 665               		.cfi_offset 17, -2
 666 0002 CF93      		push r28
 667               	.LCFI8:
 668               		.cfi_def_cfa_offset 4
 669               		.cfi_offset 28, -3
 670 0004 DF93      		push r29
 671               	.LCFI9:
 672               		.cfi_def_cfa_offset 5
 673               		.cfi_offset 29, -4
 674               	/* prologue: function */
 675               	/* frame size = 0 */
 676               	/* stack size = 3 */
 677               	.L__stack_usage = 3
 678 0006 182F      		mov r17,r24
 679 0008 EB01      		movw r28,r22
 900:quantum/action.c ****     register_code(code);
 680               		.loc 1 900 5 is_stmt 1 view .LVU149
 681 000a 0E94 0000 		call register_code
 682               	.LVL58:
 901:quantum/action.c ****     for (uint16_t i = delay; i > 0; i--) {
 683               		.loc 1 901 5 view .LVU150
 684               	.LBB37:
 685               		.loc 1 901 10 view .LVU151
 686               	.L61:
 687               		.loc 1 901 5 is_stmt 0 discriminator 1 view .LVU152
 688 000e 2097      		sbiw r28,0
 689 0010 01F4      		brne .L62
 690               		.loc 1 901 5 discriminator 1 view .LVU153
 691               	.LBE37:
 902:quantum/action.c ****         wait_ms(1);
 903:quantum/action.c ****     }
 904:quantum/action.c ****     unregister_code(code);
 692               		.loc 1 904 5 is_stmt 1 view .LVU154
 693 0012 812F      		mov r24,r17
 694               	/* epilogue start */
 905:quantum/action.c **** }
 695               		.loc 1 905 1 is_stmt 0 view .LVU155
 696 0014 DF91      		pop r29
 697 0016 CF91      		pop r28
 698               	.LVL59:
 699               		.loc 1 905 1 view .LVU156
 700 0018 1F91      		pop r17
 701               	.LVL60:
 904:quantum/action.c **** }
 702               		.loc 1 904 5 view .LVU157
 703 001a 0C94 0000 		jmp unregister_code
 704               	.LVL61:
 705               	.L62:
 706               	.LBB40:
 902:quantum/action.c ****         wait_ms(1);
 707               		.loc 1 902 9 is_stmt 1 view .LVU158
 902:quantum/action.c ****         wait_ms(1);
 708               		.loc 1 902 9 view .LVU159
 902:quantum/action.c ****         wait_ms(1);
 709               		.loc 1 902 9 view .LVU160
 710               	.LBB38:
 711               	.LBI38:
 712               		.file 4 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 713               		.loc 4 166 1 view .LVU161
 714               	.LBB39:
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 715               		.loc 4 168 2 view .LVU162
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 716               		.loc 4 172 2 view .LVU163
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 717               		.loc 4 173 2 view .LVU164
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 718               		.loc 4 174 2 view .LVU165
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 719               		.loc 4 184 3 view .LVU166
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 720               		.loc 4 187 2 view .LVU167
 721 001e 8FE9      		ldi r24,lo8(3999)
 722 0020 9FE0      		ldi r25,hi8(3999)
 723 0022 0197      	1:	sbiw r24,1
 724 0024 01F4      		brne 1b
 725 0026 00C0      		rjmp .
 726 0028 0000      		nop
 727               	.LVL62:
 728               		.loc 4 187 2 is_stmt 0 view .LVU168
 729               	.LBE39:
 730               	.LBE38:
 901:quantum/action.c ****         wait_ms(1);
 731               		.loc 1 901 38 view .LVU169
 732 002a 2197      		sbiw r28,1
 733               	.LVL63:
 901:quantum/action.c ****         wait_ms(1);
 734               		.loc 1 901 38 view .LVU170
 735 002c 00C0      		rjmp .L61
 736               	.LBE40:
 737               		.cfi_endproc
 738               	.LFE27:
 740               		.section	.text.tap_code,"ax",@progbits
 741               	.global	tap_code
 743               	tap_code:
 744               	.LVL64:
 745               	.LFB28:
 906:quantum/action.c **** 
 907:quantum/action.c **** /** \brief Tap a keycode with the default delay.
 908:quantum/action.c ****  *
 909:quantum/action.c ****  * \param code The basic keycode to tap. If `code` is `KC_CAPS`, the delay will be `TAP_HOLD_CAPS_D
 910:quantum/action.c ****  */
 911:quantum/action.c **** void tap_code(uint8_t code) { tap_code_delay(code, code == KC_CAPS ? TAP_HOLD_CAPS_DELAY : TAP_CODE
 746               		.loc 1 911 29 is_stmt 1 view -0
 747               		.cfi_startproc
 748               	/* prologue: function */
 749               	/* frame size = 0 */
 750               	/* stack size = 0 */
 751               	.L__stack_usage = 0
 752               		.loc 1 911 31 view .LVU172
 753 0000 6AE0      		ldi r22,lo8(10)
 754 0002 70E0      		ldi r23,0
 755 0004 8933      		cpi r24,lo8(57)
 756 0006 01F4      		brne .L64
 757 0008 60E5      		ldi r22,lo8(80)
 758 000a 70E0      		ldi r23,0
 759               	.L64:
 760               		.loc 1 911 31 is_stmt 0 discriminator 4 view .LVU173
 761 000c 0C94 0000 		jmp tap_code_delay
 762               	.LVL65:
 763               		.loc 1 911 31 discriminator 4 view .LVU174
 764               		.cfi_endproc
 765               	.LFE28:
 767               		.section	.text.register_mods,"ax",@progbits
 768               	.global	register_mods
 770               	register_mods:
 771               	.LVL66:
 772               	.LFB29:
 912:quantum/action.c **** 
 913:quantum/action.c **** /** \brief Adds the given physically pressed modifiers and sends a keyboard report immediately.
 914:quantum/action.c ****  *
 915:quantum/action.c ****  * \param mods A bitfield of modifiers to register.
 916:quantum/action.c ****  */
 917:quantum/action.c **** void register_mods(uint8_t mods) {
 773               		.loc 1 917 34 is_stmt 1 view -0
 774               		.cfi_startproc
 775               	/* prologue: function */
 776               	/* frame size = 0 */
 777               	/* stack size = 0 */
 778               	.L__stack_usage = 0
 918:quantum/action.c ****     if (mods) {
 779               		.loc 1 918 5 view .LVU176
 780               		.loc 1 918 8 is_stmt 0 view .LVU177
 781 0000 8823      		tst r24
 782 0002 01F0      		breq .L66
 919:quantum/action.c ****         add_mods(mods);
 783               		.loc 1 919 9 is_stmt 1 view .LVU178
 784 0004 0E94 0000 		call add_mods
 785               	.LVL67:
 920:quantum/action.c ****         send_keyboard_report();
 786               		.loc 1 920 9 view .LVU179
 787 0008 0C94 0000 		jmp send_keyboard_report
 788               	.LVL68:
 789               	.L66:
 790               	/* epilogue start */
 921:quantum/action.c ****     }
 922:quantum/action.c **** }
 791               		.loc 1 922 1 is_stmt 0 view .LVU180
 792 000c 0895      		ret
 793               		.cfi_endproc
 794               	.LFE29:
 796               		.section	.text.unregister_mods,"ax",@progbits
 797               	.global	unregister_mods
 799               	unregister_mods:
 800               	.LVL69:
 801               	.LFB30:
 923:quantum/action.c **** 
 924:quantum/action.c **** /** \brief Removes the given physically pressed modifiers and sends a keyboard report immediately.
 925:quantum/action.c ****  *
 926:quantum/action.c ****  * \param mods A bitfield of modifiers to unregister.
 927:quantum/action.c ****  */
 928:quantum/action.c **** void unregister_mods(uint8_t mods) {
 802               		.loc 1 928 36 is_stmt 1 view -0
 803               		.cfi_startproc
 804               	/* prologue: function */
 805               	/* frame size = 0 */
 806               	/* stack size = 0 */
 807               	.L__stack_usage = 0
 929:quantum/action.c ****     if (mods) {
 808               		.loc 1 929 5 view .LVU182
 809               		.loc 1 929 8 is_stmt 0 view .LVU183
 810 0000 8823      		tst r24
 811 0002 01F0      		breq .L68
 930:quantum/action.c ****         del_mods(mods);
 812               		.loc 1 930 9 is_stmt 1 view .LVU184
 813 0004 0E94 0000 		call del_mods
 814               	.LVL70:
 931:quantum/action.c ****         send_keyboard_report();
 815               		.loc 1 931 9 view .LVU185
 816 0008 0C94 0000 		jmp send_keyboard_report
 817               	.LVL71:
 818               	.L68:
 819               	/* epilogue start */
 932:quantum/action.c ****     }
 933:quantum/action.c **** }
 820               		.loc 1 933 1 is_stmt 0 view .LVU186
 821 000c 0895      		ret
 822               		.cfi_endproc
 823               	.LFE30:
 825               		.section	.text.process_action,"ax",@progbits
 826               	.global	process_action
 828               	process_action:
 829               	.LVL72:
 830               	.LFB24:
 249:quantum/action.c ****     keyevent_t event = record->event;
 831               		.loc 1 249 59 is_stmt 1 view -0
 832               		.cfi_startproc
 249:quantum/action.c ****     keyevent_t event = record->event;
 833               		.loc 1 249 59 is_stmt 0 view .LVU188
 834 0000 4F92      		push r4
 835               	.LCFI10:
 836               		.cfi_def_cfa_offset 3
 837               		.cfi_offset 4, -2
 838 0002 5F92      		push r5
 839               	.LCFI11:
 840               		.cfi_def_cfa_offset 4
 841               		.cfi_offset 5, -3
 842 0004 6F92      		push r6
 843               	.LCFI12:
 844               		.cfi_def_cfa_offset 5
 845               		.cfi_offset 6, -4
 846 0006 7F92      		push r7
 847               	.LCFI13:
 848               		.cfi_def_cfa_offset 6
 849               		.cfi_offset 7, -5
 850 0008 BF92      		push r11
 851               	.LCFI14:
 852               		.cfi_def_cfa_offset 7
 853               		.cfi_offset 11, -6
 854 000a CF92      		push r12
 855               	.LCFI15:
 856               		.cfi_def_cfa_offset 8
 857               		.cfi_offset 12, -7
 858 000c DF92      		push r13
 859               	.LCFI16:
 860               		.cfi_def_cfa_offset 9
 861               		.cfi_offset 13, -8
 862 000e EF92      		push r14
 863               	.LCFI17:
 864               		.cfi_def_cfa_offset 10
 865               		.cfi_offset 14, -9
 866 0010 FF92      		push r15
 867               	.LCFI18:
 868               		.cfi_def_cfa_offset 11
 869               		.cfi_offset 15, -10
 870 0012 0F93      		push r16
 871               	.LCFI19:
 872               		.cfi_def_cfa_offset 12
 873               		.cfi_offset 16, -11
 874 0014 1F93      		push r17
 875               	.LCFI20:
 876               		.cfi_def_cfa_offset 13
 877               		.cfi_offset 17, -12
 878 0016 CF93      		push r28
 879               	.LCFI21:
 880               		.cfi_def_cfa_offset 14
 881               		.cfi_offset 28, -13
 882 0018 DF93      		push r29
 883               	.LCFI22:
 884               		.cfi_def_cfa_offset 15
 885               		.cfi_offset 29, -14
 886               	/* prologue: function */
 887               	/* frame size = 0 */
 888               	/* stack size = 13 */
 889               	.L__stack_usage = 13
 890 001a 6C01      		movw r12,r24
 891 001c C62F      		mov r28,r22
 249:quantum/action.c ****     keyevent_t event = record->event;
 892               		.loc 1 249 59 view .LVU189
 893 001e 172F      		mov r17,r23
 250:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 894               		.loc 1 250 5 is_stmt 1 view .LVU190
 250:quantum/action.c **** #ifndef NO_ACTION_TAPPING
 895               		.loc 1 250 16 is_stmt 0 view .LVU191
 896 0020 FC01      		movw r30,r24
 897 0022 D281      		ldd r29,Z+2
 898               	.LVL73:
 252:quantum/action.c **** #endif
 899               		.loc 1 252 5 is_stmt 1 view .LVU192
 252:quantum/action.c **** #endif
 900               		.loc 1 252 36 is_stmt 0 view .LVU193
 901 0024 0581      		ldd r16,Z+5
 902 0026 0295      		swap r16
 903 0028 0F70      		andi r16,lo8(15)
 904               	.LVL74:
 256:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 905               		.loc 1 256 5 is_stmt 1 view .LVU194
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 906               		.loc 1 258 5 view .LVU195
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 907               		.loc 1 258 9 is_stmt 0 view .LVU196
 908 002a 0E94 0000 		call is_oneshot_layer_active
 909               	.LVL75:
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 910               		.loc 1 258 9 view .LVU197
 911 002e E82E      		mov r14,r24
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 912               		.loc 1 258 8 view .LVU198
 913 0030 8823      		tst r24
 914 0032 01F0      		breq .L71
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 915               		.loc 1 258 35 discriminator 1 view .LVU199
 916 0034 DD23      		tst r29
 917 0036 01F0      		breq .L165
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 918               		.loc 1 258 71 discriminator 2 view .LVU200
 919 0038 812F      		mov r24,r17
 920 003a 807F      		andi r24,lo8(-16)
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 921               		.loc 1 258 52 discriminator 2 view .LVU201
 922 003c 8034      		cpi r24,lo8(64)
 923 003e 01F0      		breq .L72
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 924               		.loc 1 258 87 discriminator 3 view .LVU202
 925 0040 90E2      		ldi r25,lo8(32)
 926               	.LVL76:
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 927               		.loc 1 258 87 discriminator 3 view .LVU203
 928 0042 9C0F      		add r25,r28
 258:quantum/action.c **** #    ifdef SWAP_HANDS_ENABLE
 929               		.loc 1 258 84 discriminator 3 view .LVU204
 930 0044 9830      		cpi r25,lo8(8)
 931 0046 00F0      		brlo .L165
 260:quantum/action.c **** #    endif
 932               		.loc 1 260 9 view .LVU205
 933 0048 8036      		cpi r24,lo8(96)
 934 004a 01F4      		brne .L72
 260:quantum/action.c **** #    endif
 935               		.loc 1 260 12 discriminator 1 view .LVU206
 936 004c C63F      		cpi r28,lo8(-10)
 937 004e 01F0      		breq .L165
 938               	.L72:
 263:quantum/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 939               		.loc 1 263 9 is_stmt 1 view .LVU207
 940 0050 82E0      		ldi r24,lo8(2)
 941 0052 0E94 0000 		call clear_oneshot_layer_state
 942               	.LVL77:
 264:quantum/action.c ****     }
 943               		.loc 1 264 9 view .LVU208
 264:quantum/action.c ****     }
 944               		.loc 1 264 31 is_stmt 0 view .LVU209
 945 0056 0E94 0000 		call is_oneshot_layer_active
 946               	.LVL78:
 264:quantum/action.c ****     }
 947               		.loc 1 264 9 view .LVU210
 948 005a 91E0      		ldi r25,lo8(1)
 949 005c E82E      		mov r14,r24
 950 005e E926      		eor r14,r25
 951               	.LVL79:
 952               	.L71:
 268:quantum/action.c ****         /* Key and Mods */
 953               		.loc 1 268 5 is_stmt 1 view .LVU211
 268:quantum/action.c ****         /* Key and Mods */
 954               		.loc 1 268 24 is_stmt 0 view .LVU212
 955 0060 B12E      		mov r11,r17
 956 0062 B294      		swap r11
 957 0064 9FE0      		ldi r25,lo8(15)
 958 0066 B922      		and r11,r25
 268:quantum/action.c ****         /* Key and Mods */
 959               		.loc 1 268 5 view .LVU213
 960 0068 FBE0      		ldi r31,lo8(11)
 961 006a FB15      		cp r31,r11
 962 006c 00F0      		brlo .L73
 963 006e EB2D      		mov r30,r11
 964 0070 F0E0      		ldi r31,0
 965 0072 E050      		subi r30,lo8(-(gs(.L75)))
 966 0074 F040      		sbci r31,hi8(-(gs(.L75)))
 967 0076 0C94 0000 		jmp __tablejump2__
 968               		.section	.jumptables.gcc.process_action,"a",@progbits
 969               		.p2align	1
 970               	.L75:
 971 0000 0000      		.word gs(.L81)
 972 0002 0000      		.word gs(.L81)
 973 0004 0000      		.word gs(.L80)
 974 0006 0000      		.word gs(.L80)
 975 0008 0000      		.word gs(.L79)
 976 000a 0000      		.word gs(.L73)
 977 000c 0000      		.word gs(.L78)
 978 000e 0000      		.word gs(.L73)
 979 0010 0000      		.word gs(.L77)
 980 0012 0000      		.word gs(.L76)
 981 0014 0000      		.word gs(.L74)
 982 0016 0000      		.word gs(.L74)
 983               		.section	.text.process_action
 984               	.LVL80:
 985               	.L165:
 256:quantum/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 986               		.loc 1 256 10 view .LVU214
 987 007a E12C      		mov r14,__zero_reg__
 988 007c 00C0      		rjmp .L71
 989               	.LVL81:
 990               	.L81:
 991               	.LBB41:
 272:quantum/action.c ****             if (event.pressed) {
 992               		.loc 1 272 13 is_stmt 1 view .LVU215
 993 007e 012F      		mov r16,r17
 994               	.LVL82:
 272:quantum/action.c ****             if (event.pressed) {
 995               		.loc 1 272 13 is_stmt 0 view .LVU216
 996 0080 0F70      		andi r16,lo8(15)
 272:quantum/action.c ****             if (event.pressed) {
 997               		.loc 1 272 44 view .LVU217
 998 0082 812F      		mov r24,r17
 999 0084 807F      		andi r24,lo8(-16)
 272:quantum/action.c ****             if (event.pressed) {
 1000               		.loc 1 272 21 view .LVU218
 1001 0086 01F0      		breq .L82
 272:quantum/action.c ****             if (event.pressed) {
 1002               		.loc 1 272 21 discriminator 2 view .LVU219
 1003 0088 0295      		swap r16
 1004 008a 007F      		andi r16,lo8(-16)
 1005               	.L82:
 1006               	.LVL83:
 273:quantum/action.c ****                 if (mods) {
 1007               		.loc 1 273 13 is_stmt 1 discriminator 4 view .LVU220
 273:quantum/action.c ****                 if (mods) {
 1008               		.loc 1 273 16 is_stmt 0 discriminator 4 view .LVU221
 1009 008c DD23      		tst r29
 1010 008e 01F0      		breq .L83
 274:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1011               		.loc 1 274 17 is_stmt 1 view .LVU222
 274:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1012               		.loc 1 274 20 is_stmt 0 view .LVU223
 1013 0090 0023      		tst r16
 1014 0092 01F0      		breq .L214
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1015               		.loc 1 275 21 is_stmt 1 view .LVU224
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1016               		.loc 1 275 25 is_stmt 0 view .LVU225
 1017 0094 80E2      		ldi r24,lo8(32)
 1018 0096 8C0F      		add r24,r28
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1019               		.loc 1 275 24 view .LVU226
 1020 0098 8830      		cpi r24,lo8(8)
 1021 009a 00F0      		brlo .L85
 275:quantum/action.c ****                         // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would make i
 1022               		.loc 1 275 49 discriminator 1 view .LVU227
 1023 009c C111      		cpse r28,__zero_reg__
 1024 009e 00C0      		rjmp .L86
 1025               	.L85:
 279:quantum/action.c ****                     } else {
 1026               		.loc 1 279 25 is_stmt 1 view .LVU228
 1027 00a0 802F      		mov r24,r16
 1028 00a2 0E94 0000 		call add_mods
 1029               	.LVL84:
 1030               	.L87:
 283:quantum/action.c ****                 }
 1031               		.loc 1 283 21 view .LVU229
 1032 00a6 0E94 0000 		call send_keyboard_report
 1033               	.LVL85:
 285:quantum/action.c ****             } else {
 1034               		.loc 1 285 17 view .LVU230
 1035               	.L214:
 285:quantum/action.c ****             } else {
 1036               		.loc 1 285 17 is_stmt 0 view .LVU231
 1037               	.LBE41:
 653:quantum/action.c ****                         } else {
 1038               		.loc 1 653 29 is_stmt 1 view .LVU232
 1039 00aa 8C2F      		mov r24,r28
 1040 00ac 0E94 0000 		call register_code
 1041               	.LVL86:
 1042 00b0 00C0      		rjmp .L73
 1043               	.LVL87:
 1044               	.L86:
 1045               	.LBB42:
 281:quantum/action.c ****                     }
 1046               		.loc 1 281 25 view .LVU233
 1047 00b2 802F      		mov r24,r16
 1048 00b4 0E94 0000 		call add_weak_mods
 1049               	.LVL88:
 1050 00b8 00C0      		rjmp .L87
 1051               	.L83:
 287:quantum/action.c ****                 if (mods) {
 1052               		.loc 1 287 17 view .LVU234
 1053 00ba 8C2F      		mov r24,r28
 1054 00bc 0E94 0000 		call unregister_code
 1055               	.LVL89:
 288:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1056               		.loc 1 288 17 view .LVU235
 288:quantum/action.c ****                     if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 1057               		.loc 1 288 20 is_stmt 0 view .LVU236
 1058 00c0 0023      		tst r16
 1059 00c2 01F0      		breq .L73
 289:quantum/action.c ****                         del_mods(mods);
 1060               		.loc 1 289 21 is_stmt 1 view .LVU237
 289:quantum/action.c ****                         del_mods(mods);
 1061               		.loc 1 289 25 is_stmt 0 view .LVU238
 1062 00c4 80E2      		ldi r24,lo8(32)
 1063 00c6 8C0F      		add r24,r28
 289:quantum/action.c ****                         del_mods(mods);
 1064               		.loc 1 289 24 view .LVU239
 1065 00c8 8830      		cpi r24,lo8(8)
 1066 00ca 00F0      		brlo .L89
 289:quantum/action.c ****                         del_mods(mods);
 1067               		.loc 1 289 49 discriminator 1 view .LVU240
 1068 00cc C111      		cpse r28,__zero_reg__
 1069 00ce 00C0      		rjmp .L90
 1070               	.L89:
 290:quantum/action.c ****                     } else {
 1071               		.loc 1 290 25 is_stmt 1 view .LVU241
 1072 00d0 802F      		mov r24,r16
 1073 00d2 0E94 0000 		call del_mods
 1074               	.LVL90:
 1075               	.L91:
 294:quantum/action.c ****                 }
 1076               		.loc 1 294 21 view .LVU242
 1077 00d6 0E94 0000 		call send_keyboard_report
 1078               	.LVL91:
 1079               	.L73:
 294:quantum/action.c ****                 }
 1080               		.loc 1 294 21 is_stmt 0 view .LVU243
 1081               	.LBE42:
 679:quantum/action.c ****         case ACT_LAYER:
 1082               		.loc 1 679 5 is_stmt 1 view .LVU244
 1083 00da 2B2D      		mov r18,r11
 1084 00dc 2850      		subi r18,8
 1085 00de 330B      		sbc r19,r19
 1086 00e0 2430      		cpi r18,4
 1087 00e2 3105      		cpc r19,__zero_reg__
 1088 00e4 00F4      		brsh .L157
 686:quantum/action.c ****             break;
 1089               		.loc 1 686 13 view .LVU245
 1090 00e6 0E94 0000 		call host_keyboard_leds
 1091               	.LVL92:
 1092 00ea 0E94 0000 		call led_set
 1093               	.LVL93:
 687:quantum/action.c ****         default:
 1094               		.loc 1 687 13 view .LVU246
 1095               	.L157:
 722:quantum/action.c ****         use_oneshot_swaphands();
 1096               		.loc 1 722 5 view .LVU247
 722:quantum/action.c ****         use_oneshot_swaphands();
 1097               		.loc 1 722 8 is_stmt 0 view .LVU248
 1098 00ee DD23      		tst r29
 1099 00f0 01F0      		breq .L158
 722:quantum/action.c ****         use_oneshot_swaphands();
 1100               		.loc 1 722 43 discriminator 1 view .LVU249
 1101 00f2 107F      		andi r17,lo8(-16)
 1102               	.LVL94:
 722:quantum/action.c ****         use_oneshot_swaphands();
 1103               		.loc 1 722 23 discriminator 1 view .LVU250
 1104 00f4 1036      		cpi r17,lo8(96)
 1105 00f6 01F4      		brne .L159
 722:quantum/action.c ****         use_oneshot_swaphands();
 1106               		.loc 1 722 26 discriminator 2 view .LVU251
 1107 00f8 C63F      		cpi r28,lo8(-10)
 1108 00fa 01F0      		breq .L158
 1109               	.L159:
 723:quantum/action.c ****     }
 1110               		.loc 1 723 9 is_stmt 1 view .LVU252
 1111 00fc 0E94 0000 		call use_oneshot_swaphands
 1112               	.LVL95:
 1113               	.L158:
 732:quantum/action.c ****         record->event.pressed = false;
 1114               		.loc 1 732 5 view .LVU253
 732:quantum/action.c ****         record->event.pressed = false;
 1115               		.loc 1 732 8 is_stmt 0 view .LVU254
 1116 0100 EE20      		tst r14
 1117 0102 01F4      		brne .+2
 1118 0104 00C0      		rjmp .L70
 732:quantum/action.c ****         record->event.pressed = false;
 1119               		.loc 1 732 33 discriminator 1 view .LVU255
 1120 0106 0E94 0000 		call get_oneshot_layer_state
 1121               	.LVL96:
 732:quantum/action.c ****         record->event.pressed = false;
 1122               		.loc 1 732 28 discriminator 1 view .LVU256
 1123 010a 80FD      		sbrc r24,0
 1124 010c 00C0      		rjmp .L70
 733:quantum/action.c ****         layer_on(get_oneshot_layer());
 1125               		.loc 1 733 9 is_stmt 1 view .LVU257
 733:quantum/action.c ****         layer_on(get_oneshot_layer());
 1126               		.loc 1 733 31 is_stmt 0 view .LVU258
 1127 010e F601      		movw r30,r12
 1128 0110 1282      		std Z+2,__zero_reg__
 734:quantum/action.c ****         process_record(record);
 1129               		.loc 1 734 9 is_stmt 1 view .LVU259
 1130 0112 0E94 0000 		call get_oneshot_layer
 1131               	.LVL97:
 1132 0116 0E94 0000 		call layer_on
 1133               	.LVL98:
 735:quantum/action.c ****         layer_off(get_oneshot_layer());
 1134               		.loc 1 735 9 view .LVU260
 1135 011a C601      		movw r24,r12
 1136 011c 0E94 0000 		call process_record
 1137               	.LVL99:
 736:quantum/action.c ****     }
 1138               		.loc 1 736 9 view .LVU261
 1139 0120 0E94 0000 		call get_oneshot_layer
 1140               	.LVL100:
 1141               	/* epilogue start */
 739:quantum/action.c **** 
 1142               		.loc 1 739 1 is_stmt 0 view .LVU262
 1143 0124 DF91      		pop r29
 1144               	.LVL101:
 739:quantum/action.c **** 
 1145               		.loc 1 739 1 view .LVU263
 1146 0126 CF91      		pop r28
 1147               	.LVL102:
 739:quantum/action.c **** 
 1148               		.loc 1 739 1 view .LVU264
 1149 0128 1F91      		pop r17
 739:quantum/action.c **** 
 1150               		.loc 1 739 1 view .LVU265
 1151 012a 0F91      		pop r16
 1152 012c FF90      		pop r15
 1153 012e EF90      		pop r14
 1154               	.LVL103:
 739:quantum/action.c **** 
 1155               		.loc 1 739 1 view .LVU266
 1156 0130 DF90      		pop r13
 1157 0132 CF90      		pop r12
 1158               	.LVL104:
 739:quantum/action.c **** 
 1159               		.loc 1 739 1 view .LVU267
 1160 0134 BF90      		pop r11
 1161 0136 7F90      		pop r7
 1162 0138 6F90      		pop r6
 1163 013a 5F90      		pop r5
 1164 013c 4F90      		pop r4
 736:quantum/action.c ****     }
 1165               		.loc 1 736 9 view .LVU268
 1166 013e 0C94 0000 		jmp layer_off
 1167               	.LVL105:
 1168               	.L90:
 1169               	.LBB43:
 292:quantum/action.c ****                     }
 1170               		.loc 1 292 25 is_stmt 1 view .LVU269
 1171 0142 802F      		mov r24,r16
 1172 0144 0E94 0000 		call del_weak_mods
 1173               	.LVL106:
 1174 0148 00C0      		rjmp .L91
 1175               	.LVL107:
 1176               	.L80:
 292:quantum/action.c ****                     }
 1177               		.loc 1 292 25 is_stmt 0 view .LVU270
 1178               	.LBE43:
 1179               	.LBB44:
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1180               		.loc 1 301 13 is_stmt 1 view .LVU271
 1181 014a 212F      		mov r18,r17
 1182 014c 2F70      		andi r18,lo8(15)
 1183 014e F22E      		mov r15,r18
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1184               		.loc 1 301 44 is_stmt 0 view .LVU272
 1185 0150 812F      		mov r24,r17
 1186 0152 807F      		andi r24,lo8(-16)
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1187               		.loc 1 301 21 view .LVU273
 1188 0154 8032      		cpi r24,lo8(32)
 1189 0156 01F0      		breq .L92
 301:quantum/action.c ****             switch (action.layer_tap.code) {
 1190               		.loc 1 301 21 discriminator 2 view .LVU274
 1191 0158 F294      		swap r15
 1192 015a 80EF      		ldi r24,lo8(-16)
 1193 015c F822      		and r15,r24
 1194               	.L92:
 1195               	.LVL108:
 302:quantum/action.c **** #    ifndef NO_ACTION_ONESHOT
 1196               		.loc 1 302 13 is_stmt 1 discriminator 4 view .LVU275
 1197 015e CC23      		tst r28
 1198 0160 01F0      		breq .L93
 1199 0162 C130      		cpi r28,lo8(1)
 1200 0164 01F0      		breq .L94
 357:quantum/action.c ****                         if (tap_count > 0) {
 1201               		.loc 1 357 21 view .LVU276
 357:quantum/action.c ****                         if (tap_count > 0) {
 1202               		.loc 1 357 24 is_stmt 0 view .LVU277
 1203 0166 DD23      		tst r29
 1204 0168 01F0      		breq .L102
 358:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1205               		.loc 1 358 25 is_stmt 1 view .LVU278
 358:quantum/action.c **** #    if !defined(IGNORE_MOD_TAP_INTERRUPT) || defined(IGNORE_MOD_TAP_INTERRUPT_PER_KEY)
 1206               		.loc 1 358 28 is_stmt 0 view .LVU279
 1207 016a 0023      		tst r16
 1208 016c 01F0      		breq .L103
 360:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1209               		.loc 1 360 29 is_stmt 1 view .LVU280
 364:quantum/action.c ****                                 dprint("mods_tap: tap: cancel: add_mods\n");
 1210               		.loc 1 364 33 is_stmt 0 view .LVU281
 1211 016e F601      		movw r30,r12
 1212 0170 8581      		ldd r24,Z+5
 360:quantum/action.c **** #        ifdef IGNORE_MOD_TAP_INTERRUPT_PER_KEY
 1213               		.loc 1 360 32 view .LVU282
 1214 0172 80FF      		sbrs r24,0
 1215 0174 00C0      		rjmp .L214
 365:quantum/action.c ****                                 // ad hoc: set 0 to cancel tap
 1216               		.loc 1 365 76 is_stmt 1 view .LVU283
 367:quantum/action.c ****                                 register_mods(mods);
 1217               		.loc 1 367 33 view .LVU284
 367:quantum/action.c ****                                 register_mods(mods);
 1218               		.loc 1 367 51 is_stmt 0 view .LVU285
 1219 0176 8F70      		andi r24,lo8(15)
 1220 0178 8583      		std Z+5,r24
 368:quantum/action.c ****                             } else
 1221               		.loc 1 368 33 is_stmt 1 view .LVU286
 1222 017a 00C0      		rjmp .L103
 1223               	.L93:
 306:quantum/action.c ****                         if (tap_count == 0) {
 1224               		.loc 1 306 21 view .LVU287
 306:quantum/action.c ****                         if (tap_count == 0) {
 1225               		.loc 1 306 24 is_stmt 0 view .LVU288
 1226 017c DD23      		tst r29
 1227 017e 01F0      		breq .L96
 307:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1228               		.loc 1 307 25 is_stmt 1 view .LVU289
 307:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: 0\n");
 1229               		.loc 1 307 28 is_stmt 0 view .LVU290
 1230 0180 0111      		cpse r16,__zero_reg__
 1231 0182 00C0      		rjmp .L97
 1232               	.L98:
 321:quantum/action.c ****                         }
 1233               		.loc 1 321 29 is_stmt 1 view .LVU291
 321:quantum/action.c ****                         }
 1234               		.loc 1 321 50 is_stmt 0 view .LVU292
 1235 0184 0E94 0000 		call get_oneshot_mods
 1236               	.LVL109:
 321:quantum/action.c ****                         }
 1237               		.loc 1 321 29 view .LVU293
 1238 0188 8F29      		or r24,r15
 1239               	.LVL110:
 1240               	.L212:
 321:quantum/action.c ****                         }
 1241               		.loc 1 321 29 view .LVU294
 1242               	.LBE44:
 491:quantum/action.c ****             } else {
 1243               		.loc 1 491 17 view .LVU295
 1244 018a 0E94 0000 		call register_mods
 1245               	.LVL111:
 1246 018e 00C0      		rjmp .L73
 1247               	.LVL112:
 1248               	.L97:
 1249               	.LBB47:
 310:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1250               		.loc 1 310 32 is_stmt 1 view .LVU296
 310:quantum/action.c ****                             dprint("MODS_TAP: Oneshot: start\n");
 1251               		.loc 1 310 35 is_stmt 0 view .LVU297
 1252 0190 0130      		cpi r16,lo8(1)
 1253 0192 01F4      		brne .L98
 311:quantum/action.c ****                             set_oneshot_mods(mods | get_oneshot_mods());
 1254               		.loc 1 311 65 is_stmt 1 view .LVU298
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1255               		.loc 1 312 29 view .LVU299
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1256               		.loc 1 312 53 is_stmt 0 view .LVU300
 1257 0194 0E94 0000 		call get_oneshot_mods
 1258               	.LVL113:
 312:quantum/action.c **** #        if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1259               		.loc 1 312 29 view .LVU301
 1260 0198 8F29      		or r24,r15
 1261 019a 0E94 0000 		call set_oneshot_mods
 1262               	.LVL114:
 1263 019e 00C0      		rjmp .L73
 1264               	.L96:
 324:quantum/action.c ****                             clear_oneshot_mods();
 1265               		.loc 1 324 25 is_stmt 1 view .LVU302
 324:quantum/action.c ****                             clear_oneshot_mods();
 1266               		.loc 1 324 28 is_stmt 0 view .LVU303
 1267 01a0 0111      		cpse r16,__zero_reg__
 1268 01a2 00C0      		rjmp .L99
 1269               	.L219:
 339:quantum/action.c ****                             unregister_mods(mods);
 1270               		.loc 1 339 29 is_stmt 1 view .LVU304
 1271 01a4 0E94 0000 		call clear_oneshot_mods
 1272               	.LVL115:
 340:quantum/action.c ****                         }
 1273               		.loc 1 340 29 view .LVU305
 1274               	.L105:
 389:quantum/action.c ****                             unregister_mods(mods);
 1275               		.loc 1 389 67 view .LVU306
 390:quantum/action.c ****                         }
 1276               		.loc 1 390 29 view .LVU307
 1277 01a8 8F2D      		mov r24,r15
 1278 01aa 0E94 0000 		call unregister_mods
 1279               	.LVL116:
 1280 01ae 00C0      		rjmp .L73
 1281               	.L99:
 327:quantum/action.c ****                             // Retain Oneshot mods
 1282               		.loc 1 327 32 view .LVU308
 327:quantum/action.c ****                             // Retain Oneshot mods
 1283               		.loc 1 327 35 is_stmt 0 view .LVU309
 1284 01b0 0130      		cpi r16,lo8(1)
 1285 01b2 01F4      		brne .+2
 1286 01b4 00C0      		rjmp .L73
 1287 01b6 00C0      		rjmp .L219
 1288               	.L94:
 346:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1289               		.loc 1 346 21 is_stmt 1 view .LVU310
 346:quantum/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 1290               		.loc 1 346 24 is_stmt 0 view .LVU311
 1291 01b8 DD23      		tst r29
 1292 01ba 01F0      		breq .L101
 347:quantum/action.c ****                             register_mods(mods);
 1293               		.loc 1 347 25 is_stmt 1 view .LVU312
 347:quantum/action.c ****                             register_mods(mods);
 1294               		.loc 1 347 28 is_stmt 0 view .LVU313
 1295 01bc 0630      		cpi r16,lo8(6)
 1296 01be 00F0      		brlo .+2
 1297 01c0 00C0      		rjmp .L73
 1298               	.L103:
 376:quantum/action.c ****                             register_mods(mods);
 1299               		.loc 1 376 67 is_stmt 1 view .LVU314
 377:quantum/action.c ****                         }
 1300               		.loc 1 377 29 view .LVU315
 1301 01c2 8F2D      		mov r24,r15
 1302 01c4 00C0      		rjmp .L212
 1303               	.L101:
 351:quantum/action.c ****                             unregister_mods(mods);
 1304               		.loc 1 351 25 view .LVU316
 351:quantum/action.c ****                             unregister_mods(mods);
 1305               		.loc 1 351 28 is_stmt 0 view .LVU317
 1306 01c6 0530      		cpi r16,lo8(5)
 1307 01c8 00F0      		brlo .+2
 1308 01ca 00C0      		rjmp .L73
 1309 01cc 00C0      		rjmp .L105
 1310               	.L102:
 380:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1311               		.loc 1 380 25 is_stmt 1 view .LVU318
 380:quantum/action.c ****                             dprint("MODS_TAP: Tap: unregister_code\n");
 1312               		.loc 1 380 28 is_stmt 0 view .LVU319
 1313 01ce 0023      		tst r16
 1314 01d0 01F0      		breq .L105
 381:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1315               		.loc 1 381 71 is_stmt 1 view .LVU320
 382:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1316               		.loc 1 382 29 view .LVU321
 382:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1317               		.loc 1 382 32 is_stmt 0 view .LVU322
 1318 01d2 C933      		cpi r28,lo8(57)
 1319 01d4 01F0      		breq .+2
 1320 01d6 00C0      		rjmp .L140
 383:quantum/action.c ****                             } else {
 1321               		.loc 1 383 33 is_stmt 1 view .LVU323
 383:quantum/action.c ****                             } else {
 1322               		.loc 1 383 33 view .LVU324
 383:quantum/action.c ****                             } else {
 1323               		.loc 1 383 33 view .LVU325
 1324               	.LVL117:
 1325               	.LBB45:
 1326               	.LBI45:
 166:/usr/avr/include/util/delay.h **** {
 1327               		.loc 4 166 1 view .LVU326
 1328               	.LBB46:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1329               		.loc 4 168 2 view .LVU327
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1330               		.loc 4 172 2 view .LVU328
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1331               		.loc 4 173 2 view .LVU329
 174:/usr/avr/include/util/delay.h **** 
 1332               		.loc 4 174 2 view .LVU330
 184:/usr/avr/include/util/delay.h **** 	#endif
 1333               		.loc 4 184 3 view .LVU331
 1334               		.loc 4 187 2 view .LVU332
 1335 01d8 FFEF      		ldi r31,lo8(255999)
 1336 01da 27EE      		ldi r18,hi8(255999)
 1337 01dc 33E0      		ldi r19,hlo8(255999)
 1338 01de F150      	1:	subi r31,1
 1339 01e0 2040      		sbci r18,0
 1340 01e2 3040      		sbci r19,0
 1341 01e4 01F4      		brne 1b
 1342               	.LVL118:
 1343               	.L209:
 1344               		.loc 4 187 2 is_stmt 0 view .LVU333
 1345               	.LBE46:
 1346               	.LBE45:
 1347               	.LBE47:
 1348               	.LBB48:
 1349               	.LBB49:
 1350 01e6 00C0      		rjmp .
 1351 01e8 0000      		nop
 1352               	.LBE49:
 1353               	.LBE48:
 578:quantum/action.c ****                         } else {
 1354               		.loc 1 578 29 is_stmt 1 view .LVU334
 1355 01ea 8C2F      		mov r24,r28
 1356 01ec 0E94 0000 		call unregister_code
 1357               	.LVL119:
 1358 01f0 00C0      		rjmp .L73
 1359               	.L79:
 400:quantum/action.c ****                 case PAGE_SYSTEM:
 1360               		.loc 1 400 13 view .LVU335
 400:quantum/action.c ****                 case PAGE_SYSTEM:
 1361               		.loc 1 400 33 is_stmt 0 view .LVU336
 1362 01f2 812F      		mov r24,r17
 1363 01f4 8695      		lsr r24
 1364 01f6 8695      		lsr r24
 1365 01f8 8370      		andi r24,lo8(3)
 1366 01fa 01F0      		breq .L108
 1367 01fc 8130      		cpi r24,lo8(1)
 1368 01fe 01F0      		breq .+2
 1369 0200 00C0      		rjmp .L73
 409:quantum/action.c ****                         host_consumer_send(action.usage.code);
 1370               		.loc 1 409 21 is_stmt 1 view .LVU337
 410:quantum/action.c ****                     } else {
 1371               		.loc 1 410 25 is_stmt 0 view .LVU338
 1372 0202 8C2F      		mov r24,r28
 1373 0204 912F      		mov r25,r17
 1374 0206 9370      		andi r25,lo8(3)
 409:quantum/action.c ****                         host_consumer_send(action.usage.code);
 1375               		.loc 1 409 24 view .LVU339
 1376 0208 D111      		cpse r29,__zero_reg__
 1377 020a 00C0      		rjmp .L215
 412:quantum/action.c ****                     }
 1378               		.loc 1 412 25 is_stmt 1 view .LVU340
 1379 020c 90E0      		ldi r25,0
 1380 020e 80E0      		ldi r24,0
 1381               	.L215:
 1382 0210 0E94 0000 		call host_consumer_send
 1383               	.LVL120:
 1384 0214 00C0      		rjmp .L73
 1385               	.L108:
 402:quantum/action.c ****                         host_system_send(action.usage.code);
 1386               		.loc 1 402 21 view .LVU341
 403:quantum/action.c ****                     } else {
 1387               		.loc 1 403 25 is_stmt 0 view .LVU342
 1388 0216 8C2F      		mov r24,r28
 1389 0218 912F      		mov r25,r17
 1390 021a 9370      		andi r25,lo8(3)
 402:quantum/action.c ****                         host_system_send(action.usage.code);
 1391               		.loc 1 402 24 view .LVU343
 1392 021c D111      		cpse r29,__zero_reg__
 1393 021e 00C0      		rjmp .L210
 405:quantum/action.c ****                     }
 1394               		.loc 1 405 25 is_stmt 1 view .LVU344
 1395 0220 90E0      		ldi r25,0
 1396 0222 80E0      		ldi r24,0
 1397               	.L210:
 1398 0224 0E94 0000 		call host_system_send
 1399               	.LVL121:
 1400 0228 00C0      		rjmp .L73
 1401               	.L77:
 444:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1402               		.loc 1 444 13 view .LVU345
 444:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1403               		.loc 1 444 39 is_stmt 0 view .LVU346
 1404 022a 812F      		mov r24,r17
 1405 022c 8370      		andi r24,lo8(3)
 444:quantum/action.c ****                 /* Default Layer Bitwise Operation */
 1406               		.loc 1 444 16 view .LVU347
 1407 022e 01F0      		breq .+2
 1408 0230 00C0      		rjmp .L112
 446:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1409               		.loc 1 446 17 is_stmt 1 view .LVU348
 446:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1410               		.loc 1 446 20 is_stmt 0 view .LVU349
 1411 0232 D111      		cpse r29,__zero_reg__
 1412 0234 00C0      		rjmp .L73
 1413               	.LBB51:
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1414               		.loc 1 447 21 is_stmt 1 view .LVU350
 1415               	.LVL122:
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1416               		.loc 1 448 21 view .LVU351
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1417               		.loc 1 447 61 is_stmt 0 view .LVU352
 1418 0236 2C2F      		mov r18,r28
 1419 0238 2295      		swap r18
 1420 023a 2695      		lsr r18
 1421 023c 2770      		andi r18,lo8(7)
 447:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1422               		.loc 1 447 35 view .LVU353
 1423 023e 220F      		lsl r18
 1424 0240 220F      		lsl r18
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1425               		.loc 1 448 77 view .LVU354
 1426 0242 6C2F      		mov r22,r28
 1427 0244 6F70      		andi r22,lo8(15)
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1428               		.loc 1 448 44 view .LVU355
 1429 0246 462E      		mov r4,r22
 1430 0248 512C      		mov r5,__zero_reg__
 1431 024a 712C      		mov r7,__zero_reg__
 1432 024c 612C      		mov r6,__zero_reg__
 448:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1433               		.loc 1 448 35 view .LVU356
 1434 024e 022E      		mov r0,r18
 1435 0250 00C0      		rjmp 2f
 1436               		1:
 1437 0252 440C      		lsl r4
 1438 0254 551C      		rol r5
 1439 0256 661C      		rol r6
 1440 0258 771C      		rol r7
 1441               		2:
 1442 025a 0A94      		dec r0
 1443 025c 02F4      		brpl 1b
 1444               	.LVL123:
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1445               		.loc 1 449 21 is_stmt 1 view .LVU357
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1446               		.loc 1 449 104 is_stmt 0 view .LVU358
 1447 025e 60E0      		ldi r22,0
 1448 0260 70E0      		ldi r23,0
 1449 0262 CB01      		movw r24,r22
 1450 0264 C4FF      		sbrs r28,4
 1451 0266 00C0      		rjmp .L113
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1452               		.loc 1 449 94 discriminator 1 view .LVU359
 1453 0268 6FE0      		ldi r22,lo8(15)
 1454 026a 70E0      		ldi r23,0
 1455 026c 80E0      		ldi r24,0
 1456 026e 90E0      		ldi r25,0
 1457 0270 00C0      		rjmp 2f
 1458               		1:
 1459 0272 660F      		lsl r22
 1460 0274 771F      		rol r23
 1461 0276 881F      		rol r24
 1462 0278 991F      		rol r25
 1463               		2:
 1464 027a 2A95      		dec r18
 1465 027c 02F4      		brpl 1b
 449:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1466               		.loc 1 449 104 discriminator 1 view .LVU360
 1467 027e 6095      		com r22
 1468 0280 7095      		com r23
 1469 0282 8095      		com r24
 1470 0284 9095      		com r25
 1471               	.L113:
 1472               	.LVL124:
 450:quantum/action.c ****                         case OP_BIT_AND:
 1473               		.loc 1 450 21 is_stmt 1 discriminator 4 view .LVU361
 450:quantum/action.c ****                         case OP_BIT_AND:
 1474               		.loc 1 450 47 is_stmt 0 discriminator 4 view .LVU362
 1475 0286 212F      		mov r18,r17
 1476 0288 2695      		lsr r18
 1477 028a 2695      		lsr r18
 1478 028c 2370      		andi r18,lo8(3)
 1479 028e 6429      		or r22,r4
 1480               	.LVL125:
 450:quantum/action.c ****                         case OP_BIT_AND:
 1481               		.loc 1 450 47 discriminator 4 view .LVU363
 1482 0290 7529      		or r23,r5
 1483 0292 8629      		or r24,r6
 1484 0294 9729      		or r25,r7
 1485 0296 2230      		cpi r18,lo8(2)
 1486 0298 01F0      		breq .L114
 1487 029a 00F4      		brsh .L115
 1488 029c 2130      		cpi r18,lo8(1)
 1489 029e 01F0      		breq .L116
 452:quantum/action.c ****                             break;
 1490               		.loc 1 452 29 is_stmt 1 view .LVU364
 1491 02a0 0E94 0000 		call default_layer_and
 1492               	.LVL126:
 453:quantum/action.c ****                         case OP_BIT_OR:
 1493               		.loc 1 453 29 view .LVU365
 1494 02a4 00C0      		rjmp .L73
 1495               	.L116:
 455:quantum/action.c ****                             break;
 1496               		.loc 1 455 29 view .LVU366
 1497 02a6 0E94 0000 		call default_layer_or
 1498               	.LVL127:
 456:quantum/action.c ****                         case OP_BIT_XOR:
 1499               		.loc 1 456 29 view .LVU367
 1500 02aa 00C0      		rjmp .L73
 1501               	.L114:
 458:quantum/action.c ****                             break;
 1502               		.loc 1 458 29 view .LVU368
 1503 02ac 0E94 0000 		call default_layer_xor
 1504               	.LVL128:
 459:quantum/action.c ****                         case OP_BIT_SET:
 1505               		.loc 1 459 29 view .LVU369
 1506 02b0 00C0      		rjmp .L73
 1507               	.L115:
 461:quantum/action.c ****                             break;
 1508               		.loc 1 461 29 view .LVU370
 1509 02b2 0E94 0000 		call default_layer_set
 1510               	.LVL129:
 462:quantum/action.c ****                     }
 1511               		.loc 1 462 29 view .LVU371
 1512 02b6 00C0      		rjmp .L73
 1513               	.LVL130:
 1514               	.L112:
 462:quantum/action.c ****                     }
 1515               		.loc 1 462 29 is_stmt 0 view .LVU372
 1516               	.LBE51:
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1517               		.loc 1 467 17 is_stmt 1 view .LVU373
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1518               		.loc 1 467 21 is_stmt 0 view .LVU374
 1519 02b8 8695      		lsr r24
 1520 02ba DD23      		tst r29
 1521 02bc 01F0      		breq .L118
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1522               		.loc 1 467 21 discriminator 1 view .LVU375
 1523 02be 812F      		mov r24,r17
 1524 02c0 8170      		andi r24,lo8(1)
 1525               	.L118:
 467:quantum/action.c ****                     uint8_t       shift = action.layer_bitop.part * 4;
 1526               		.loc 1 467 20 discriminator 4 view .LVU376
 1527 02c2 8823      		tst r24
 1528 02c4 01F4      		brne .+2
 1529 02c6 00C0      		rjmp .L73
 1530               	.LBB52:
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1531               		.loc 1 468 21 is_stmt 1 view .LVU377
 1532               	.LVL131:
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1533               		.loc 1 469 21 view .LVU378
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1534               		.loc 1 468 61 is_stmt 0 view .LVU379
 1535 02c8 2C2F      		mov r18,r28
 1536 02ca 2295      		swap r18
 1537 02cc 2695      		lsr r18
 1538 02ce 2770      		andi r18,lo8(7)
 468:quantum/action.c ****                     layer_state_t bits  = ((layer_state_t)action.layer_bitop.bits) << shift;
 1539               		.loc 1 468 35 view .LVU380
 1540 02d0 220F      		lsl r18
 1541 02d2 220F      		lsl r18
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1542               		.loc 1 469 77 view .LVU381
 1543 02d4 6C2F      		mov r22,r28
 1544 02d6 6F70      		andi r22,lo8(15)
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1545               		.loc 1 469 44 view .LVU382
 1546 02d8 462E      		mov r4,r22
 1547 02da 512C      		mov r5,__zero_reg__
 1548 02dc 712C      		mov r7,__zero_reg__
 1549 02de 612C      		mov r6,__zero_reg__
 469:quantum/action.c ****                     layer_state_t mask  = (action.layer_bitop.xbit) ? ~(((layer_state_t)0xf) << shi
 1550               		.loc 1 469 35 view .LVU383
 1551 02e0 022E      		mov r0,r18
 1552 02e2 00C0      		rjmp 2f
 1553               		1:
 1554 02e4 440C      		lsl r4
 1555 02e6 551C      		rol r5
 1556 02e8 661C      		rol r6
 1557 02ea 771C      		rol r7
 1558               		2:
 1559 02ec 0A94      		dec r0
 1560 02ee 02F4      		brpl 1b
 1561               	.LVL132:
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1562               		.loc 1 470 21 is_stmt 1 view .LVU384
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1563               		.loc 1 470 104 is_stmt 0 view .LVU385
 1564 02f0 60E0      		ldi r22,0
 1565 02f2 70E0      		ldi r23,0
 1566 02f4 CB01      		movw r24,r22
 1567 02f6 C4FF      		sbrs r28,4
 1568 02f8 00C0      		rjmp .L119
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1569               		.loc 1 470 94 discriminator 1 view .LVU386
 1570 02fa 6FE0      		ldi r22,lo8(15)
 1571 02fc 70E0      		ldi r23,0
 1572 02fe 80E0      		ldi r24,0
 1573 0300 90E0      		ldi r25,0
 1574 0302 00C0      		rjmp 2f
 1575               		1:
 1576 0304 660F      		lsl r22
 1577 0306 771F      		rol r23
 1578 0308 881F      		rol r24
 1579 030a 991F      		rol r25
 1580               		2:
 1581 030c 2A95      		dec r18
 1582 030e 02F4      		brpl 1b
 470:quantum/action.c ****                     switch (action.layer_bitop.op) {
 1583               		.loc 1 470 104 discriminator 1 view .LVU387
 1584 0310 6095      		com r22
 1585 0312 7095      		com r23
 1586 0314 8095      		com r24
 1587 0316 9095      		com r25
 1588               	.L119:
 1589               	.LVL133:
 471:quantum/action.c ****                         case OP_BIT_AND:
 1590               		.loc 1 471 21 is_stmt 1 discriminator 4 view .LVU388
 471:quantum/action.c ****                         case OP_BIT_AND:
 1591               		.loc 1 471 47 is_stmt 0 discriminator 4 view .LVU389
 1592 0318 212F      		mov r18,r17
 1593 031a 2695      		lsr r18
 1594 031c 2695      		lsr r18
 1595 031e 2370      		andi r18,lo8(3)
 1596 0320 6429      		or r22,r4
 1597               	.LVL134:
 471:quantum/action.c ****                         case OP_BIT_AND:
 1598               		.loc 1 471 47 discriminator 4 view .LVU390
 1599 0322 7529      		or r23,r5
 1600 0324 8629      		or r24,r6
 1601 0326 9729      		or r25,r7
 1602 0328 2230      		cpi r18,lo8(2)
 1603 032a 01F0      		breq .L120
 1604 032c 00F4      		brsh .L121
 1605 032e 2130      		cpi r18,lo8(1)
 1606 0330 01F0      		breq .L122
 473:quantum/action.c ****                             break;
 1607               		.loc 1 473 29 is_stmt 1 view .LVU391
 1608 0332 0E94 0000 		call layer_and
 1609               	.LVL135:
 474:quantum/action.c ****                         case OP_BIT_OR:
 1610               		.loc 1 474 29 view .LVU392
 1611 0336 00C0      		rjmp .L73
 1612               	.L122:
 476:quantum/action.c ****                             break;
 1613               		.loc 1 476 29 view .LVU393
 1614 0338 0E94 0000 		call layer_or
 1615               	.LVL136:
 477:quantum/action.c ****                         case OP_BIT_XOR:
 1616               		.loc 1 477 29 view .LVU394
 1617 033c 00C0      		rjmp .L73
 1618               	.L120:
 479:quantum/action.c ****                             break;
 1619               		.loc 1 479 29 view .LVU395
 1620 033e 0E94 0000 		call layer_xor
 1621               	.LVL137:
 480:quantum/action.c ****                         case OP_BIT_SET:
 1622               		.loc 1 480 29 view .LVU396
 1623 0342 00C0      		rjmp .L73
 1624               	.L121:
 482:quantum/action.c ****                             break;
 1625               		.loc 1 482 29 view .LVU397
 1626 0344 0E94 0000 		call layer_state_set
 1627               	.LVL138:
 483:quantum/action.c ****                     }
 1628               		.loc 1 483 29 view .LVU398
 1629 0348 00C0      		rjmp .L73
 1630               	.LVL139:
 1631               	.L76:
 483:quantum/action.c ****                     }
 1632               		.loc 1 483 29 is_stmt 0 view .LVU399
 1633               	.LBE52:
 489:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 1634               		.loc 1 489 13 is_stmt 1 view .LVU400
 1635 034a 012F      		mov r16,r17
 1636               	.LVL140:
 489:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 1637               		.loc 1 489 13 is_stmt 0 view .LVU401
 1638 034c 0F70      		andi r16,lo8(15)
 489:quantum/action.c ****                 layer_on(action.layer_mods.layer);
 1639               		.loc 1 489 16 view .LVU402
 1640 034e DD23      		tst r29
 1641 0350 01F0      		breq .L123
 490:quantum/action.c ****                 register_mods(action.layer_mods.mods);
 1642               		.loc 1 490 17 is_stmt 1 view .LVU403
 1643 0352 802F      		mov r24,r16
 1644 0354 0E94 0000 		call layer_on
 1645               	.LVL141:
 491:quantum/action.c ****             } else {
 1646               		.loc 1 491 17 view .LVU404
 1647 0358 8C2F      		mov r24,r28
 1648 035a 00C0      		rjmp .L212
 1649               	.L123:
 493:quantum/action.c ****                 layer_off(action.layer_mods.layer);
 1650               		.loc 1 493 17 view .LVU405
 1651 035c 8C2F      		mov r24,r28
 1652 035e 0E94 0000 		call unregister_mods
 1653               	.LVL142:
 494:quantum/action.c ****             }
 1654               		.loc 1 494 17 view .LVU406
 1655 0362 802F      		mov r24,r16
 1656               	.L218:
 581:quantum/action.c ****                         }
 1657               		.loc 1 581 29 is_stmt 0 view .LVU407
 1658 0364 0E94 0000 		call layer_off
 1659               	.LVL143:
 1660 0368 00C0      		rjmp .L73
 1661               	.LVL144:
 1662               	.L74:
 500:quantum/action.c ****                 case OP_TAP_TOGGLE:
 1663               		.loc 1 500 13 is_stmt 1 view .LVU408
 1664 036a C23F      		cpi r28,lo8(-14)
 1665 036c 01F0      		breq .L124
 1666 036e 00F4      		brsh .L125
 1667 0370 C03F      		cpi r28,lo8(-16)
 1668 0372 01F0      		breq .L126
 1669 0374 C13F      		cpi r28,lo8(-15)
 1670 0376 01F0      		breq .L127
 1671               	.L128:
 562:quantum/action.c ****                         if (tap_count > 0) {
 1672               		.loc 1 562 21 view .LVU409
 562:quantum/action.c ****                         if (tap_count > 0) {
 1673               		.loc 1 562 24 is_stmt 0 view .LVU410
 1674 0378 DD23      		tst r29
 1675 037a 01F4      		brne .+2
 1676 037c 00C0      		rjmp .L137
 563:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1677               		.loc 1 563 25 is_stmt 1 view .LVU411
 563:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1678               		.loc 1 563 28 is_stmt 0 view .LVU412
 1679 037e 0111      		cpse r16,__zero_reg__
 1680 0380 00C0      		rjmp .L214
 567:quantum/action.c ****                             layer_on(action.layer_tap.val);
 1681               		.loc 1 567 76 is_stmt 1 view .LVU413
 568:quantum/action.c ****                         }
 1682               		.loc 1 568 29 view .LVU414
 1683 0382 812F      		mov r24,r17
 1684 0384 8F71      		andi r24,lo8(31)
 1685 0386 00C0      		rjmp .L216
 1686               	.L125:
 1687 0388 C33F      		cpi r28,lo8(-13)
 1688 038a 01F0      		breq .L129
 1689 038c C43F      		cpi r28,lo8(-12)
 1690 038e 01F4      		brne .L128
 548:quantum/action.c ****                         layer_on(action.layer_tap.val);
 1691               		.loc 1 548 21 view .LVU415
 548:quantum/action.c ****                         layer_on(action.layer_tap.val);
 1692               		.loc 1 548 24 is_stmt 0 view .LVU416
 1693 0390 DD23      		tst r29
 1694 0392 01F0      		breq .L136
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1695               		.loc 1 549 25 is_stmt 1 view .LVU417
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1696               		.loc 1 549 50 is_stmt 0 view .LVU418
 1697 0394 012F      		mov r16,r17
 1698               	.LVL145:
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1699               		.loc 1 549 50 view .LVU419
 1700 0396 0F71      		andi r16,lo8(31)
 549:quantum/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1701               		.loc 1 549 25 view .LVU420
 1702 0398 802F      		mov r24,r16
 1703 039a 0E94 0000 		call layer_on
 1704               	.LVL146:
 550:quantum/action.c ****                     } else {
 1705               		.loc 1 550 25 is_stmt 1 view .LVU421
 1706 039e 63E0      		ldi r22,lo8(3)
 1707 03a0 802F      		mov r24,r16
 1708 03a2 0E94 0000 		call set_oneshot_layer
 1709               	.LVL147:
 1710 03a6 00C0      		rjmp .L73
 1711               	.LVL148:
 1712               	.L126:
 503:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1713               		.loc 1 503 21 view .LVU422
 503:quantum/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1714               		.loc 1 503 24 is_stmt 0 view .LVU423
 1715 03a8 DD23      		tst r29
 1716 03aa 01F0      		breq .L131
 504:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1717               		.loc 1 504 25 is_stmt 1 view .LVU424
 504:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1718               		.loc 1 504 28 is_stmt 0 view .LVU425
 1719 03ac 0530      		cpi r16,lo8(5)
 1720 03ae 00F0      		brlo .+2
 1721 03b0 00C0      		rjmp .L73
 1722               	.L132:
 505:quantum/action.c ****                         }
 1723               		.loc 1 505 29 is_stmt 1 view .LVU426
 1724 03b2 812F      		mov r24,r17
 1725 03b4 8F71      		andi r24,lo8(31)
 1726 03b6 0E94 0000 		call layer_invert
 1727               	.LVL149:
 1728 03ba 00C0      		rjmp .L73
 1729               	.L131:
 508:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1730               		.loc 1 508 25 view .LVU427
 508:quantum/action.c ****                             layer_invert(action.layer_tap.val);
 1731               		.loc 1 508 28 is_stmt 0 view .LVU428
 1732 03bc 0630      		cpi r16,lo8(6)
 1733 03be 00F0      		brlo .+2
 1734 03c0 00C0      		rjmp .L73
 1735 03c2 00C0      		rjmp .L132
 1736               	.L127:
 514:quantum/action.c ****                     break;
 1737               		.loc 1 514 21 is_stmt 1 view .LVU429
 1738 03c4 812F      		mov r24,r17
 1739 03c6 8F71      		andi r24,lo8(31)
 514:quantum/action.c ****                     break;
 1740               		.loc 1 514 68 is_stmt 0 view .LVU430
 1741 03c8 DD23      		tst r29
 1742 03ca 01F0      		breq .L218
 1743               	.L216:
 568:quantum/action.c ****                         }
 1744               		.loc 1 568 29 view .LVU431
 1745 03cc 0E94 0000 		call layer_on
 1746               	.LVL150:
 1747 03d0 00C0      		rjmp .L73
 1748               	.L124:
 517:quantum/action.c ****                     break;
 1749               		.loc 1 517 21 is_stmt 1 view .LVU432
 1750 03d2 812F      		mov r24,r17
 1751 03d4 8F71      		andi r24,lo8(31)
 517:quantum/action.c ****                     break;
 1752               		.loc 1 517 69 is_stmt 0 view .LVU433
 1753 03d6 DD23      		tst r29
 1754 03d8 01F0      		breq .L216
 1755 03da 00C0      		rjmp .L218
 1756               	.L129:
 520:quantum/action.c ****                     break;
 1757               		.loc 1 520 21 is_stmt 1 view .LVU434
 520:quantum/action.c ****                     break;
 1758               		.loc 1 520 70 is_stmt 0 view .LVU435
 1759 03dc DD23      		tst r29
 1760 03de 01F0      		breq .L135
 520:quantum/action.c ****                     break;
 1761               		.loc 1 520 37 discriminator 1 view .LVU436
 1762 03e0 812F      		mov r24,r17
 1763 03e2 8F71      		andi r24,lo8(31)
 1764 03e4 0E94 0000 		call layer_move
 1765               	.LVL151:
 1766 03e8 00C0      		rjmp .L73
 1767               	.L135:
 520:quantum/action.c ****                     break;
 1768               		.loc 1 520 72 discriminator 2 view .LVU437
 1769 03ea 0E94 0000 		call layer_clear
 1770               	.LVL152:
 1771 03ee 00C0      		rjmp .L73
 1772               	.L136:
 552:quantum/action.c ****                         if (tap_count > 1) {
 1773               		.loc 1 552 25 is_stmt 1 view .LVU438
 1774 03f0 81E0      		ldi r24,lo8(1)
 1775 03f2 0E94 0000 		call clear_oneshot_layer_state
 1776               	.LVL153:
 553:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1777               		.loc 1 553 25 view .LVU439
 553:quantum/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1778               		.loc 1 553 28 is_stmt 0 view .LVU440
 1779 03f6 0230      		cpi r16,lo8(2)
 1780 03f8 00F4      		brsh .+2
 1781 03fa 00C0      		rjmp .L73
 554:quantum/action.c ****                         }
 1782               		.loc 1 554 29 is_stmt 1 view .LVU441
 1783 03fc 82E0      		ldi r24,lo8(2)
 1784 03fe 0E94 0000 		call clear_oneshot_layer_state
 1785               	.LVL154:
 1786 0402 00C0      		rjmp .L73
 1787               	.L137:
 571:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1788               		.loc 1 571 25 view .LVU442
 571:quantum/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1789               		.loc 1 571 28 is_stmt 0 view .LVU443
 1790 0404 0023      		tst r16
 1791 0406 01F0      		breq .L139
 572:quantum/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1792               		.loc 1 572 77 is_stmt 1 view .LVU444
 573:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1793               		.loc 1 573 29 view .LVU445
 573:quantum/action.c ****                                 wait_ms(TAP_HOLD_CAPS_DELAY);
 1794               		.loc 1 573 32 is_stmt 0 view .LVU446
 1795 0408 C933      		cpi r28,lo8(57)
 1796 040a 01F4      		brne .L140
 574:quantum/action.c ****                             } else {
 1797               		.loc 1 574 33 is_stmt 1 view .LVU447
 574:quantum/action.c ****                             } else {
 1798               		.loc 1 574 33 view .LVU448
 574:quantum/action.c ****                             } else {
 1799               		.loc 1 574 33 view .LVU449
 1800               	.LVL155:
 1801               	.LBB53:
 1802               	.LBI53:
 166:/usr/avr/include/util/delay.h **** {
 1803               		.loc 4 166 1 view .LVU450
 1804               	.LBB54:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1805               		.loc 4 168 2 view .LVU451
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1806               		.loc 4 172 2 view .LVU452
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1807               		.loc 4 173 2 view .LVU453
 174:/usr/avr/include/util/delay.h **** 
 1808               		.loc 4 174 2 view .LVU454
 184:/usr/avr/include/util/delay.h **** 	#endif
 1809               		.loc 4 184 3 view .LVU455
 1810               		.loc 4 187 2 view .LVU456
 1811 040c 9FEF      		ldi r25,lo8(255999)
 1812 040e E7EE      		ldi r30,hi8(255999)
 1813 0410 F3E0      		ldi r31,hlo8(255999)
 1814 0412 9150      	1:	subi r25,1
 1815 0414 E040      		sbci r30,0
 1816 0416 F040      		sbci r31,0
 1817 0418 01F4      		brne 1b
 1818 041a 00C0      		rjmp .L209
 1819               	.LVL156:
 1820               	.L140:
 1821               		.loc 4 187 2 is_stmt 0 view .LVU457
 1822               	.LBE54:
 1823               	.LBE53:
 576:quantum/action.c ****                             }
 1824               		.loc 1 576 33 is_stmt 1 view .LVU458
 576:quantum/action.c ****                             }
 1825               		.loc 1 576 33 view .LVU459
 576:quantum/action.c ****                             }
 1826               		.loc 1 576 33 view .LVU460
 1827               	.LBB55:
 1828               	.LBI48:
 166:/usr/avr/include/util/delay.h **** {
 1829               		.loc 4 166 1 view .LVU461
 1830               	.LBB50:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1831               		.loc 4 168 2 view .LVU462
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1832               		.loc 4 172 2 view .LVU463
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1833               		.loc 4 173 2 view .LVU464
 174:/usr/avr/include/util/delay.h **** 
 1834               		.loc 4 174 2 view .LVU465
 184:/usr/avr/include/util/delay.h **** 	#endif
 1835               		.loc 4 184 3 view .LVU466
 1836               		.loc 4 187 2 view .LVU467
 1837 041c 8FE3      		ldi r24,lo8(-25537)
 1838 041e 9CE9      		ldi r25,hi8(-25537)
 1839 0420 0197      	1:	sbiw r24,1
 1840 0422 01F4      		brne 1b
 1841 0424 00C0      		rjmp .L209
 1842               	.LVL157:
 1843               	.L139:
 1844               		.loc 4 187 2 is_stmt 0 view .LVU468
 1845               	.LBE50:
 1846               	.LBE55:
 580:quantum/action.c ****                             layer_off(action.layer_tap.val);
 1847               		.loc 1 580 79 is_stmt 1 view .LVU469
 581:quantum/action.c ****                         }
 1848               		.loc 1 581 29 view .LVU470
 1849 0426 812F      		mov r24,r17
 1850 0428 8F71      		andi r24,lo8(31)
 1851 042a 00C0      		rjmp .L218
 1852               	.L78:
 597:quantum/action.c ****                 case OP_SH_TOGGLE:
 1853               		.loc 1 597 13 view .LVU471
 1854 042c E0E1      		ldi r30,lo8(16)
 1855 042e EC0F      		add r30,r28
 1856 0430 E730      		cpi r30,lo8(7)
 1857 0432 00F4      		brsh .L142
 1858 0434 F0E0      		ldi r31,0
 1859 0436 E050      		subi r30,lo8(-(gs(.L144)))
 1860 0438 F040      		sbci r31,hi8(-(gs(.L144)))
 1861 043a 0C94 0000 		jmp __tablejump2__
 1862               		.section	.jumptables.gcc.process_action,"a",@progbits
 1863               		.p2align	1
 1864               	.L144:
 1865 0018 0000      		.word gs(.L150)
 1866 001a 0000      		.word gs(.L149)
 1867 001c 0000      		.word gs(.L148)
 1868 001e 0000      		.word gs(.L147)
 1869 0020 0000      		.word gs(.L146)
 1870 0022 0000      		.word gs(.L145)
 1871 0024 0000      		.word gs(.L143)
 1872               		.section	.text.process_action
 1873               	.L150:
 599:quantum/action.c ****                         swap_hands = !swap_hands;
 1874               		.loc 1 599 21 view .LVU472
 599:quantum/action.c ****                         swap_hands = !swap_hands;
 1875               		.loc 1 599 24 is_stmt 0 view .LVU473
 1876 043e DD23      		tst r29
 1877 0440 01F4      		brne .+2
 1878 0442 00C0      		rjmp .L73
 1879               	.L153:
 600:quantum/action.c ****                     }
 1880               		.loc 1 600 25 is_stmt 1 view .LVU474
 1881 0444 8091 0000 		lds r24,swap_hands
 1882 0448 91E0      		ldi r25,lo8(1)
 1883 044a 8927      		eor r24,r25
 1884               	.L217:
 611:quantum/action.c ****                     }
 1885               		.loc 1 611 36 is_stmt 0 view .LVU475
 1886 044c 8093 0000 		sts swap_hands,r24
 1887 0450 00C0      		rjmp .L73
 1888               	.L148:
 604:quantum/action.c ****                     break;
 1889               		.loc 1 604 21 is_stmt 1 view .LVU476
 604:quantum/action.c ****                     break;
 1890               		.loc 1 604 32 is_stmt 0 view .LVU477
 1891 0452 D093 0000 		sts swap_hands,r29
 605:quantum/action.c ****                 case OP_SH_OFF_ON:
 1892               		.loc 1 605 21 is_stmt 1 view .LVU478
 1893 0456 00C0      		rjmp .L73
 1894               	.L147:
 607:quantum/action.c ****                     break;
 1895               		.loc 1 607 21 view .LVU479
 1896 0458 81E0      		ldi r24,lo8(1)
 1897 045a 8D27      		eor r24,r29
 1898 045c 00C0      		rjmp .L217
 1899               	.L145:
 610:quantum/action.c ****                         swap_hands = true;
 1900               		.loc 1 610 21 view .LVU480
 610:quantum/action.c ****                         swap_hands = true;
 1901               		.loc 1 610 24 is_stmt 0 view .LVU481
 1902 045e D111      		cpse r29,__zero_reg__
 1903 0460 00C0      		rjmp .L73
 611:quantum/action.c ****                     }
 1904               		.loc 1 611 25 is_stmt 1 view .LVU482
 611:quantum/action.c ****                     }
 1905               		.loc 1 611 36 is_stmt 0 view .LVU483
 1906 0462 81E0      		ldi r24,lo8(1)
 1907 0464 00C0      		rjmp .L217
 1908               	.L146:
 615:quantum/action.c ****                         swap_hands = false;
 1909               		.loc 1 615 21 is_stmt 1 view .LVU484
 615:quantum/action.c ****                         swap_hands = false;
 1910               		.loc 1 615 24 is_stmt 0 view .LVU485
 1911 0466 D111      		cpse r29,__zero_reg__
 1912 0468 00C0      		rjmp .L73
 616:quantum/action.c ****                     }
 1913               		.loc 1 616 25 is_stmt 1 view .LVU486
 616:quantum/action.c ****                     }
 1914               		.loc 1 616 36 is_stmt 0 view .LVU487
 1915 046a 1092 0000 		sts swap_hands,__zero_reg__
 1916 046e 00C0      		rjmp .L73
 1917               	.L143:
 621:quantum/action.c ****                         set_oneshot_swaphands();
 1918               		.loc 1 621 21 is_stmt 1 view .LVU488
 621:quantum/action.c ****                         set_oneshot_swaphands();
 1919               		.loc 1 621 24 is_stmt 0 view .LVU489
 1920 0470 DD23      		tst r29
 1921 0472 01F0      		breq .L151
 622:quantum/action.c ****                     } else {
 1922               		.loc 1 622 25 is_stmt 1 view .LVU490
 1923 0474 0E94 0000 		call set_oneshot_swaphands
 1924               	.LVL158:
 1925 0478 00C0      		rjmp .L73
 1926               	.L151:
 624:quantum/action.c ****                     }
 1927               		.loc 1 624 25 view .LVU491
 1928 047a 0E94 0000 		call release_oneshot_swaphands
 1929               	.LVL159:
 1930 047e 00C0      		rjmp .L73
 1931               	.L149:
 633:quantum/action.c ****                         if (swap_held) {
 1932               		.loc 1 633 21 view .LVU492
 633:quantum/action.c ****                         if (swap_held) {
 1933               		.loc 1 633 24 is_stmt 0 view .LVU493
 1934 0480 DD23      		tst r29
 1935 0482 01F0      		breq .L152
 634:quantum/action.c ****                             swap_held = false;
 1936               		.loc 1 634 25 is_stmt 1 view .LVU494
 634:quantum/action.c ****                             swap_held = false;
 1937               		.loc 1 634 28 is_stmt 0 view .LVU495
 1938 0484 8091 0000 		lds r24,swap_held
 1939 0488 8823      		tst r24
 1940 048a 01F0      		breq .L153
 1941               	.L211:
 662:quantum/action.c ****                         }
 1942               		.loc 1 662 29 is_stmt 1 view .LVU496
 662:quantum/action.c ****                         }
 1943               		.loc 1 662 40 is_stmt 0 view .LVU497
 1944 048c 1092 0000 		sts swap_held,__zero_reg__
 1945 0490 00C0      		rjmp .L73
 1946               	.L152:
 640:quantum/action.c ****                             swap_hands = !swap_hands;
 1947               		.loc 1 640 25 is_stmt 1 view .LVU498
 640:quantum/action.c ****                             swap_hands = !swap_hands;
 1948               		.loc 1 640 28 is_stmt 0 view .LVU499
 1949 0492 0530      		cpi r16,lo8(5)
 1950 0494 00F0      		brlo .L153
 1951 0496 00C0      		rjmp .L73
 1952               	.L142:
 647:quantum/action.c ****                         if (swap_held) {
 1953               		.loc 1 647 21 is_stmt 1 view .LVU500
 1954 0498 8091 0000 		lds r24,swap_held
 647:quantum/action.c ****                         if (swap_held) {
 1955               		.loc 1 647 24 is_stmt 0 view .LVU501
 1956 049c 0023      		tst r16
 1957 049e 01F0      		breq .L154
 648:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 1958               		.loc 1 648 25 is_stmt 1 view .LVU502
 648:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 1959               		.loc 1 648 28 is_stmt 0 view .LVU503
 1960 04a0 8823      		tst r24
 1961 04a2 01F0      		breq .L155
 649:quantum/action.c ****                             swap_held  = false;
 1962               		.loc 1 649 29 is_stmt 1 view .LVU504
 1963 04a4 8091 0000 		lds r24,swap_hands
 1964 04a8 91E0      		ldi r25,lo8(1)
 1965 04aa 8927      		eor r24,r25
 649:quantum/action.c ****                             swap_held  = false;
 1966               		.loc 1 649 40 is_stmt 0 view .LVU505
 1967 04ac 8093 0000 		sts swap_hands,r24
 650:quantum/action.c ****                         }
 1968               		.loc 1 650 29 is_stmt 1 view .LVU506
 650:quantum/action.c ****                         }
 1969               		.loc 1 650 40 is_stmt 0 view .LVU507
 1970 04b0 1092 0000 		sts swap_held,__zero_reg__
 1971               	.L155:
 652:quantum/action.c ****                             register_code(action.swap.code);
 1972               		.loc 1 652 25 is_stmt 1 view .LVU508
 652:quantum/action.c ****                             register_code(action.swap.code);
 1973               		.loc 1 652 28 is_stmt 0 view .LVU509
 1974 04b4 D111      		cpse r29,__zero_reg__
 1975 04b6 00C0      		rjmp .L214
 655:quantum/action.c ****                             unregister_code(action.swap.code);
 1976               		.loc 1 655 29 is_stmt 1 view .LVU510
 655:quantum/action.c ****                             unregister_code(action.swap.code);
 1977               		.loc 1 655 29 view .LVU511
 655:quantum/action.c ****                             unregister_code(action.swap.code);
 1978               		.loc 1 655 29 view .LVU512
 1979               	.LVL160:
 1980               	.LBB56:
 1981               	.LBI56:
 166:/usr/avr/include/util/delay.h **** {
 1982               		.loc 4 166 1 view .LVU513
 1983               	.LBB57:
 168:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1984               		.loc 4 168 2 view .LVU514
 172:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1985               		.loc 4 172 2 view .LVU515
 173:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1986               		.loc 4 173 2 view .LVU516
 174:/usr/avr/include/util/delay.h **** 
 1987               		.loc 4 174 2 view .LVU517
 184:/usr/avr/include/util/delay.h **** 	#endif
 1988               		.loc 4 184 3 view .LVU518
 1989               		.loc 4 187 2 view .LVU519
 1990 04b8 EFE3      		ldi r30,lo8(-25537)
 1991 04ba FCE9      		ldi r31,hi8(-25537)
 1992 04bc 3197      	1:	sbiw r30,1
 1993 04be 01F4      		brne 1b
 1994 04c0 00C0      		rjmp .
 1995 04c2 0000      		nop
 1996               	.LVL161:
 1997               		.loc 4 187 2 is_stmt 0 view .LVU520
 1998               	.LBE57:
 1999               	.LBE56:
 656:quantum/action.c ****                             *record = (keyrecord_t){};  // hack: reset tap mode
 2000               		.loc 1 656 29 is_stmt 1 view .LVU521
 2001 04c4 8C2F      		mov r24,r28
 2002 04c6 0E94 0000 		call unregister_code
 2003               	.LVL162:
 657:quantum/action.c ****                         }
 2004               		.loc 1 657 29 view .LVU522
 657:quantum/action.c ****                         }
 2005               		.loc 1 657 37 is_stmt 0 view .LVU523
 2006 04ca 86E0      		ldi r24,lo8(6)
 2007 04cc F601      		movw r30,r12
 2008               		0:
 2009 04ce 1192      		st Z+,__zero_reg__
 2010 04d0 8A95      		dec r24
 2011 04d2 01F4      		brne 0b
 2012 04d4 00C0      		rjmp .L73
 2013               	.L154:
 660:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2014               		.loc 1 660 25 is_stmt 1 view .LVU524
 660:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2015               		.loc 1 660 28 is_stmt 0 view .LVU525
 2016 04d6 8823      		tst r24
 2017 04d8 01F4      		brne .+2
 2018 04da 00C0      		rjmp .L73
 660:quantum/action.c ****                             swap_hands = !swap_hands;  // undo hold set up in _tap_hint
 2019               		.loc 1 660 39 discriminator 1 view .LVU526
 2020 04dc D111      		cpse r29,__zero_reg__
 2021 04de 00C0      		rjmp .L73
 661:quantum/action.c ****                             swap_held  = false;
 2022               		.loc 1 661 29 is_stmt 1 view .LVU527
 2023 04e0 8091 0000 		lds r24,swap_hands
 2024 04e4 91E0      		ldi r25,lo8(1)
 2025 04e6 8927      		eor r24,r25
 661:quantum/action.c ****                             swap_held  = false;
 2026               		.loc 1 661 40 is_stmt 0 view .LVU528
 2027 04e8 8093 0000 		sts swap_hands,r24
 2028 04ec 00C0      		rjmp .L211
 2029               	.LVL163:
 2030               	.L70:
 2031               	/* epilogue start */
 739:quantum/action.c **** 
 2032               		.loc 1 739 1 view .LVU529
 2033 04ee DF91      		pop r29
 2034               	.LVL164:
 739:quantum/action.c **** 
 2035               		.loc 1 739 1 view .LVU530
 2036 04f0 CF91      		pop r28
 2037               	.LVL165:
 739:quantum/action.c **** 
 2038               		.loc 1 739 1 view .LVU531
 2039 04f2 1F91      		pop r17
 739:quantum/action.c **** 
 2040               		.loc 1 739 1 view .LVU532
 2041 04f4 0F91      		pop r16
 2042 04f6 FF90      		pop r15
 2043 04f8 EF90      		pop r14
 2044               	.LVL166:
 739:quantum/action.c **** 
 2045               		.loc 1 739 1 view .LVU533
 2046 04fa DF90      		pop r13
 2047 04fc CF90      		pop r12
 2048               	.LVL167:
 739:quantum/action.c **** 
 2049               		.loc 1 739 1 view .LVU534
 2050 04fe BF90      		pop r11
 2051 0500 7F90      		pop r7
 2052 0502 6F90      		pop r6
 2053 0504 5F90      		pop r5
 2054 0506 4F90      		pop r4
 2055 0508 0895      		ret
 2056               		.cfi_endproc
 2057               	.LFE24:
 2059               		.section	.text.process_record_handler,"ax",@progbits
 2060               	.global	process_record_handler
 2062               	process_record_handler:
 2063               	.LVL168:
 2064               	.LFB23:
 208:quantum/action.c **** #ifdef COMBO_ENABLE
 2065               		.loc 1 208 50 is_stmt 1 view -0
 2066               		.cfi_startproc
 208:quantum/action.c **** #ifdef COMBO_ENABLE
 2067               		.loc 1 208 50 is_stmt 0 view .LVU536
 2068 0000 0F93      		push r16
 2069               	.LCFI23:
 2070               		.cfi_def_cfa_offset 3
 2071               		.cfi_offset 16, -2
 2072 0002 1F93      		push r17
 2073               	.LCFI24:
 2074               		.cfi_def_cfa_offset 4
 2075               		.cfi_offset 17, -3
 2076 0004 CF93      		push r28
 2077               	.LCFI25:
 2078               		.cfi_def_cfa_offset 5
 2079               		.cfi_offset 28, -4
 2080 0006 DF93      		push r29
 2081               	.LCFI26:
 2082               		.cfi_def_cfa_offset 6
 2083               		.cfi_offset 29, -5
 2084               	/* prologue: function */
 2085               	/* frame size = 0 */
 2086               	/* stack size = 4 */
 2087               	.L__stack_usage = 4
 2088 0008 EC01      		movw r28,r24
 217:quantum/action.c **** #endif
 2089               		.loc 1 217 5 is_stmt 1 view .LVU537
 217:quantum/action.c **** #endif
 2090               		.loc 1 217 23 is_stmt 0 view .LVU538
 2091 000a 6881      		ld r22,Y
 2092 000c 7981      		ldd r23,Y+1
 2093 000e 8A81      		ldd r24,Y+2
 2094               	.LVL169:
 217:quantum/action.c **** #endif
 2095               		.loc 1 217 23 view .LVU539
 2096 0010 0E94 0000 		call store_or_get_action
 2097               	.LVL170:
 2098 0014 8C01      		movw r16,r24
 2099               	.LVL171:
 219:quantum/action.c ****     debug_action(action);
 2100               		.loc 1 219 23 is_stmt 1 view .LVU540
 220:quantum/action.c **** #ifndef NO_ACTION_LAYER
 2101               		.loc 1 220 5 view .LVU541
 222:quantum/action.c ****     layer_debug();
 2102               		.loc 1 222 29 view .LVU542
 223:quantum/action.c ****     dprint(" default_layer_state: ");
 2103               		.loc 1 223 5 view .LVU543
 2104 0016 0E94 0000 		call layer_debug
 2105               	.LVL172:
 224:quantum/action.c ****     default_layer_debug();
 2106               		.loc 1 224 37 view .LVU544
 225:quantum/action.c **** #endif
 2107               		.loc 1 225 5 view .LVU545
 2108 001a 0E94 0000 		call default_layer_debug
 2109               	.LVL173:
 227:quantum/action.c **** 
 2110               		.loc 1 227 15 view .LVU546
 229:quantum/action.c **** }
 2111               		.loc 1 229 5 view .LVU547
 229:quantum/action.c **** }
 2112               		.loc 1 229 5 is_stmt 0 view .LVU548
 2113 001e B801      		movw r22,r16
 2114 0020 CE01      		movw r24,r28
 2115               	/* epilogue start */
 230:quantum/action.c **** 
 2116               		.loc 1 230 1 view .LVU549
 2117 0022 DF91      		pop r29
 2118 0024 CF91      		pop r28
 2119               	.LVL174:
 230:quantum/action.c **** 
 2120               		.loc 1 230 1 view .LVU550
 2121 0026 1F91      		pop r17
 2122 0028 0F91      		pop r16
 2123               	.LVL175:
 229:quantum/action.c **** }
 2124               		.loc 1 229 5 view .LVU551
 2125 002a 0C94 0000 		jmp process_action
 2126               	.LVL176:
 229:quantum/action.c **** }
 2127               		.loc 1 229 5 view .LVU552
 2128               		.cfi_endproc
 2129               	.LFE23:
 2131               		.section	.text.process_record,"ax",@progbits
 2132               	.global	process_record
 2134               	process_record:
 2135               	.LVL177:
 2136               	.LFB22:
 190:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 2137               		.loc 1 190 42 is_stmt 1 view -0
 2138               		.cfi_startproc
 190:quantum/action.c ****     if (IS_NOEVENT(record->event)) {
 2139               		.loc 1 190 42 is_stmt 0 view .LVU554
 2140 0000 CF93      		push r28
 2141               	.LCFI27:
 2142               		.cfi_def_cfa_offset 3
 2143               		.cfi_offset 28, -2
 2144 0002 DF93      		push r29
 2145               	.LCFI28:
 2146               		.cfi_def_cfa_offset 4
 2147               		.cfi_offset 29, -3
 2148               	/* prologue: function */
 2149               	/* frame size = 0 */
 2150               	/* stack size = 2 */
 2151               	.L__stack_usage = 2
 2152 0004 EC01      		movw r28,r24
 191:quantum/action.c ****         return;
 2153               		.loc 1 191 5 is_stmt 1 view .LVU555
 2154               	.LBB60:
 2155               	.LBI60:
 2156               		.loc 2 47 20 view .LVU556
 2157               	.LBB61:
 2158               		.loc 2 47 51 view .LVU557
 2159               		.loc 2 47 74 is_stmt 0 view .LVU558
 2160 0006 8B81      		ldd r24,Y+3
 2161 0008 9C81      		ldd r25,Y+4
 2162               	.LVL178:
 2163               		.loc 2 47 74 view .LVU559
 2164 000a 892B      		or r24,r25
 2165 000c 01F0      		breq .L221
 2166 000e 8881      		ld r24,Y
 2167 0010 9981      		ldd r25,Y+1
 2168 0012 8923      		and r24,r25
 2169 0014 8F3F      		cpi r24,lo8(-1)
 2170 0016 01F4      		brne .L237
 2171               	.L221:
 2172               	/* epilogue start */
 2173               	.LBE61:
 2174               	.LBE60:
 206:quantum/action.c **** 
 2175               		.loc 1 206 1 view .LVU560
 2176 0018 DF91      		pop r29
 2177 001a CF91      		pop r28
 2178               	.LVL179:
 206:quantum/action.c **** 
 2179               		.loc 1 206 1 view .LVU561
 2180 001c 0895      		ret
 2181               	.LVL180:
 2182               	.L226:
 204:quantum/action.c ****     post_process_record_quantum(record);
 2183               		.loc 1 204 5 is_stmt 1 view .LVU562
 2184 001e CE01      		movw r24,r28
 2185 0020 0E94 0000 		call process_record_handler
 2186               	.LVL181:
 205:quantum/action.c **** }
 2187               		.loc 1 205 5 view .LVU563
 2188 0024 CE01      		movw r24,r28
 2189               	/* epilogue start */
 206:quantum/action.c **** 
 2190               		.loc 1 206 1 is_stmt 0 view .LVU564
 2191 0026 DF91      		pop r29
 2192 0028 CF91      		pop r28
 2193               	.LVL182:
 205:quantum/action.c **** }
 2194               		.loc 1 205 5 view .LVU565
 2195 002a 0C94 0000 		jmp post_process_record_quantum
 2196               	.LVL183:
 2197               	.L237:
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 2198               		.loc 1 195 5 is_stmt 1 view .LVU566
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 2199               		.loc 1 195 10 is_stmt 0 view .LVU567
 2200 002e CE01      		movw r24,r28
 2201 0030 0E94 0000 		call process_record_quantum
 2202               	.LVL184:
 195:quantum/action.c **** #ifndef NO_ACTION_ONESHOT
 2203               		.loc 1 195 8 view .LVU568
 2204 0034 8111      		cpse r24,__zero_reg__
 2205 0036 00C0      		rjmp .L226
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2206               		.loc 1 197 9 is_stmt 1 view .LVU569
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2207               		.loc 1 197 13 is_stmt 0 view .LVU570
 2208 0038 0E94 0000 		call is_oneshot_layer_active
 2209               	.LVL185:
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2210               		.loc 1 197 12 view .LVU571
 2211 003c 8823      		tst r24
 2212 003e 01F0      		breq .L221
 197:quantum/action.c ****             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 2213               		.loc 1 197 39 discriminator 1 view .LVU572
 2214 0040 8A81      		ldd r24,Y+2
 2215 0042 8823      		tst r24
 2216 0044 01F0      		breq .L221
 198:quantum/action.c ****         }
 2217               		.loc 1 198 13 is_stmt 1 view .LVU573
 2218 0046 82E0      		ldi r24,lo8(2)
 2219               	/* epilogue start */
 206:quantum/action.c **** 
 2220               		.loc 1 206 1 is_stmt 0 view .LVU574
 2221 0048 DF91      		pop r29
 2222 004a CF91      		pop r28
 2223               	.LVL186:
 198:quantum/action.c ****         }
 2224               		.loc 1 198 13 view .LVU575
 2225 004c 0C94 0000 		jmp clear_oneshot_layer_state
 2226               	.LVL187:
 2227               		.cfi_endproc
 2228               	.LFE22:
 2230               		.section	.text.process_record_nocache,"ax",@progbits
 2231               	.global	process_record_nocache
 2233               	process_record_nocache:
 2234               	.LVL188:
 2235               	.LFB18:
 148:quantum/action.c ****     disable_action_cache = true;
 2236               		.loc 1 148 50 is_stmt 1 view -0
 2237               		.cfi_startproc
 2238               	/* prologue: function */
 2239               	/* frame size = 0 */
 2240               	/* stack size = 0 */
 2241               	.L__stack_usage = 0
 149:quantum/action.c ****     process_record(record);
 2242               		.loc 1 149 5 view .LVU577
 149:quantum/action.c ****     process_record(record);
 2243               		.loc 1 149 26 is_stmt 0 view .LVU578
 2244 0000 21E0      		ldi r18,lo8(1)
 2245 0002 2093 0000 		sts disable_action_cache,r18
 150:quantum/action.c ****     disable_action_cache = false;
 2246               		.loc 1 150 5 is_stmt 1 view .LVU579
 2247 0006 0E94 0000 		call process_record
 2248               	.LVL189:
 151:quantum/action.c **** }
 2249               		.loc 1 151 5 view .LVU580
 151:quantum/action.c **** }
 2250               		.loc 1 151 26 is_stmt 0 view .LVU581
 2251 000a 1092 0000 		sts disable_action_cache,__zero_reg__
 2252               	/* epilogue start */
 152:quantum/action.c **** #else
 2253               		.loc 1 152 1 view .LVU582
 2254 000e 0895      		ret
 2255               		.cfi_endproc
 2256               	.LFE18:
 2258               		.section	.text.register_weak_mods,"ax",@progbits
 2259               	.global	register_weak_mods
 2261               	register_weak_mods:
 2262               	.LVL190:
 2263               	.LFB31:
 934:quantum/action.c **** 
 935:quantum/action.c **** /** \brief Adds the given weak modifiers and sends a keyboard report immediately.
 936:quantum/action.c ****  *
 937:quantum/action.c ****  * \param mods A bitfield of modifiers to register.
 938:quantum/action.c ****  */
 939:quantum/action.c **** void register_weak_mods(uint8_t mods) {
 2264               		.loc 1 939 39 is_stmt 1 view -0
 2265               		.cfi_startproc
 2266               	/* prologue: function */
 2267               	/* frame size = 0 */
 2268               	/* stack size = 0 */
 2269               	.L__stack_usage = 0
 940:quantum/action.c ****     if (mods) {
 2270               		.loc 1 940 5 view .LVU584
 2271               		.loc 1 940 8 is_stmt 0 view .LVU585
 2272 0000 8823      		tst r24
 2273 0002 01F0      		breq .L240
 941:quantum/action.c ****         add_weak_mods(mods);
 2274               		.loc 1 941 9 is_stmt 1 view .LVU586
 2275 0004 0E94 0000 		call add_weak_mods
 2276               	.LVL191:
 942:quantum/action.c ****         send_keyboard_report();
 2277               		.loc 1 942 9 view .LVU587
 2278 0008 0C94 0000 		jmp send_keyboard_report
 2279               	.LVL192:
 2280               	.L240:
 2281               	/* epilogue start */
 943:quantum/action.c ****     }
 944:quantum/action.c **** }
 2282               		.loc 1 944 1 is_stmt 0 view .LVU588
 2283 000c 0895      		ret
 2284               		.cfi_endproc
 2285               	.LFE31:
 2287               		.section	.text.unregister_weak_mods,"ax",@progbits
 2288               	.global	unregister_weak_mods
 2290               	unregister_weak_mods:
 2291               	.LVL193:
 2292               	.LFB32:
 945:quantum/action.c **** 
 946:quantum/action.c **** /** \brief Removes the given weak modifiers and sends a keyboard report immediately.
 947:quantum/action.c ****  *
 948:quantum/action.c ****  * \param mods A bitfield of modifiers to unregister.
 949:quantum/action.c ****  */
 950:quantum/action.c **** void unregister_weak_mods(uint8_t mods) {
 2293               		.loc 1 950 41 is_stmt 1 view -0
 2294               		.cfi_startproc
 2295               	/* prologue: function */
 2296               	/* frame size = 0 */
 2297               	/* stack size = 0 */
 2298               	.L__stack_usage = 0
 951:quantum/action.c ****     if (mods) {
 2299               		.loc 1 951 5 view .LVU590
 2300               		.loc 1 951 8 is_stmt 0 view .LVU591
 2301 0000 8823      		tst r24
 2302 0002 01F0      		breq .L242
 952:quantum/action.c ****         del_weak_mods(mods);
 2303               		.loc 1 952 9 is_stmt 1 view .LVU592
 2304 0004 0E94 0000 		call del_weak_mods
 2305               	.LVL194:
 953:quantum/action.c ****         send_keyboard_report();
 2306               		.loc 1 953 9 view .LVU593
 2307 0008 0C94 0000 		jmp send_keyboard_report
 2308               	.LVL195:
 2309               	.L242:
 2310               	/* epilogue start */
 954:quantum/action.c ****     }
 955:quantum/action.c **** }
 2311               		.loc 1 955 1 is_stmt 0 view .LVU594
 2312 000c 0895      		ret
 2313               		.cfi_endproc
 2314               	.LFE32:
 2316               		.section	.text.clear_keyboard_but_mods_and_keys,"ax",@progbits
 2317               	.global	clear_keyboard_but_mods_and_keys
 2319               	clear_keyboard_but_mods_and_keys:
 2320               	.LFB35:
 956:quantum/action.c **** 
 957:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 958:quantum/action.c ****  *
 959:quantum/action.c ****  * FIXME: Needs documentation.
 960:quantum/action.c ****  */
 961:quantum/action.c **** void clear_keyboard(void) {
 962:quantum/action.c ****     clear_mods();
 963:quantum/action.c ****     clear_keyboard_but_mods();
 964:quantum/action.c **** }
 965:quantum/action.c **** 
 966:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 967:quantum/action.c ****  *
 968:quantum/action.c ****  * FIXME: Needs documentation.
 969:quantum/action.c ****  */
 970:quantum/action.c **** void clear_keyboard_but_mods(void) {
 971:quantum/action.c ****     clear_keys();
 972:quantum/action.c ****     clear_keyboard_but_mods_and_keys();
 973:quantum/action.c **** }
 974:quantum/action.c **** 
 975:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 976:quantum/action.c ****  *
 977:quantum/action.c ****  * FIXME: Needs documentation.
 978:quantum/action.c ****  */
 979:quantum/action.c **** void clear_keyboard_but_mods_and_keys() {
 2321               		.loc 1 979 41 is_stmt 1 view -0
 2322               		.cfi_startproc
 2323               	/* prologue: function */
 2324               	/* frame size = 0 */
 2325               	/* stack size = 0 */
 2326               	.L__stack_usage = 0
 980:quantum/action.c **** #ifdef EXTRAKEY_ENABLE
 981:quantum/action.c ****     host_system_send(0);
 2327               		.loc 1 981 5 view .LVU596
 2328 0000 90E0      		ldi r25,0
 2329 0002 80E0      		ldi r24,0
 2330 0004 0E94 0000 		call host_system_send
 2331               	.LVL196:
 982:quantum/action.c ****     host_consumer_send(0);
 2332               		.loc 1 982 5 view .LVU597
 2333 0008 90E0      		ldi r25,0
 2334 000a 80E0      		ldi r24,0
 2335 000c 0E94 0000 		call host_consumer_send
 2336               	.LVL197:
 983:quantum/action.c **** #endif
 984:quantum/action.c ****     clear_weak_mods();
 2337               		.loc 1 984 5 view .LVU598
 2338 0010 0E94 0000 		call clear_weak_mods
 2339               	.LVL198:
 985:quantum/action.c ****     clear_macro_mods();
 2340               		.loc 1 985 5 view .LVU599
 2341 0014 0E94 0000 		call clear_macro_mods
 2342               	.LVL199:
 986:quantum/action.c ****     send_keyboard_report();
 2343               		.loc 1 986 5 view .LVU600
 2344 0018 0C94 0000 		jmp send_keyboard_report
 2345               	.LVL200:
 2346               		.cfi_endproc
 2347               	.LFE35:
 2349               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2350               	.global	clear_keyboard_but_mods
 2352               	clear_keyboard_but_mods:
 2353               	.LFB34:
 970:quantum/action.c ****     clear_keys();
 2354               		.loc 1 970 36 view -0
 2355               		.cfi_startproc
 2356               	/* prologue: function */
 2357               	/* frame size = 0 */
 2358               	/* stack size = 0 */
 2359               	.L__stack_usage = 0
 971:quantum/action.c ****     clear_keyboard_but_mods_and_keys();
 2360               		.loc 1 971 5 view .LVU602
 2361 0000 0E94 0000 		call clear_keys
 2362               	.LVL201:
 972:quantum/action.c **** }
 2363               		.loc 1 972 5 view .LVU603
 2364 0004 0C94 0000 		jmp clear_keyboard_but_mods_and_keys
 2365               	.LVL202:
 2366               		.cfi_endproc
 2367               	.LFE34:
 2369               		.section	.text.clear_keyboard,"ax",@progbits
 2370               	.global	clear_keyboard
 2372               	clear_keyboard:
 2373               	.LFB33:
 961:quantum/action.c ****     clear_mods();
 2374               		.loc 1 961 27 view -0
 2375               		.cfi_startproc
 2376               	/* prologue: function */
 2377               	/* frame size = 0 */
 2378               	/* stack size = 0 */
 2379               	.L__stack_usage = 0
 962:quantum/action.c ****     clear_keyboard_but_mods();
 2380               		.loc 1 962 5 view .LVU605
 2381 0000 0E94 0000 		call clear_mods
 2382               	.LVL203:
 963:quantum/action.c **** }
 2383               		.loc 1 963 5 view .LVU606
 2384 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2385               	.LVL204:
 2386               		.cfi_endproc
 2387               	.LFE33:
 2389               		.section	.text.is_tap_action,"ax",@progbits
 2390               	.global	is_tap_action
 2392               	is_tap_action:
 2393               	.LVL205:
 2394               	.LFB38:
 987:quantum/action.c **** #ifdef MOUSEKEY_ENABLE
 988:quantum/action.c ****     mousekey_clear();
 989:quantum/action.c ****     mousekey_send();
 990:quantum/action.c **** #endif
 991:quantum/action.c **** }
 992:quantum/action.c **** 
 993:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 994:quantum/action.c ****  *
 995:quantum/action.c ****  * FIXME: Needs documentation.
 996:quantum/action.c ****  */
 997:quantum/action.c **** bool is_tap_key(keypos_t key) {
 998:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 999:quantum/action.c ****     return is_tap_action(action);
1000:quantum/action.c **** }
1001:quantum/action.c **** 
1002:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1003:quantum/action.c ****  *
1004:quantum/action.c ****  * FIXME: Needs documentation.
1005:quantum/action.c ****  */
1006:quantum/action.c **** bool is_tap_record(keyrecord_t *record) {
1007:quantum/action.c **** #ifdef COMBO_ENABLE
1008:quantum/action.c ****     action_t action;
1009:quantum/action.c ****     if (record->keycode) {
1010:quantum/action.c ****         action = action_for_keycode(record->keycode);
1011:quantum/action.c ****     } else {
1012:quantum/action.c ****         action = layer_switch_get_action(record->event.key);
1013:quantum/action.c ****     }
1014:quantum/action.c **** #else
1015:quantum/action.c ****     action_t action = layer_switch_get_action(record->event.key);
1016:quantum/action.c **** #endif
1017:quantum/action.c ****     return is_tap_action(action);
1018:quantum/action.c **** }
1019:quantum/action.c **** 
1020:quantum/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
1021:quantum/action.c ****  *
1022:quantum/action.c ****  * FIXME: Needs documentation.
1023:quantum/action.c ****  */
1024:quantum/action.c **** bool is_tap_action(action_t action) {
 2395               		.loc 1 1024 37 view -0
 2396               		.cfi_startproc
 2397               	/* prologue: function */
 2398               	/* frame size = 0 */
 2399               	/* stack size = 0 */
 2400               	.L__stack_usage = 0
1025:quantum/action.c ****     switch (action.kind.id) {
 2401               		.loc 1 1025 5 view .LVU608
 2402               		.loc 1 1025 24 is_stmt 0 view .LVU609
 2403 0000 E92F      		mov r30,r25
 2404 0002 E295      		swap r30
 2405 0004 EF70      		andi r30,lo8(15)
 2406               		.loc 1 1025 5 view .LVU610
 2407 0006 E250      		subi r30,lo8(-(-2))
 2408 0008 EE30      		cpi r30,lo8(14)
 2409 000a 00F4      		brsh .L256
 2410 000c F0E0      		ldi r31,0
 2411 000e E050      		subi r30,lo8(-(gs(.L250)))
 2412 0010 F040      		sbci r31,hi8(-(gs(.L250)))
 2413 0012 0C94 0000 		jmp __tablejump2__
 2414               		.section	.jumptables.gcc.is_tap_action,"a",@progbits
 2415               		.p2align	1
 2416               	.L250:
 2417 0000 0000      		.word gs(.L251)
 2418 0002 0000      		.word gs(.L251)
 2419 0004 0000      		.word gs(.L256)
 2420 0006 0000      		.word gs(.L256)
 2421 0008 0000      		.word gs(.L252)
 2422 000a 0000      		.word gs(.L256)
 2423 000c 0000      		.word gs(.L256)
 2424 000e 0000      		.word gs(.L256)
 2425 0010 0000      		.word gs(.L251)
 2426 0012 0000      		.word gs(.L251)
 2427 0014 0000      		.word gs(.L249)
 2428 0016 0000      		.word gs(.L256)
 2429 0018 0000      		.word gs(.L256)
 2430 001a 0000      		.word gs(.L249)
 2431               		.section	.text.is_tap_action
 2432               	.L251:
1026:quantum/action.c ****         case ACT_LMODS_TAP:
1027:quantum/action.c ****         case ACT_RMODS_TAP:
1028:quantum/action.c ****         case ACT_LAYER_TAP:
1029:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
1030:quantum/action.c ****             switch (action.layer_tap.code) {
 2433               		.loc 1 1030 13 is_stmt 1 view .LVU611
 2434 0016 803F      		cpi r24,lo8(-16)
 2435 0018 01F0      		breq .L259
 2436 001a 00F4      		brsh .L253
 2437 001c 883E      		cpi r24,lo8(-24)
 2438 001e 00F4      		brsh .L256
 2439               	.L259:
1031:quantum/action.c ****                 case KC_NO ... KC_RGUI:
1032:quantum/action.c ****                 case OP_TAP_TOGGLE:
1033:quantum/action.c ****                 case OP_ONESHOT:
1034:quantum/action.c ****                     return true;
 2440               		.loc 1 1034 28 is_stmt 0 view .LVU612
 2441 0020 81E0      		ldi r24,lo8(1)
 2442               	.LVL206:
 2443               	/* epilogue start */
1035:quantum/action.c ****             }
1036:quantum/action.c ****             return false;
1037:quantum/action.c ****         case ACT_SWAP_HANDS:
1038:quantum/action.c ****             switch (action.swap.code) {
1039:quantum/action.c ****                 case KC_NO ... KC_RGUI:
1040:quantum/action.c ****                 case OP_SH_TAP_TOGGLE:
1041:quantum/action.c ****                     return true;
1042:quantum/action.c ****             }
1043:quantum/action.c ****             return false;
1044:quantum/action.c ****         case ACT_MACRO:
1045:quantum/action.c ****         case ACT_FUNCTION:
1046:quantum/action.c ****             if (action.func.opt & FUNC_TAP) {
1047:quantum/action.c ****                 return true;
1048:quantum/action.c ****             }
1049:quantum/action.c ****             return false;
1050:quantum/action.c ****     }
1051:quantum/action.c ****     return false;
1052:quantum/action.c **** }
 2444               		.loc 1 1052 1 view .LVU613
 2445 0022 0895      		ret
 2446               	.LVL207:
 2447               	.L253:
 2448               		.loc 1 1052 1 view .LVU614
 2449 0024 843F      		cpi r24,lo8(-12)
 2450 0026 01F0      		breq .L259
 2451               	.L256:
1036:quantum/action.c ****         case ACT_SWAP_HANDS:
 2452               		.loc 1 1036 20 view .LVU615
 2453 0028 80E0      		ldi r24,0
 2454               	.LVL208:
1036:quantum/action.c ****         case ACT_SWAP_HANDS:
 2455               		.loc 1 1036 20 view .LVU616
 2456 002a 0895      		ret
 2457               	.LVL209:
 2458               	.L252:
1038:quantum/action.c ****                 case KC_NO ... KC_RGUI:
 2459               		.loc 1 1038 13 is_stmt 1 view .LVU617
 2460 002c 883E      		cpi r24,lo8(-24)
 2461 002e 00F0      		brlo .L259
 2462 0030 813F      		cpi r24,lo8(-15)
 2463 0032 01F4      		brne .L256
 2464 0034 00C0      		rjmp .L259
 2465               	.L249:
1046:quantum/action.c ****                 return true;
 2466               		.loc 1 1046 13 view .LVU618
1046:quantum/action.c ****                 return true;
 2467               		.loc 1 1046 16 is_stmt 0 view .LVU619
 2468 0036 93FB      		bst r25,3
 2469 0038 8827      		clr r24
 2470 003a 80F9      		bld r24,0
 2471               	.LVL210:
1046:quantum/action.c ****                 return true;
 2472               		.loc 1 1046 16 view .LVU620
 2473 003c 0895      		ret
 2474               		.cfi_endproc
 2475               	.LFE38:
 2477               		.section	.text.is_tap_key,"ax",@progbits
 2478               	.global	is_tap_key
 2480               	is_tap_key:
 2481               	.LVL211:
 2482               	.LFB36:
 997:quantum/action.c ****     action_t action = layer_switch_get_action(key);
 2483               		.loc 1 997 31 is_stmt 1 view -0
 2484               		.cfi_startproc
 2485               	/* prologue: function */
 2486               	/* frame size = 0 */
 2487               	/* stack size = 0 */
 2488               	.L__stack_usage = 0
 998:quantum/action.c ****     return is_tap_action(action);
 2489               		.loc 1 998 5 view .LVU622
 998:quantum/action.c ****     return is_tap_action(action);
 2490               		.loc 1 998 23 is_stmt 0 view .LVU623
 2491 0000 0E94 0000 		call layer_switch_get_action
 2492               	.LVL212:
 999:quantum/action.c **** }
 2493               		.loc 1 999 5 is_stmt 1 view .LVU624
 999:quantum/action.c **** }
 2494               		.loc 1 999 12 is_stmt 0 view .LVU625
 2495 0004 0C94 0000 		jmp is_tap_action
 2496               	.LVL213:
 2497               		.cfi_endproc
 2498               	.LFE36:
 2500               		.section	.text.is_tap_record,"ax",@progbits
 2501               	.global	is_tap_record
 2503               	is_tap_record:
 2504               	.LVL214:
 2505               	.LFB37:
1006:quantum/action.c **** #ifdef COMBO_ENABLE
 2506               		.loc 1 1006 41 is_stmt 1 view -0
 2507               		.cfi_startproc
 2508               	/* prologue: function */
 2509               	/* frame size = 0 */
 2510               	/* stack size = 0 */
 2511               	.L__stack_usage = 0
1015:quantum/action.c **** #endif
 2512               		.loc 1 1015 5 view .LVU627
1015:quantum/action.c **** #endif
 2513               		.loc 1 1015 23 is_stmt 0 view .LVU628
 2514 0000 FC01      		movw r30,r24
 2515 0002 8081      		ld r24,Z
 2516 0004 9181      		ldd r25,Z+1
 2517               	.LVL215:
1015:quantum/action.c **** #endif
 2518               		.loc 1 1015 23 view .LVU629
 2519 0006 0E94 0000 		call layer_switch_get_action
 2520               	.LVL216:
1017:quantum/action.c **** }
 2521               		.loc 1 1017 5 is_stmt 1 view .LVU630
1017:quantum/action.c **** }
 2522               		.loc 1 1017 12 is_stmt 0 view .LVU631
 2523 000a 0C94 0000 		jmp is_tap_action
 2524               	.LVL217:
 2525               		.cfi_endproc
 2526               	.LFE37:
 2528               		.section	.text.debug_event,"ax",@progbits
 2529               	.global	debug_event
 2531               	debug_event:
 2532               	.LFB39:
1053:quantum/action.c **** 
1054:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1055:quantum/action.c ****  *
1056:quantum/action.c ****  * FIXME: Needs documentation.
1057:quantum/action.c ****  */
1058:quantum/action.c **** void debug_event(keyevent_t event) { dprintf("%04X%c(%u)", (event.key.row << 8 | event.key.col), (e
 2533               		.loc 1 1058 36 is_stmt 1 view -0
 2534               		.cfi_startproc
 2535 0000 CF93      		push r28
 2536               	.LCFI29:
 2537               		.cfi_def_cfa_offset 3
 2538               		.cfi_offset 28, -2
 2539 0002 DF93      		push r29
 2540               	.LCFI30:
 2541               		.cfi_def_cfa_offset 4
 2542               		.cfi_offset 29, -3
 2543 0004 00D0      		rcall .
 2544 0006 00D0      		rcall .
 2545 0008 0F92      		push __tmp_reg__
 2546               	.LCFI31:
 2547               		.cfi_def_cfa_offset 9
 2548 000a CDB7      		in r28,__SP_L__
 2549 000c DEB7      		in r29,__SP_H__
 2550               	.LCFI32:
 2551               		.cfi_def_cfa_register 28
 2552               	/* prologue: function */
 2553               	/* frame size = 5 */
 2554               	/* stack size = 7 */
 2555               	.L__stack_usage = 7
 2556               		.loc 1 1058 138 view .LVU633
 2557               	/* epilogue start */
 2558               		.loc 1 1058 1 is_stmt 0 view .LVU634
 2559 000e 0F90      		pop __tmp_reg__
 2560 0010 0F90      		pop __tmp_reg__
 2561 0012 0F90      		pop __tmp_reg__
 2562 0014 0F90      		pop __tmp_reg__
 2563 0016 0F90      		pop __tmp_reg__
 2564 0018 DF91      		pop r29
 2565 001a CF91      		pop r28
 2566 001c 0895      		ret
 2567               		.cfi_endproc
 2568               	.LFE39:
 2570               		.section	.text.debug_record,"ax",@progbits
 2571               	.global	debug_record
 2573               	debug_record:
 2574               	.LFB40:
1059:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1060:quantum/action.c ****  *
1061:quantum/action.c ****  * FIXME: Needs documentation.
1062:quantum/action.c ****  */
1063:quantum/action.c **** void debug_record(keyrecord_t record) {
 2575               		.loc 1 1063 39 is_stmt 1 view -0
 2576               		.cfi_startproc
 2577 0000 CF93      		push r28
 2578               	.LCFI33:
 2579               		.cfi_def_cfa_offset 3
 2580               		.cfi_offset 28, -2
 2581 0002 DF93      		push r29
 2582               	.LCFI34:
 2583               		.cfi_def_cfa_offset 4
 2584               		.cfi_offset 29, -3
 2585 0004 00D0      		rcall .
 2586 0006 00D0      		rcall .
 2587 0008 00D0      		rcall .
 2588               	.LCFI35:
 2589               		.cfi_def_cfa_offset 10
 2590 000a CDB7      		in r28,__SP_L__
 2591 000c DEB7      		in r29,__SP_H__
 2592               	.LCFI36:
 2593               		.cfi_def_cfa_register 28
 2594               	/* prologue: function */
 2595               	/* frame size = 6 */
 2596               	/* stack size = 8 */
 2597               	.L__stack_usage = 8
1064:quantum/action.c ****     debug_event(record.event);
 2598               		.loc 1 1064 5 view .LVU636
1065:quantum/action.c **** #ifndef NO_ACTION_TAPPING
1066:quantum/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2599               		.loc 1 1066 77 view .LVU637
 2600               	/* epilogue start */
1067:quantum/action.c **** #endif
1068:quantum/action.c **** }
 2601               		.loc 1 1068 1 is_stmt 0 view .LVU638
 2602 000e 2696      		adiw r28,6
 2603 0010 0FB6      		in __tmp_reg__,__SREG__
 2604 0012 F894      		cli
 2605 0014 DEBF      		out __SP_H__,r29
 2606 0016 0FBE      		out __SREG__,__tmp_reg__
 2607 0018 CDBF      		out __SP_L__,r28
 2608 001a DF91      		pop r29
 2609 001c CF91      		pop r28
 2610 001e 0895      		ret
 2611               		.cfi_endproc
 2612               	.LFE40:
 2614               		.section	.text.debug_action,"ax",@progbits
 2615               	.global	debug_action
 2617               	debug_action:
 2618               	.LVL218:
 2619               	.LFB41:
1069:quantum/action.c **** 
1070:quantum/action.c **** /** \brief Debug print (FIXME: Needs better description)
1071:quantum/action.c ****  *
1072:quantum/action.c ****  * FIXME: Needs documentation.
1073:quantum/action.c ****  */
1074:quantum/action.c **** void debug_action(action_t action) {
 2620               		.loc 1 1074 36 is_stmt 1 view -0
 2621               		.cfi_startproc
 2622               	/* prologue: function */
 2623               	/* frame size = 0 */
 2624               	/* stack size = 0 */
 2625               	.L__stack_usage = 0
1075:quantum/action.c ****     switch (action.kind.id) {
 2626               		.loc 1 1075 5 view .LVU640
1076:quantum/action.c ****         case ACT_LMODS:
1077:quantum/action.c ****             dprint("ACT_LMODS");
1078:quantum/action.c ****             break;
1079:quantum/action.c ****         case ACT_RMODS:
1080:quantum/action.c ****             dprint("ACT_RMODS");
1081:quantum/action.c ****             break;
1082:quantum/action.c ****         case ACT_LMODS_TAP:
1083:quantum/action.c ****             dprint("ACT_LMODS_TAP");
1084:quantum/action.c ****             break;
1085:quantum/action.c ****         case ACT_RMODS_TAP:
1086:quantum/action.c ****             dprint("ACT_RMODS_TAP");
1087:quantum/action.c ****             break;
1088:quantum/action.c ****         case ACT_USAGE:
1089:quantum/action.c ****             dprint("ACT_USAGE");
1090:quantum/action.c ****             break;
1091:quantum/action.c ****         case ACT_MOUSEKEY:
1092:quantum/action.c ****             dprint("ACT_MOUSEKEY");
1093:quantum/action.c ****             break;
1094:quantum/action.c ****         case ACT_LAYER:
1095:quantum/action.c ****             dprint("ACT_LAYER");
1096:quantum/action.c ****             break;
1097:quantum/action.c ****         case ACT_LAYER_MODS:
1098:quantum/action.c ****             dprint("ACT_LAYER_MODS");
1099:quantum/action.c ****             break;
1100:quantum/action.c ****         case ACT_LAYER_TAP:
1101:quantum/action.c ****             dprint("ACT_LAYER_TAP");
1102:quantum/action.c ****             break;
1103:quantum/action.c ****         case ACT_LAYER_TAP_EXT:
1104:quantum/action.c ****             dprint("ACT_LAYER_TAP_EXT");
1105:quantum/action.c ****             break;
1106:quantum/action.c ****         case ACT_MACRO:
1107:quantum/action.c ****             dprint("ACT_MACRO");
1108:quantum/action.c ****             break;
1109:quantum/action.c ****         case ACT_FUNCTION:
1110:quantum/action.c ****             dprint("ACT_FUNCTION");
1111:quantum/action.c ****             break;
1112:quantum/action.c ****         case ACT_SWAP_HANDS:
1113:quantum/action.c ****             dprint("ACT_SWAP_HANDS");
1114:quantum/action.c ****             break;
1115:quantum/action.c ****         default:
1116:quantum/action.c ****             dprint("UNKNOWN");
1117:quantum/action.c ****             break;
1118:quantum/action.c ****     }
1119:quantum/action.c ****     dprintf("[%X:%02X]", action.kind.param >> 8, action.kind.param & 0xff);
 2627               		.loc 1 1119 75 view .LVU641
 2628               	/* epilogue start */
1120:quantum/action.c **** }
 2629               		.loc 1 1120 1 is_stmt 0 view .LVU642
 2630 0000 0895      		ret
 2631               		.cfi_endproc
 2632               	.LFE41:
 2634               		.section	.rodata.CSWTCH.24,"a"
 2637               	CSWTCH.24:
 2638 0000 E200      		.word	226
 2639 0002 E900      		.word	233
 2640 0004 EA00      		.word	234
 2641 0006 B500      		.word	181
 2642 0008 B600      		.word	182
 2643 000a B700      		.word	183
 2644 000c CD00      		.word	205
 2645 000e 8301      		.word	387
 2646 0010 CC00      		.word	204
 2647 0012 8A01      		.word	394
 2648 0014 9201      		.word	402
 2649 0016 9401      		.word	404
 2650 0018 2102      		.word	545
 2651 001a 2302      		.word	547
 2652 001c 2402      		.word	548
 2653 001e 2502      		.word	549
 2654 0020 2602      		.word	550
 2655 0022 2702      		.word	551
 2656 0024 2A02      		.word	554
 2657 0026 B300      		.word	179
 2658 0028 B400      		.word	180
 2659 002a 6F00      		.word	111
 2660 002c 7000      		.word	112
 2661               		.section	.rodata.CSWTCH.23,"a"
 2664               	CSWTCH.23:
 2665 0000 81        		.byte	-127
 2666 0001 82        		.byte	-126
 2667 0002 83        		.byte	-125
 2668               		.section	.bss.swap_state.2819,"aw",@nobits
 2671               	swap_state.2819:
 2672 0000 0000 0000 		.zero	10
 2672      0000 0000 
 2672      0000 
 2673               	.global	disable_action_cache
 2674               		.section	.bss.disable_action_cache,"aw",@nobits
 2677               	disable_action_cache:
 2678 0000 00        		.zero	1
 2679               	.global	swap_held
 2680               		.section	.bss.swap_held,"aw",@nobits
 2683               	swap_held:
 2684 0000 00        		.zero	1
 2685               	.global	swap_hands
 2686               		.section	.bss.swap_hands,"aw",@nobits
 2689               	swap_hands:
 2690 0000 00        		.zero	1
 2691               		.comm	tp_buttons,2,1
 2692               		.text
 2693               	.Letext0:
 2694               		.file 5 "/usr/avr/include/stdint.h"
 2695               		.file 6 "quantum/keycode.h"
 2696               		.file 7 "tmk_core/common/host.h"
 2697               		.file 8 "quantum/mousekey.h"
 2698               		.file 9 "quantum/command.h"
 2699               		.file 10 "quantum/action_code.h"
 2700               		.file 11 "quantum/action.h"
 2701               		.file 12 "quantum/action_layer.h"
 2702               		.file 13 "quantum/action_util.h"
 2703               		.file 14 "quantum/logging/debug.h"
 2704               		.file 15 "quantum/led.h"
 2705               		.file 16 "quantum/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
     /tmp/ccDa8vic.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccDa8vic.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccDa8vic.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccDa8vic.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccDa8vic.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccDa8vic.s:13     .text.process_hand_swap:0000000000000000 process_hand_swap
     /tmp/ccDa8vic.s:2671   .bss.swap_state.2819:0000000000000000 swap_state.2819
     /tmp/ccDa8vic.s:2689   .bss.swap_hands:0000000000000000 swap_hands
     /tmp/ccDa8vic.s:162    .text.process_record_quantum:0000000000000000 process_record_quantum
     /tmp/ccDa8vic.s:162    .text.process_record_quantum:0000000000000000 process_record_quantum.localalias.1
     /tmp/ccDa8vic.s:185    .text.pre_process_record_quantum:0000000000000000 pre_process_record_quantum
     /tmp/ccDa8vic.s:199    .text.action_exec:0000000000000000 action_exec
     /tmp/ccDa8vic.s:344    .text.post_process_record_quantum:0000000000000000 post_process_record_quantum
     /tmp/ccDa8vic.s:363    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
     /tmp/ccDa8vic.s:2683   .bss.swap_held:0000000000000000 swap_held
     /tmp/ccDa8vic.s:413    .text.register_code:0000000000000000 register_code
     /tmp/ccDa8vic.s:2664   .rodata.CSWTCH.23:0000000000000000 CSWTCH.23
     /tmp/ccDa8vic.s:2637   .rodata.CSWTCH.24:0000000000000000 CSWTCH.24
     /tmp/ccDa8vic.s:566    .text.unregister_code:0000000000000000 unregister_code
     /tmp/ccDa8vic.s:656    .text.tap_code_delay:0000000000000000 tap_code_delay
     /tmp/ccDa8vic.s:743    .text.tap_code:0000000000000000 tap_code
     /tmp/ccDa8vic.s:770    .text.register_mods:0000000000000000 register_mods
     /tmp/ccDa8vic.s:799    .text.unregister_mods:0000000000000000 unregister_mods
     /tmp/ccDa8vic.s:828    .text.process_action:0000000000000000 process_action
     /tmp/ccDa8vic.s:2134   .text.process_record:0000000000000000 process_record
     /tmp/ccDa8vic.s:2062   .text.process_record_handler:0000000000000000 process_record_handler
     /tmp/ccDa8vic.s:2233   .text.process_record_nocache:0000000000000000 process_record_nocache
     /tmp/ccDa8vic.s:2677   .bss.disable_action_cache:0000000000000000 disable_action_cache
     /tmp/ccDa8vic.s:2261   .text.register_weak_mods:0000000000000000 register_weak_mods
     /tmp/ccDa8vic.s:2290   .text.unregister_weak_mods:0000000000000000 unregister_weak_mods
     /tmp/ccDa8vic.s:2319   .text.clear_keyboard_but_mods_and_keys:0000000000000000 clear_keyboard_but_mods_and_keys
     /tmp/ccDa8vic.s:2352   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
     /tmp/ccDa8vic.s:2372   .text.clear_keyboard:0000000000000000 clear_keyboard
     /tmp/ccDa8vic.s:2392   .text.is_tap_action:0000000000000000 is_tap_action
     /tmp/ccDa8vic.s:2480   .text.is_tap_key:0000000000000000 is_tap_key
     /tmp/ccDa8vic.s:2503   .text.is_tap_record:0000000000000000 is_tap_record
     /tmp/ccDa8vic.s:2531   .text.debug_event:0000000000000000 debug_event
     /tmp/ccDa8vic.s:2573   .text.debug_record:0000000000000000 debug_record
     /tmp/ccDa8vic.s:2617   .text.debug_action:0000000000000000 debug_action
                            *COM*:0000000000000002 tp_buttons

UNDEFINED SYMBOLS
hand_swap_config
clear_weak_mods
action_tapping_process
layer_switch_get_action
keyboard_report
is_key_pressed
del_key
send_keyboard_report
add_key
add_mods
host_system_send
host_consumer_send
del_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
host_keyboard_leds
led_set
use_oneshot_swaphands
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
default_layer_and
default_layer_or
default_layer_xor
default_layer_set
layer_and
layer_or
layer_xor
layer_state_set
set_oneshot_layer
layer_invert
layer_move
layer_clear
set_oneshot_swaphands
release_oneshot_swaphands
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
clear_mods
__do_copy_data
__do_clear_bss
